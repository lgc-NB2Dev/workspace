"""Python Skia binding module."""

import datetime
import types
import typing
import typing_extensions

import numpy

from . import cms

__version__: str = "132.0b11"

__all__ = [
    "M44",
    "PDF",
    "SVGDOM",
    "V3",
    "V4",
    "AlphaOPAQUE",
    "AlphaTRANSPARENT",
    "AlphaType",
    "AlphaTypeIsOpaque",
    "ApplyPerspectiveClip",
    "AsWinding",
    "AutoCanvasRestore",
    "BBHFactory",
    "BBoxHierarchy",
    "Bitmap",
    "BlendMode",
    "BlendModeCoeff",
    "BlendMode_AsCoeff",
    "BlendMode_Name",
    "BlurMaskFilter",
    "BlurStyle",
    "Budgeted",
    "Canvas",
    "ClipOp",
    "Codec",
    "Color",
    "Color4f",
    "ColorBLACK",
    "ColorBLUE",
    "ColorCYAN",
    "ColorChannel",
    "ColorChannelFlag",
    "ColorDKGRAY",
    "ColorFilter",
    "ColorFilters",
    "ColorGRAY",
    "ColorGREEN",
    "ColorGetA",
    "ColorGetB",
    "ColorGetG",
    "ColorGetR",
    "ColorInfo",
    "ColorLTGRAY",
    "ColorMAGENTA",
    "ColorMatrix",
    "ColorMatrixFilter",
    "ColorRED",
    "ColorSetA",
    "ColorSetARGB",
    "ColorSetRGB",
    "ColorSpace",
    "ColorTRANSPARENT",
    "ColorToHSV",
    "ColorType",
    "ColorTypeBytesPerPixel",
    "ColorTypeIsAlwaysOpaque",
    "ColorTypeValidateAlphaType",
    "ColorWHITE",
    "ColorYELLOW",
    "ComputeIsOpaque",
    "ConvergeMode",
    "CornerPathEffect",
    "CubicResampler",
    "DashPathEffect",
    "Data",
    "DiscretePathEffect",
    "Document",
    "Drawable",
    "DynamicMemoryWStream",
    "EncodedImageFormat",
    "EncodedOrigin",
    "EncodedOriginToMatrix",
    "FILEStream",
    "FILEWStream",
    "FilterMode",
    "Flattanable",
    "Font",
    "FontArguments",
    "FontHinting",
    "FontMetrics",
    "FontMgr",
    "FontParameters",
    "FontStyle",
    "FontStyleSet",
    "GrBackendApi",
    "GrBackendFormat",
    "GrBackendRenderTarget",
    "GrBackendRenderTargets",
    "GrBackendSemaphore",
    "GrBackendTexture",
    "GrColorType",
    "GrContext",
    "GrContextOptions",
    "GrContext_Base",
    "GrDirectContext",
    "GrDirectContexts",
    "GrFlushInfo",
    "GrGLBackendState",
    "GrGLFormat",
    "GrGLFramebufferInfo",
    "GrGLInterface",
    "GrGLTextureInfo",
    "GrImageContext",
    "GrMipmapped",
    "GrMockOptions",
    "GrMockRenderTargetInfo",
    "GrMockTextureInfo",
    "GrProtected",
    "GrPurgeResourceOptions",
    "GrRecordingContext",
    "GrRenderable",
    "GrSemaphoresSubmitted",
    "GrSurfaceOrigin",
    "GrSyncCpu",
    "GrTextureType",
    "GrVkAlloc",
    "GrVkBackendContext",
    "GrVkDrawableInfo",
    "GrVkImageInfo",
    "GrVkYcbcrConversionInfo",
    "GradientShader",
    "HSVToColor",
    "HighContrastConfig",
    "HighContrastFilter",
    "IPoint",
    "IRect",
    "ISize",
    "Image",
    "ImageFilter",
    "ImageFilters",
    "ImageInfo",
    "Line2DPathEffect",
    "LumaColorFilter",
    "MakeNullCanvas",
    "MaskFilter",
    "Matrix",
    "MemoryStream",
    "MipmapBuilder",
    "MipmapMode",
    "NullWStream",
    "Op",
    "OpBuilder",
    "OverdrawColorFilter",
    "Paint",
    "Path",
    "Path1DPathEffect",
    "Path2DPathEffect",
    "PathBuilder",
    "PathDirection",
    "PathEffect",
    "PathFillType",
    "PathFillType_ConvertToNonInverse",
    "PathFillType_IsEvenOdd",
    "PathFillType_IsInverse",
    "PathMeasure",
    "PathOp",
    "PathSegmentMask",
    "PathVerb",
    "PerlinNoiseShader",
    "Picture",
    "PictureRecorder",
    "PixelGeometry",
    "PixelRef",
    "Pixmap",
    "Point",
    "Point3",
    "PreMultiplyARGB",
    "PreMultiplyColor",
    "RGBToHSV",
    "RRect",
    "RSXform",
    "RTreeFactory",
    "Rect",
    "RefCnt",
    "RefCntBase",
    "Region",
    "RuntimeBlendBuilder",
    "RuntimeColorFilterBuilder",
    "RuntimeEffect",
    "RuntimeEffectBuilder",
    "RuntimeEffectBuilderChild",
    "RuntimeEffectBuilderUniform",
    "RuntimeEffectChildPtr",
    "RuntimeEffectResult",
    "RuntimeShaderBuilder",
    "SVGCanvas",
    "SamplingOptions",
    "ScalarInfinity",
    "ScalarNegativeInfinity",
    "Shader",
    "ShaderMaskFilter",
    "Shaders",
    "Simplify",
    "Size",
    "SpanRuntimeEffectChildPtr",
    "Stream",
    "StreamAsset",
    "StreamMemory",
    "StreamRewindable",
    "StreamSeekable",
    "String",
    "StrokeRec",
    "Surface",
    "SurfaceCharacterization",
    "SurfaceProps",
    "Surfaces",
    "TableColorFilter",
    "TableMaskFilter",
    "TextBlob",
    "TextBlobBuilder",
    "TextEncoding",
    "TightBounds",
    "TileMode",
    "TrimPathEffect",
    "Typeface",
    "Unicode",
    "Unicodes",
    "VectorRuntimeEffectChildPtr",
    "Vertices",
    "VkFormat",
    "VkImageLayout",
    "WStream",
    "YUVAInfo",
    "YUVAPixmapInfo",
    "YUVAPixmaps",
    "YUVColorSpace",
    "cms",
    "gpuBackendApi",
    "k2D",
    "kA",
    "kA16_float_ColorType",
    "kA16_unorm_ColorType",
    "kABGR_4444",
    "kALL_GrGLBackendState",
    "kALPHA8",
    "kARGB_4444_ColorType",
    "kASTC",
    "kAllResources",
    "kAlpha_8",
    "kAlpha_8_ColorType",
    "kAlpha_8xxx",
    "kAlpha_16",
    "kAlpha_ColorChannelFlag",
    "kAlpha_F16",
    "kAlpha_F32xxx",
    "kB",
    "kBGRA8",
    "kBGRA_8888",
    "kBGRA_8888_ColorType",
    "kBGRA_1010102_ColorType",
    "kBGR_565",
    "kBGR_101010x_ColorType",
    "kBGR_H_PixelGeometry",
    "kBGR_V_PixelGeometry",
    "kBMP",
    "kBT2020_YUVColorSpace",
    "kBlend_GrGLBackendState",
    "kBlue_ColorChannelFlag",
    "kBottomLeft_EncodedOrigin",
    "kBottomLeft_GrSurfaceOrigin",
    "kBottomRight_EncodedOrigin",
    "kCCW",
    "kCOMPRESSED_ETC1_RGB8",
    "kCOMPRESSED_RGB8_BC1",
    "kCOMPRESSED_RGB8_ETC2",
    "kCOMPRESSED_RGBA8_BC1",
    "kCW",
    "kCenter",
    "kClamp",
    "kClear",
    "kClose",
    "kCoeffCount",
    "kColor",
    "kColorBurn",
    "kColorDodge",
    "kConic",
    "kConic_PathSegmentMask",
    "kCubic",
    "kCubic_PathSegmentMask",
    "kDA",
    "kDC",
    "kDNG",
    "kDarken",
    "kDashed",
    "kDawn",
    "kDecal",
    "kDefault_EncodedOrigin",
    "kDifference",
    "kDifference_PathOp",
    "kDirect3D",
    "kDotted",
    "kDouble",
    "kDst",
    "kDstATop",
    "kDstIn",
    "kDstOut",
    "kDstOver",
    "kEnd",
    "kEvenOdd",
    "kExclusion",
    "kExternal",
    "kFixedFunction_GrGLBackendState",
    "kFull",
    "kG",
    "kGIF",
    "kGaps",
    "kGlyphID",
    "kGray_8",
    "kGray_8_ColorType",
    "kGray_8xxx",
    "kGray_ColorChannelFlag",
    "kGray_F16",
    "kGreen_ColorChannelFlag",
    "kHEIF",
    "kHardLight",
    "kHue",
    "kICO",
    "kIDA",
    "kIDC",
    "kISA",
    "kISC",
    "kIdentity_YUVColorSpace",
    "kInner_BlurStyle",
    "kIntersect",
    "kIntersect_PathOp",
    "kInverseEvenOdd",
    "kInverseWinding",
    "kJPEG",
    "kJPEG_YUVColorSpace",
    "kJustify",
    "kKTX",
    "kLUMINANCE8",
    "kLUMINANCE16F",
    "kLast",
    "kLastCoeffMode",
    "kLastEnum",
    "kLastEnum_AlphaType",
    "kLastEnum_BlurStyle",
    "kLastEnum_YUVColorSpace",
    "kLastMode",
    "kLastSeparableMode",
    "kLastTileMode",
    "kLast_EncodedOrigin",
    "kLeft",
    "kLeftBottom_EncodedOrigin",
    "kLeftTop_EncodedOrigin",
    "kLighten",
    "kLine",
    "kLineThrough",
    "kLine_PathSegmentMask",
    "kLinear",
    "kLuminosity",
    "kMSAAEnable_GrGLBackendState",
    "kMetal",
    "kMirror",
    "kMisc_GrGLBackendState",
    "kMock",
    "kModulate",
    "kMove",
    "kMultiply",
    "kN32_ColorType",
    "kNearest",
    "kNo",
    "kNoDecoration",
    "kNone",
    "kNormal",
    "kNormal_BlurStyle",
    "kOne",
    "kOpaque_AlphaType",
    "kOpenGL",
    "kOpenGL_GrBackend",
    "kOuter_BlurStyle",
    "kOverlay",
    "kOverline",
    "kOverlineLineThrough",
    "kPKM",
    "kPNG",
    "kPixelStore_GrGLBackendState",
    "kPlus",
    "kPremul_AlphaType",
    "kProgram_GrGLBackendState",
    "kQuad",
    "kQuad_PathSegmentMask",
    "kR",
    "kR8",
    "kR8G8_unorm_ColorType",
    "kR16",
    "kR16F",
    "kR16G16B16A16_unorm_ColorType",
    "kR16G16_float_ColorType",
    "kR16G16_unorm_ColorType",
    "kRG8",
    "kRG16",
    "kRG16F",
    "kRGB8",
    "kRGB10_A2",
    "kRGB565",
    "kRGBA4",
    "kRGBA8",
    "kRGBA16",
    "kRGBA16F",
    "kRGBA_8888",
    "kRGBA_8888_ColorType",
    "kRGBA_8888_SRGB",
    "kRGBA_1010102",
    "kRGBA_1010102_ColorType",
    "kRGBA_16161616",
    "kRGBA_ColorChannelFlags",
    "kRGBA_F16",
    "kRGBA_F16Norm_ColorType",
    "kRGBA_F16_Clamped",
    "kRGBA_F16_ColorType",
    "kRGBA_F32",
    "kRGBA_F32_ColorType",
    "kRGB_565_ColorType",
    "kRGB_888",
    "kRGB_888x",
    "kRGB_888x_ColorType",
    "kRGB_101010x_ColorType",
    "kRGB_ColorChannelFlags",
    "kRGB_H_PixelGeometry",
    "kRGB_V_PixelGeometry",
    "kRG_88",
    "kRG_1616",
    "kRG_ColorChannelFlags",
    "kRG_F16",
    "kR_8",
    "kR_16",
    "kR_F16",
    "kRec601_YUVColorSpace",
    "kRec709_YUVColorSpace",
    "kRectangle",
    "kRed_ColorChannelFlag",
    "kRenderTarget_GrGLBackendState",
    "kRepeat",
    "kReverseDifference",
    "kReverseDifference_PathOp",
    "kRight",
    "kRightBottom_EncodedOrigin",
    "kRightTop_EncodedOrigin",
    "kSA",
    "kSC",
    "kSRGB8_ALPHA8",
    "kSaturation",
    "kScratchResourcesOnly",
    "kScreen",
    "kSlight",
    "kSoftLight",
    "kSolid",
    "kSolid_BlurStyle",
    "kSrc",
    "kSrcATop",
    "kSrcIn",
    "kSrcOut",
    "kSrcOver",
    "kStart",
    "kStencil_GrGLBackendState",
    "kTextureBinding_GrGLBackendState",
    "kThrough",
    "kTopLeft_EncodedOrigin",
    "kTopLeft_GrSurfaceOrigin",
    "kTopRight_EncodedOrigin",
    "kUTF8",
    "kUTF16",
    "kUTF32",
    "kUnderline",
    "kUnderlineLineThrough",
    "kUnderlineOverline",
    "kUnderlineOverlineLineThrough",
    "kUnion",
    "kUnion_PathOp",
    "kUnknown",
    "kUnknown_AlphaType",
    "kUnknown_ColorType",
    "kUnknown_PixelGeometry",
    "kUnpremul_AlphaType",
    "kVertex_GrGLBackendState",
    "kView_GrGLBackendState",
    "kVulkan",
    "kWBMP",
    "kWEBP",
    "kWavy",
    "kWinding",
    "kXOR_PathOp",
    "kXor",
    "kYes",
    "kZero",
    "skgpu",
    "textlayout",
    "textlayout_FontCollection",
    "textlayout_Paragraph",
    "textlayout_ParagraphBuilder",
    "textlayout_ParagraphStyle",
    "textlayout_TextAlign",
    "textlayout_TextDecoration",
    "textlayout_TextDecorationMode",
    "textlayout_TextDecorationStyle",
    "textlayout_TextStyle",
]

class AlphaType:
    """
    Members:

      kUnknown_AlphaType : uninitialized

      kOpaque_AlphaType : pixel is opaque

      kPremul_AlphaType : pixel components are premultiplied by alpha

      kUnpremul_AlphaType : pixel components are independent of alpha

      kLastEnum_AlphaType : last valid value
    """

    __members__: typing.ClassVar[
        dict[str, AlphaType]
    ]  # value = {'kUnknown_AlphaType': <AlphaType.kUnknown_AlphaType: 0>, 'kOpaque_AlphaType': <AlphaType.kOpaque_AlphaType: 1>, 'kPremul_AlphaType': <AlphaType.kPremul_AlphaType: 2>, 'kUnpremul_AlphaType': <AlphaType.kUnpremul_AlphaType: 3>, 'kLastEnum_AlphaType': <AlphaType.kUnpremul_AlphaType: 3>}
    kLastEnum_AlphaType: typing.ClassVar[
        AlphaType
    ]  # value = <AlphaType.kUnpremul_AlphaType: 3>
    kOpaque_AlphaType: typing.ClassVar[
        AlphaType
    ]  # value = <AlphaType.kOpaque_AlphaType: 1>
    kPremul_AlphaType: typing.ClassVar[
        AlphaType
    ]  # value = <AlphaType.kPremul_AlphaType: 2>
    kUnknown_AlphaType: typing.ClassVar[
        AlphaType
    ]  # value = <AlphaType.kUnknown_AlphaType: 0>
    kUnpremul_AlphaType: typing.ClassVar[
        AlphaType
    ]  # value = <AlphaType.kUnpremul_AlphaType: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ApplyPerspectiveClip:
    """
    Members:

      kNo : Don't pre-clip the geometry before applying the (perspective) matrix.

      kYes : Do pre-clip the geometry before applying the (perspective) matrix.
    """

    __members__: typing.ClassVar[
        dict[str, ApplyPerspectiveClip]
    ]  # value = {'kNo': <ApplyPerspectiveClip.kNo: 0>, 'kYes': <ApplyPerspectiveClip.kYes: 1>}
    kNo: typing.ClassVar[ApplyPerspectiveClip]  # value = <ApplyPerspectiveClip.kNo: 0>
    kYes: typing.ClassVar[
        ApplyPerspectiveClip
    ]  # value = <ApplyPerspectiveClip.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AutoCanvasRestore:
    """

    Stack helper class calls :py:meth:`Canvas.restoreToCount` when
    :py:class:`AutoCanvasRestore` goes out of scope.

    Use this to guarantee that the canvas is restored to a known state.

    Example::

        with skia.AutoCanvasRestore(canvas):
            canvas.drawCircle(50.0, 50.0, 10.0, paint)


    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...
    def __init__(self, canvas: Canvas, doSave: bool = True) -> None:
        """
        Preserves :py:meth:`Canvas.save` count.

        Optionally saves :py:class:`Canvas` clip and :py:class:`Canvas` matrix.

        :param skia.Canvas canvas: :py:class:`Canvas` to guard
        :param bool doSave: call :py:meth:`Canvas.save`
        :return: utility to restore :py:class:`Canvas` state on destructor
        """
    def restore(self) -> None:
        """
        Restores :py:class:`Canvas` to saved state immediately.

        Subsequent calls and destructor have no effect.
        """

class BBHFactory:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class BBoxHierarchy(RefCnt):
    class Metadata:
        isDraw: bool
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...

    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def bytesUsed(self) -> int:
        """
        Return approximate size in memory of this.
        """
    @typing.overload
    def insert(self, rects: Rect, N: int) -> None:
        """
        Insert N bounding boxes into the hierarchy.
        """
    @typing.overload
    def insert(self, rects: Rect, metadata: BBoxHierarchy.Metadata, N: int) -> None: ...
    def search(self, query: Rect, results: ..., std: ...) -> None:
        """
        Populate results with the indices of bounding boxes intersecting that
        query.
        """

class Bitmap:
    """

    :py:class:`Bitmap` describes a two-dimensional raster pixel array.

    :py:class:`Bitmap` is built on :py:class:`ImageInfo`, containing integer
    width and height, :py:class:`ColorType` and :py:class:`AlphaType` describing
    the pixel format, and :py:class:`ColorSpace` describing the range of colors.
    :py:class:`Bitmap` points to :py:class:`PixelRef`, which describes the
    physical array of pixels. :py:class:`ImageInfo` bounds may be located
    anywhere fully inside :py:class:`PixelRef` bounds.

    :py:class:`Bitmap` can be drawn using :py:class:`Canvas`.
    :py:class:`Bitmap` can be a drawing destination for :py:class:`Canvas` draw
    member functions. :py:class:`Bitmap` flexibility as a pixel container limits
    some optimizations available to the target platform.

    If pixel array is primarily read-only, use :py:class:`Image` for better
    performance. If pixel array is primarily written to, use
    :py:class:`Surface` for better performance.

    Declaring :py:class:`Bitmap` const prevents altering
    :py:class:`ImageInfo`: the :py:class:`Bitmap` height, width, and so on
    cannot change. It does not affect :py:class:`PixelRef`: a caller may write
    its pixels. Declaring :py:class:`Bitmap` const affects :py:class:`Bitmap`
    configuration, not its contents.

    :py:class:`Bitmap` is not thread safe. Each thread must have its own copy of
    :py:class:`Bitmap` fields, although threads may share the underlying pixel
    array.

    :py:class:`Bitmap` supports buffer protocol. It is possible to mount
    :py:class:`Bitmap` as array::

        array = np.array(bitmap, copy=False)

    Or mount array as :py:class:`Bitmap` with :py:class:`ImageInfo`::

        buffer = np.zeros((100, 100, 4), np.uint8)
        bitmap = skia.Bitmap()
        bitmap.setInfo(skia.ImageInfo.MakeN32Premul(100, 100))
        bitmap.setPixels(buffer)


    """
    class AllocFlags:
        """
        Members:

          kZeroPixels_AllocFlag :
                zero pixel memory. No effect. This is the default.

        """

        __members__: typing.ClassVar[
            dict[str, Bitmap.AllocFlags]
        ]  # value = {'kZeroPixels_AllocFlag': <AllocFlags.kZeroPixels_AllocFlag: 1>}
        kZeroPixels_AllocFlag: typing.ClassVar[
            Bitmap.AllocFlags
        ]  # value = <AllocFlags.kZeroPixels_AllocFlag: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kZeroPixels_AllocFlag: typing.ClassVar[
        Bitmap.AllocFlags
    ]  # value = <AllocFlags.kZeroPixels_AllocFlag: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.Any) -> int: ...
    def __init__(self, src: Bitmap | None = None) -> None:
        """
        Creates a :py:class:`Bitmap`.

        When ``src`` is given, copies settings from src to returned
        :py:class:`Bitmap`.

        Shares pixels if src has pixels allocated, so both bitmaps reference the
        same pixels.

        When ``src`` is ``None``, creates an empty :py:class:`Bitmap` without
        pixels, with :py:attr:`~ColorType.kUnknown_ColorType`,
        :py:attr:`~AlphaType.kUnknown_AlphaType`, and with a width and height of
        zero.

        :py:class:`PixelRef` origin is set to (0, 0). :py:class:`Bitmap` is not
        volatile.

        Use :py:meth:`setInfo` to associate :py:class:`ColorType`,
        :py:class:`AlphaType`, width, and height after :py:class:`Bitmap` has
        been created.

        :param: src :py:class:`Bitmap` to copy :py:class:`ImageInfo`, and share
            :py:class:`PixelRef`
        """
    def __len__(self) -> int: ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def allocN32Pixels(self, width: int, height: int, isOpaque: bool) -> None:
        """
        Sets :py:class:`ImageInfo` to width, height, and the native color type;
        and allocates pixel memory.

        If isOpaque is true, sets :py:class:`ImageInfo` to
        :py:attr:`~AlphaType.kOpaque_AlphaType`; otherwise, sets to
        :py:attr:`~AlphaType.kPremul_AlphaType`.

        Aborts if width exceeds 29 bits or is negative, or height is negative,
        or allocation fails. Abort steps may be provided by the user at compile
        time by defining SK_ABORT.

        Use to create :py:class:`Bitmap` that matches :py:class:`PMColor`, the
        native pixel arrangement on the platform. :py:class:`Bitmap` drawn to
        output device skips converting its pixel format.

        :param int width: pixel column count; must be zero or greater
        :param int height: pixel row count; must be zero or greater
        :param bool isOpaque: true if pixels do not have transparency
        """
    def allocPixels(self, info: ImageInfo | None = None, rowBytes: int = 0) -> None:
        """
        Sets :py:class:`ImageInfo` to info following the rules in
        :py:meth:`setInfo` and allocates pixel memory.

        rowBytes must equal or exceed info.:py:meth:`width` times
        info.bytesPerPixel, or equal zero. Pass in zero for rowBytes to compute
        the minimum valid value.

        Aborts execution if :py:class:`ImageInfo` could not be set, or memory
        could not be allocated. Abort steps may be provided by the user at
        compile time by defining SK_ABORT.

        On most platforms, allocating pixel memory may succeed even though there
        is not sufficient memory to hold pixels; allocation does not take place
        until the pixels are written to. The actual behavior depends on the
        platform implementation of :py:meth:`malloc`.

        :param skia.ImageInfo info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param int rowBytes: size of pixel row or larger; may be zero
        """
    def allocPixelsFlags(self, info: ImageInfo, flags: int) -> None:
        """
        Sets :py:class:`ImageInfo` to info following the rules in
        :py:meth:`setInfo` and allocates pixel memory.

        Memory is zeroed.

        Aborts execution if :py:class:`ImageInfo` could not be set, or memory
        could not be allocated, or memory could not optionally be zeroed. Abort
        steps may be provided by the user at compile time by defining SK_ABORT.

        On most platforms, allocating pixel memory may succeed even though there
        is not sufficient memory to hold pixels; allocation does not take place
        until the pixels are written to. The actual behavior depends on the
        platform implementation of ``calloc``.

        :param skia.ImageInfo info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param int flags: :py:attr:`kZeroPixels_AllocFlag`, or zero
        """
    def alphaType(self) -> AlphaType: ...
    def bounds(self) -> IRect:
        """
        Returns :py:class:`IRect` { 0, 0, :py:meth:`width`, :py:meth:`height` }.

        :return: integral rectangle from origin to :py:meth:`width` and
            :py:meth:`height`
        """
    def bytesPerPixel(self) -> int:
        """
        Returns number of bytes per pixel required by :py:class:`ColorType`.

        Returns zero if colorType( is :py:attr:`ColorType.kUnknown_ColorType`.

        :return: bytes in pixel
        """
    def colorSpace(self) -> ColorSpace:
        """
        Returns :py:class:`ColorSpace`, the range of colors, associated with
        :py:class:`ImageInfo`.

        The reference count of :py:class:`ColorSpace` is unchanged. The returned
        :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace` in :py:class:`ImageInfo`, or nullptr
        """
    def colorType(self) -> ColorType: ...
    def computeByteSize(self) -> int:
        """
        Returns minimum memory required for pixel storage.

        Does not include unused memory on last row when
        :py:meth:`rowBytesAsPixels` exceeds :py:meth:`width`. Returns SIZE_MAX
        if result does not fit in size_t. Returns zero if :py:meth:`height` or
        :py:meth:`width` is 0. Returns :py:meth:`height` times
        :py:meth:`rowBytes` if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: size in bytes of image buffer
        """
    def dimensions(self) -> ISize:
        """
        Returns :py:class:`ISize` { :py:meth:`width`, :py:meth:`height` }.

        :return: integral size of :py:meth:`width` and :py:meth:`height`
        """
    def drawsNothing(self) -> bool:
        """
        Returns true if :py:meth:`width` or :py:meth:`height` are zero, or if
        :py:class:`PixelRef` is nullptr.

        If true, :py:class:`Bitmap` has no effect when drawn or drawn into.

        :return: true if drawing has no effect
        """
    def empty(self) -> bool:
        """
        Returns true if either :py:meth:`width` or :py:meth:`height` are zero.

        Does not check if :py:class:`PixelRef` is nullptr; call
        :py:meth:`drawsNothing` to check :py:meth:`width`, :py:meth:`height`,
        and :py:class:`PixelRef`.

        :return: true if dimensions do not enclose area
        """
    @typing.overload
    def erase(self, c: Color4f, area: IRect) -> None:
        """
        Replaces pixel values inside area with c.

        interpreted as being in the sRGB :py:class:`ColorSpace`. If area does
        not intersect bounds(), call has no effect.

        If the colorType() is :py:attr:`~ColorType.kGray_8_ColorType` or
        :py:attr:`~ColorType.kRGB_565_ColorType`, then alpha is ignored; RGB is
        treated as opaque. If colorType() is
        :py:attr:`~ColorType.kAlpha_8_ColorType`, then RGB is ignored.

        :param int c: unpremultiplied color
        :param skia.IRect area: rectangle to fill
        """
    @typing.overload
    def erase(self, c: int, area: IRect) -> None:
        """
        Deprecated.

        :param int c: unpremultiplied color
        :param skia.IRect area: rectangle to fill
        """
    def eraseARGB(self, a: int, r: int, g: int, b: int) -> None:
        """
        Replaces pixel values with unpremultiplied color built from a, r, g, and
        b, interpreted as being in the sRGB :py:class:`ColorSpace`.

        All pixels contained by bounds() are affected. If the colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType` or
        :py:attr:`~ColorType.kRGB_565_ColorType`, then alpha is ignored; RGB is
        treated as opaque. If colorType() is
        :py:attr:`~ColorType.kAlpha_8_ColorType`, then RGB is ignored.

        :param int a: amount of alpha, from fully transparent (0) to fully
            opaque (255)
        :param int r: amount of red, from no red (0) to full red (255)
        :param int g: amount of green, from no green (0) to full green (255)
        :param int b: amount of blue, from no blue (0) to full blue (255)
        """
    def extractAlpha(
        self,
        dst: Bitmap,
        paint: Paint | None = None,
        offset: IPoint | None = None,
    ) -> bool:
        """
        Sets dst to alpha described by pixels.

        Returns false if dst cannot be written to or dst pixels cannot be
        allocated.

        If paint is not nullptr and contains :py:class:`MaskFilter`,
        :py:class:`MaskFilter` generates mask alpha from :py:class:`Bitmap`.
        Uses HeapAllocator to reserve memory for dst :py:class:`PixelRef`. Sets
        offset to top-left position for dst for alignment with
        :py:class:`Bitmap`; (0, 0) unless :py:class:`MaskFilter` generates mask.

        :param dst: holds :py:class:`PixelRef` to fill with alpha layer
        :param paint: holds optional :py:class:`MaskFilter`; may be nullptr
        :param offset: top-left position for dst; may be nullptr
        :return: true if alpha layer was constructed in dst :py:class:`PixelRef`
        """
    def extractSubset(self, dst: Bitmap, subset: IRect) -> bool:
        """
        Shares :py:class:`PixelRef` with dst.

        Pixels are not copied; :py:class:`Bitmap` and dst point to the same
        pixels; dst :py:meth:`bounds` are set to the intersection of subset and
        the original :py:meth:`bounds`.

        subset may be larger than :py:meth:`bounds`. Any area outside of
        :py:meth:`bounds` is ignored.

        Any contents of dst are discarded. :py:meth:`isVolatile` setting is
        copied to dst. dst is set to :py:meth:`colorType`, :py:meth:`alphaType`,
        and :py:meth:`colorSpace`.

        Return false if:

        - dst is nullptr
        - :py:class:`PixelRef` is nullptr
        - subset does not intersect :py:meth:`bounds`

        :param dst: :py:class:`Bitmap` set to subset
        :param subset: rectangle of pixels to reference
        :return: true if dst is replaced by subset
        """
    def getAlphaf(self, x: int, y: int) -> float:
        """
        Look up the pixel at (x,y) and return its alpha component, normalized to
        [0..1].

        This is roughly equivalent to :py:func:`GetColorA` of
        :py:meth:`getColor`, but can be more efficent (and more precise if the
        pixels store more than 8 bits per component).

        :param int x: column index, zero or greater, and less than
            :py:meth:`width`
        :param int y: row index, zero or greater, and less than
            :py:meth:`height`
        :return: alpha converted to normalized float
        """
    def getBounds(self) -> IRect:
        """
        Returns :py:class:`IRect` { 0, 0, :py:meth:`width`, :py:meth:`height` }.

        :return: integral rectangle
        """
    def getColor(self, x: int, y: int) -> int:
        """
        Returns pixel at (x, y) as unpremultiplied color.

        Returns black with alpha if :py:class:`ColorType` is
        :py:attr:`~ColorType.kAlpha_8_ColorType`.

        Input is not validated: out of bounds values of x or y trigger an
        assert() if built with SK_DEBUG defined; and returns undefined values or
        may crash if SK_RELEASE is defined. Fails if :py:class:`ColorType` is
        :py:attr:`~ColorType.kUnknown_ColorType` or pixel address is nullptr.

        :py:class:`ColorSpace` in :py:class:`ImageInfo` is ignored. Some color
        precision may be lost in the conversion to unpremultiplied color;
        original pixel data may have additional precision.

        :param int x: column index, zero or greater, and less than width()
        :param int y: row index, zero or greater, and less than height()
        :return: pixel converted to unpremultiplied color
        """
    def getGenerationID(self) -> int:
        """
        Returns a unique value corresponding to the pixels in
        :py:class:`PixelRef`.

        Returns a different value after :py:meth:`notifyPixelsChanged` has been
        called. Returns zero if :py:class:`PixelRef` is nullptr.

        Determines if pixels have changed since last examined.

        :return: unique value for pixels in :py:class:`PixelRef`
        """
    def getPixels(self) -> typing.Any:
        """
        Returns pixel address, the base address corresponding to the pixel
        origin.

        :return: pixel address
        """
    def getSubset(self) -> IRect:
        """
        Returns the bounds of this bitmap, offset by its :py:class:`PixelRef`
        origin.

        :return: bounds within :py:class:`PixelRef` bounds
        """
    def height(self) -> int:
        """
        Returns pixel row count.

        Maybe be less than :py:meth:`pixelRef` . :py:meth:`height`. Will not
        exceed :py:meth:`pixelRef` . :py:meth:`height` less
        :py:meth:`pixelRefOrigin` . fY.

        :return: pixel height in :py:class:`ImageInfo`
        """
    def info(self) -> ImageInfo:
        """
        Returns width, height, :py:class:`AlphaType`, :py:class:`ColorType`, and
        :py:class:`ColorSpace`.

        :return: reference to :py:class:`ImageInfo`
        """
    @typing.overload
    def installPixels(
        self,
        info: ImageInfo,
        pixels: typing.Any,
        rowBytes: int,
    ) -> bool:
        """
        Sets :py:class:`ImageInfo` to info following the rules in
        :py:meth:`setInfo`, and creates :py:class:`PixelRef` containing pixels
        and rowBytes.

        If :py:class:`ImageInfo` could not be set, or rowBytes is less than
        info.minRowBytes(): calls :py:meth:`reset`, and returns false.

        Otherwise, if pixels equals nullptr: sets :py:class:`ImageInfo`, returns
        true.

        Caller must ensure that pixels are valid for the lifetime of
        :py:class:`Bitmap` and :py:class:`PixelRef`.

        :info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :pixels: address or pixel storage buffer; may be nullptr
        :rowBytes: size of pixel row or larger
        :return: true if :py:class:`ImageInfo` is set to info
        """
    @typing.overload
    def installPixels(self, pixmap: Pixmap) -> bool:
        """
        Sets :py:class:`ImageInfo` to pixmap.info() following the rules in
        :py:meth:`setInfo`, and creates :py:class:`PixelRef` containing
        pixmap.addr() and pixmap.rowBytes().

        If :py:class:`ImageInfo` could not be set, or pixmap.rowBytes() is less
        than :py:meth:`ImageInfo.minRowBytes` : calls :py:meth:`reset`, and
        returns false.

        Otherwise, if pixmap.addr() equals nullptr: sets :py:class:`ImageInfo`,
        returns true.

        Caller must ensure that pixmap is valid for the lifetime of
        :py:class:`Bitmap` and :py:class:`PixelRef`.

        :pixmap: :py:class:`ImageInfo`, pixel address, and rowBytes()
        :return: true if :py:class:`ImageInfo` was set to pixmap.info()
        """
    def isImmutable(self) -> bool:
        """
        Returns true if pixels can not change.

        Most immutable :py:class:`Bitmap` checks trigger an assert only on debug
        builds.

        :return: true if pixels are immutable
        """
    def isNull(self) -> bool:
        """
        Returns true if :py:class:`PixelRef` is nullptr.

        Does not check if :py:meth:`width` or :py:meth:`height` are zero; call
        :py:meth:`drawsNothing` to check :py:meth:`width`, :py:meth:`height`,
        and :py:class:`PixelRef`.

        :return: true if no :py:class:`PixelRef` is associated
        """
    def isOpaque(self) -> bool:
        """
        Returns true if :py:class:`AlphaType` is set to hint that all pixels are
        opaque; their alpha value is implicitly or explicitly 1.0.

        If true, and all pixels are not opaque, Skia may draw incorrectly.

        Does not check if :py:class:`ColorType` allows alpha, or if any pixel
        value has transparency.

        :return: true if :py:class:`ImageInfo` :py:class:`AlphaType` is
            :py:attr:`~AlphaType.kOpaque_AlphaType`
        """
    def makeShader(
        self,
        tmx: TileMode = ...,
        tmy: TileMode = ...,
        sampling: SamplingOptions = ...,
        localMatrix: Matrix | None = None,
    ) -> Shader: ...
    def notifyPixelsChanged(self) -> None:
        """
        Marks that pixels in :py:class:`PixelRef` have changed.

        Subsequent calls to :py:meth:`getGenerationID` return a different value.
        """
    def peekPixels(self, pixmap: Pixmap) -> bool:
        """
        Copies :py:class:`Bitmap` pixel address, row bytes, and
        :py:class:`ImageInfo` to pixmap, if address is available, and returns
        true.

        If pixel address is not available, return false and leave pixmap
        unchanged.

        pixmap contents become invalid on any future change to
        :py:class:`Bitmap`.

        :param skia.Pixmap pixmap: storage for pixel state if pixels are
            readable; otherwise, ignored
        :return: true if :py:class:`Bitmap` has direct access to pixels
        """
    def pixmap(self) -> Pixmap:
        """
        Returns a constant reference to the :py:class:`Pixmap` holding the
        :py:class:`Bitmap` pixel address, row bytes, and :py:class:`ImageInfo`.

        :return: reference to :py:class:`Pixmap` describing this
            :py:class:`Bitmap`
        """
    @typing.overload
    def readPixels(
        self,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int = 0,
        srcX: int = 0,
        srcY: int = 0,
    ) -> bool:
        """
        Copies a :py:class:`Rect` of pixels from :py:class:`Bitmap` to
        dstPixels.

        Copy starts at (srcX, srcY), and does not exceed :py:class:`Bitmap` (
        :py:meth:`width`, :py:meth:`height`).

        dstInfo specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, and :py:class:`ColorSpace` of destination.
        dstRowBytes specifics the gap from one destination row to the next.
        Returns true if pixels are copied. Returns false if:

        - dstInfo has no address
        - dstRowBytes is less than dstInfo.minRowBytes()
        - :py:class:`PixelRef` is nullptr

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; dstInfo.colorType() must
        match. If :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, dstInfo.colorSpace() must
        match. If :py:class:`Bitmap` alphaType() is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, dstInfo.alphaType() must match.
        If :py:class:`Bitmap` colorSpace() is nullptr, dstInfo.colorSpace() must
        match. Returns false if pixel conversion is not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if width() or height() is zero or negative. Returns false
        if abs(srcX) >= Bitmap width(), or if abs(srcY) >= Bitmap height().

        :dstInfo: destination width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`
        :dstPixels: destination pixel storage
        :dstRowBytes: destination row length
        :srcX: column index whose absolute value is less than :py:meth:`width`
        :srcY: row index whose absolute value is less than :py:meth:`height`
        :return: true if pixels are copied to dstPixels
        """
    @typing.overload
    def readPixels(self, dst: Pixmap, srcX: int = 0, srcY: int = 0) -> bool:
        """
        Copies a :py:class:`Rect` of pixels from :py:class:`Bitmap` to
        dst.

        Copy starts at (srcX, srcY), and does not exceed :py:class:`Bitmap` (
        :py:meth:`width`, :py:meth:`height`).

        dst specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, :py:class:`ColorSpace`, pixel storage, and row
        bytes of destination. dst.rowBytes() specifics the gap from one
        destination row to the next. Returns true if pixels are copied. Returns
        false if:

        - dst pixel storage equals nullptr
        - dst.rowBytes is less than :py:meth:`ImageInfo.minRowBytes`
        - :py:class:`PixelRef` is nullptr

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; dst :py:class:`ColorType` must
        match. If :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, dst :py:class:`ColorSpace` must
        match. If :py:class:`Bitmap` alphaType() is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, dst :py:class:`AlphaType` must
        match. If :py:class:`Bitmap` colorSpace() is nullptr, dst
        :py:class:`ColorSpace` must match. Returns false if pixel conversion is
        not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if width() or height() is zero or negative. Returns false
        if abs(srcX) >= Bitmap width(), or if abs(srcY) >= Bitmap height().

        :dst: destination :py:class:`Pixmap`: :py:class:`ImageInfo`, pixels, row
            bytes
        :srcX: column index whose absolute value is less than width()
        :srcY: row index whose absolute value is less than height()
        :return: true if pixels are copied to dst
        """
    def readyToDraw(self) -> bool:
        """
        Returns true if :py:class:`Bitmap` is can be drawn.

        :return: true if :py:class:`getPixels` is not nullptr
        """
    def refColorSpace(self) -> ColorSpace:
        """
        Returns smart pointer to :py:class:`ColorSpace`, the range of colors,
        associated with :py:class:`ImageInfo`.

        The smart pointer tracks the number of objects sharing this
        :py:class:`ColorSpace` reference so the memory is released when the
        owners destruct.

        The returned :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace` in :py:class:`ImageInfo` wrapped in a
            smart pointer
        """
    def reset(self) -> None:
        """
        Resets to its initial state; all fields are set to zero, as if
        :py:class:`Bitmap` had been initialized by :py:class:`Bitmap`.

        Sets width, height, row bytes to zero; pixel address to nullptr;
        :py:class:`ColorType` to :py:attr:`~ColorType.kUnknown_ColorType`; and
        :py:class:`AlphaType` to :py:attr:`~AlphaType.kUnknown_AlphaType`.

        If :py:class:`PixelRef` is allocated, its reference count is decreased
        by one, releasing its memory if :py:class:`Bitmap` is the sole owner.
        """
    def rowBytes(self) -> int:
        """
        Returns row bytes, the interval from one pixel row to the next.

        Row bytes is at least as large as: :py:meth:`width` * :py:meth:`info` .
        :py:meth:`bytesPerPixel`.

        Returns zero if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`, or if row bytes supplied to
        :py:meth:`setInfo` is not large enough to hold a row of pixels.

        :return: byte length of pixel row
        """
    def rowBytesAsPixels(self) -> int:
        """
        Returns number of pixels that fit on row.

        Should be greater than or equal to width().

        :return: maximum pixels per row
        """
    def setAlphaType(self, alphaType: AlphaType) -> bool:
        """
        Sets :py:class:`AlphaType`, if alphaType is compatible with
        :py:class:`ColorType`.

        Returns true unless alphaType is
        :py:attr:`~AlphaType.kUnknown_AlphaType` and current
        :py:class:`AlphaType` is not :py:attr:`~AlphaType.kUnknown_AlphaType`.

        Returns true if :py:class:`ColorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`. alphaType is ignored, and
        :py:class:`AlphaType` remains :py:attr:`~AlphaType.kUnknown_AlphaType`.

        Returns true if :py:class:`ColorType` is
        :py:attr:`~ColorType.kRGB_565_ColorType` or
        :py:attr:`~ColorType.kGray_8_ColorType`. alphaType is ignored, and
        :py:class:`AlphaType` remains :py:attr:`~AlphaType.kOpaque_AlphaType`.

        If :py:class:`ColorType` is :py:attr:`~ColorType.kARGB_4444_ColorType`,
        :py:attr:`~ColorType.kRGBA_8888_ColorType`,
        :py:attr:`~ColorType.kBGRA_8888_ColorType`, or
        :py:attr:`~ColorType.kRGBA_F16_ColorType`: returns true unless alphaType
        is :py:attr:`~AlphaType.kUnknown_AlphaType` and :py:class:`AlphaType` is
        not :py:attr:`~AlphaType.kUnknown_AlphaType`. If :py:class:`AlphaType`
        is :py:attr:`~AlphaType.kUnknown_AlphaType`, alphaType is ignored.

        If :py:class:`ColorType` is :py:attr:`~ColorType.kAlpha_8_ColorType`,
        returns true unless alphaType is
        :py:attr:`~AlphaType.kUnknown_AlphaType` and :py:class:`AlphaType` is
        not :py:attr:`~AlphaType.kUnknown_AlphaType`. If :py:class:`AlphaType`
        is :py:attr:`~AlphaType.kUnknown_AlphaType`, alphaType is ignored. If
        alphaType is :py:attr:`~AlphaType.kUnpremul_AlphaType`, it is treated as
        :py:attr:`~AlphaType.kPremul_AlphaType`.

        This changes :py:class:`AlphaType` in :py:class:`PixelRef`; all bitmaps
        sharing :py:class:`PixelRef` are affected.

        :return: true if :py:class:`AlphaType` is set
        """
    def setImmutable(self) -> None:
        """
        Sets internal flag to mark :py:class:`Bitmap` as immutable.

        Once set, pixels can not change. Any other bitmap sharing the same
        :py:class:`PixelRef` are also marked as immutable. Once
        :py:class:`PixelRef` is marked immutable, the setting cannot be cleared.

        Writing to immutable :py:class:`Bitmap` pixels triggers an assert on
        debug builds.
        """
    def setInfo(self, imageInfo: ImageInfo, rowBytes: int = 0) -> bool:
        """
        Sets width, height, :py:class:`AlphaType`, :py:class:`ColorType`,
        :py:class:`ColorSpace`, and optional rowBytes.

        Frees pixels, and returns true if successful.

        imageInfo.alphaType() may be altered to a value permitted by
        imageInfo.colorSpace(). If imageInfo.colorType() is
        :py:attr:`~ColorType.kUnknown_ColorType`, imageInfo.alphaType() is set
        to :py:attr:`~AlphaType.kUnknown_AlphaType`. If imageInfo.colorType() is
        :py:attr:`~ColorType.kAlpha_8_ColorType` and imageInfo.alphaType() is
        :py:attr:`~AlphaType.kUnpremul_AlphaType`, imageInfo.alphaType() is
        replaced by :py:attr:`~AlphaType.kPremul_AlphaType`. If
        imageInfo.colorType() is :py:attr:`~ColorType.kRGB_565_ColorType` or
        :py:attr:`~ColorType.kGray_8_ColorType`, imageInfo.alphaType() is set to
        :py:attr:`~AlphaType.kOpaque_AlphaType`. If imageInfo.colorType() is
        :py:attr:`~ColorType.kARGB_4444_ColorType`,
        :py:attr:`~ColorType.kRGBA_8888_ColorType`,
        :py:attr:`~ColorType.kBGRA_8888_ColorType`, or
        :py:attr:`~ColorType.kRGBA_F16_ColorType`: imageInfo.alphaType() remains
        unchanged.

        rowBytes must equal or exceed imageInfo.minRowBytes(). If
        imageInfo.colorSpace() is :py:attr:`~ColorType.kUnknown_ColorType`,
        rowBytes is ignored and treated as zero; for all other
        :py:class:`ColorSpace` values, rowBytes of zero is treated as
        imageInfo.minRowBytes().

        Calls :py:meth:`reset` and returns false if:

        - rowBytes exceeds 31 bits
        - imageInfo.width() is negative
        - imageInfo.height() is negative
        - rowBytes is positive and less than imageInfo.width() times
            imageInfo.bytesPerPixel()

        :param skia.ImageInfo imageInfo: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param int rowBytes: imageInfo.minRowBytes() or larger; or zero
        :return: true if :py:class:`ImageInfo` set successfully
        """
    def setPixels(self, pixels: typing_extensions.Buffer) -> None:
        """
        Replaces :py:class:`PixelRef` with pixels, preserving
        :py:class:`ImageInfo` and rowBytes().

        Sets :py:class:`PixelRef` origin to (0, 0).

        If pixels is nullptr, or if info().colorType() equals
        :py:attr:`~ColorType.kUnknown_ColorType`; release reference to
        :py:class:`PixelRef`, and set :py:class:`PixelRef` to nullptr.

        Caller is responsible for handling ownership pixel memory for the
        lifetime of :py:class:`Bitmap` and :py:class:`PixelRef`.

        :param Union[bytes,bytearray,memoryview] pixels: address of pixel
            storage, managed by caller
        """
    def shiftPerPixel(self) -> int:
        """
        Returns bit shift converting row bytes to row pixels.

        Returns zero for :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: one of: 0, 1, 2, 3; left shift to convert pixels to bytes
        """
    def swap(self, other: Bitmap) -> None:
        """
        Swaps the fields of the two bitmaps.

        :param skia.Bitmap other: :py:class:`Bitmap` exchanged with original
        """
    def tobytes(self) -> typing.Any: ...
    def tryAllocN32Pixels(self, width: int, height: int, isOpaque: bool) -> bool:
        """
        Sets :py:class:`ImageInfo` to width, height, and native color type; and
        allocates pixel memory.

        If isOpaque is true, sets :py:class:`ImageInfo` to
        :py:attr:`~AlphaType.kOpaque_AlphaType`; otherwise, sets to
        :py:attr:`~AlphaType.kPremul_AlphaType`.

        Calls reset() and returns false if width exceeds 29 bits or is negative,
        or height is negative.

        Returns false if allocation fails.

        Use to create :py:class:`Bitmap` that matches :py:class:`PMColor`, the
        native pixel arrangement on the platform. :py:class:`Bitmap` drawn to
        output device skips converting its pixel format.

        :param int width: pixel column count; must be zero or greater
        :param int height: pixel row count; must be zero or greater
        :param bool isOpaque: true if pixels do not have transparency
        :return: true if pixel storage is allocated
        """
    def tryAllocPixels(self, info: ImageInfo | None = None, rowBytes: int = 0) -> bool:
        """
        Sets :py:class:`ImageInfo` to info following the rules in
        :py:meth:`setInfo` and allocates pixel memory.

        rowBytes must equal or exceed info.:py:meth:`width` times
        info.bytesPerPixel, or equal zero. Pass in zero for rowBytes to compute
        the minimum valid value.

        Returns false and calls :py:meth:`reset` if :py:class:`ImageInfo` could
        not be set, or memory could not be allocated.

        On most platforms, allocating pixel memory may succeed even though there
        is not sufficient memory to hold pixels; allocation does not take place
        until the pixels are written to. The actual behavior depends on the
        platform implementation of :py:meth:`malloc`.

        :param skia.ImageInfo info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param int rowBytes: size of pixel row or larger; may be zero
        :return: true if pixel storage is allocated
        """
    def tryAllocPixelsFlags(self, info: ImageInfo, flags: int) -> bool:
        """
        Sets :py:class:`ImageInfo` to info following the rules in
        :py:meth:`setInfo` and allocates pixel memory.

        Memory is zeroed.

        Returns false and calls :py:meth:`reset` if :py:class:`ImageInfo` could
        not be set, or memory could not be allocated, or memory could not
        optionally be zeroed.

        On most platforms, allocating pixel memory may succeed even though there
        is not sufficient memory to hold pixels; allocation does not take place
        until the pixels are written to. The actual behavior depends on the
        platform implementation of ``calloc``.

        :param skia.ImageInfo info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param int flags: :py:attr:`kZeroPixels_AllocFlag`, or zero
        :return: true if pixels allocation is successful
        """
    def width(self) -> int:
        """
        Returns pixel count in each row.

        Should be equal or less than :py:meth:`rowBytes` / :py:meth:`info` .
        :py:meth:`bytesPerPixel`.

        May be less than :py:meth:`pixelRef` . :py:meth:`width`. Will not exceed
        :py:meth:`pixelRef` . :py:meth:`width` less :py:meth:`pixelRefOrigin` .
        fX.

        :return: pixel width in SkImageInfo
        """
    def writePixels(self, src: Pixmap, dstX: int = 0, dstY: int = 0) -> bool:
        """
        Copies a :py:class:`Rect` of pixels from src.

        Copy starts at (dstX, dstY), and does not exceed (``src.width()``,
        ``src.height()``).

        src specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, :py:class:`ColorSpace`, pixel storage, and row
        bytes of source. src.rowBytes() specifics the gap from one source row to
        the next. Returns true if pixels are copied. Returns false if:

        - src pixel storage equals nullptr
        - src.rowBytes is less than :py:class:`ImageInfo`::minRowBytes()
        - :py:class:`PixelRef` is nullptr

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; src :py:class:`ColorType` must
        match. If :py:class:`Bitmap` colorType() is
        :py:attr:`~ColorType.kGray_8_ColorType`, src :py:class:`ColorSpace` must
        match. If :py:class:`Bitmap` alphaType() is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, src :py:class:`AlphaType` must
        match. If :py:class:`Bitmap` colorSpace() is nullptr, src
        :py:class:`ColorSpace` must match. Returns false if pixel conversion is
        not possible.

        dstX and dstY may be negative to copy only top or left of source.
        Returns false if width() or height() is zero or negative. Returns false
        if abs(dstX) >= Bitmap width(), or if abs(dstY) >= Bitmap height().

        :param skia.Pixmap src: source :py:class:`Pixmap`:
            :py:class:`ImageInfo`, pixels, row bytes
        :param int dstX: column index whose absolute value is less than width()
        :param int dstY: row index whose absolute value is less than height()
        :return: true if src pixels are copied to :py:class:`Bitmap`
        """
    @property
    def __array_interface__(self) -> dict: ...

class BlendMode:
    """
    Members:

      kClear : replaces destination with zero: fully transparent

      kSrc : replaces destination

      kDst : preserves destination

      kSrcOver : source over destination

      kDstOver : destination over source

      kSrcIn : source trimmed inside destination

      kDstIn : destination trimmed by source

      kSrcOut : source trimmed outside destination

      kDstOut : destination trimmed outside source

      kSrcATop : source inside destination blended with destination

      kDstATop : destination inside source blended with source

      kXor : each of source and destination trimmed outside the other

      kPlus : sum of colors

      kModulate : product of premultiplied colors; darkens destination

      kScreen : multiply inverse of pixels, inverting result; brightens destination

      kLastCoeffMode : last porter duff blend mode

      kOverlay : multiply or screen, depending on destination

      kDarken : darker of source and destination

      kLighten : lighter of source and destination

      kColorDodge : brighten destination to reflect source

      kColorBurn : darken destination to reflect source

      kHardLight : multiply or screen, depending on source

      kSoftLight : lighten or darken, depending on source

      kDifference : subtract darker from lighter with higher contrast

      kExclusion : subtract darker from lighter with lower contrast

      kMultiply : multiply source with destination, darkening image

      kLastSeparableMode : last blend mode operating separately on components

      kHue : hue of source with saturation and luminosity of destination

      kSaturation : saturation of source with hue and luminosity of destination

      kColor : hue and saturation of source with luminosity of destination

      kLuminosity : luminosity of source with hue and saturation of destination

      kLastMode : last valid value
    """

    __members__: typing.ClassVar[
        dict[str, BlendMode]
    ]  # value = {'kClear': <BlendMode.kClear: 0>, 'kSrc': <BlendMode.kSrc: 1>, 'kDst': <BlendMode.kDst: 2>, 'kSrcOver': <BlendMode.kSrcOver: 3>, 'kDstOver': <BlendMode.kDstOver: 4>, 'kSrcIn': <BlendMode.kSrcIn: 5>, 'kDstIn': <BlendMode.kDstIn: 6>, 'kSrcOut': <BlendMode.kSrcOut: 7>, 'kDstOut': <BlendMode.kDstOut: 8>, 'kSrcATop': <BlendMode.kSrcATop: 9>, 'kDstATop': <BlendMode.kDstATop: 10>, 'kXor': <BlendMode.kXor: 11>, 'kPlus': <BlendMode.kPlus: 12>, 'kModulate': <BlendMode.kModulate: 13>, 'kScreen': <BlendMode.kScreen: 14>, 'kLastCoeffMode': <BlendMode.kScreen: 14>, 'kOverlay': <BlendMode.kOverlay: 15>, 'kDarken': <BlendMode.kDarken: 16>, 'kLighten': <BlendMode.kLighten: 17>, 'kColorDodge': <BlendMode.kColorDodge: 18>, 'kColorBurn': <BlendMode.kColorBurn: 19>, 'kHardLight': <BlendMode.kHardLight: 20>, 'kSoftLight': <BlendMode.kSoftLight: 21>, 'kDifference': <BlendMode.kDifference: 22>, 'kExclusion': <BlendMode.kExclusion: 23>, 'kMultiply': <BlendMode.kMultiply: 24>, 'kLastSeparableMode': <BlendMode.kMultiply: 24>, 'kHue': <BlendMode.kHue: 25>, 'kSaturation': <BlendMode.kSaturation: 26>, 'kColor': <BlendMode.kColor: 27>, 'kLuminosity': <BlendMode.kLuminosity: 28>, 'kLastMode': <BlendMode.kLuminosity: 28>}
    kClear: typing.ClassVar[BlendMode]  # value = <BlendMode.kClear: 0>
    kColor: typing.ClassVar[BlendMode]  # value = <BlendMode.kColor: 27>
    kColorBurn: typing.ClassVar[BlendMode]  # value = <BlendMode.kColorBurn: 19>
    kColorDodge: typing.ClassVar[BlendMode]  # value = <BlendMode.kColorDodge: 18>
    kDarken: typing.ClassVar[BlendMode]  # value = <BlendMode.kDarken: 16>
    kDifference: typing.ClassVar[BlendMode]  # value = <BlendMode.kDifference: 22>
    kDst: typing.ClassVar[BlendMode]  # value = <BlendMode.kDst: 2>
    kDstATop: typing.ClassVar[BlendMode]  # value = <BlendMode.kDstATop: 10>
    kDstIn: typing.ClassVar[BlendMode]  # value = <BlendMode.kDstIn: 6>
    kDstOut: typing.ClassVar[BlendMode]  # value = <BlendMode.kDstOut: 8>
    kDstOver: typing.ClassVar[BlendMode]  # value = <BlendMode.kDstOver: 4>
    kExclusion: typing.ClassVar[BlendMode]  # value = <BlendMode.kExclusion: 23>
    kHardLight: typing.ClassVar[BlendMode]  # value = <BlendMode.kHardLight: 20>
    kHue: typing.ClassVar[BlendMode]  # value = <BlendMode.kHue: 25>
    kLastCoeffMode: typing.ClassVar[BlendMode]  # value = <BlendMode.kScreen: 14>
    kLastMode: typing.ClassVar[BlendMode]  # value = <BlendMode.kLuminosity: 28>
    kLastSeparableMode: typing.ClassVar[BlendMode]  # value = <BlendMode.kMultiply: 24>
    kLighten: typing.ClassVar[BlendMode]  # value = <BlendMode.kLighten: 17>
    kLuminosity: typing.ClassVar[BlendMode]  # value = <BlendMode.kLuminosity: 28>
    kModulate: typing.ClassVar[BlendMode]  # value = <BlendMode.kModulate: 13>
    kMultiply: typing.ClassVar[BlendMode]  # value = <BlendMode.kMultiply: 24>
    kOverlay: typing.ClassVar[BlendMode]  # value = <BlendMode.kOverlay: 15>
    kPlus: typing.ClassVar[BlendMode]  # value = <BlendMode.kPlus: 12>
    kSaturation: typing.ClassVar[BlendMode]  # value = <BlendMode.kSaturation: 26>
    kScreen: typing.ClassVar[BlendMode]  # value = <BlendMode.kScreen: 14>
    kSoftLight: typing.ClassVar[BlendMode]  # value = <BlendMode.kSoftLight: 21>
    kSrc: typing.ClassVar[BlendMode]  # value = <BlendMode.kSrc: 1>
    kSrcATop: typing.ClassVar[BlendMode]  # value = <BlendMode.kSrcATop: 9>
    kSrcIn: typing.ClassVar[BlendMode]  # value = <BlendMode.kSrcIn: 5>
    kSrcOut: typing.ClassVar[BlendMode]  # value = <BlendMode.kSrcOut: 7>
    kSrcOver: typing.ClassVar[BlendMode]  # value = <BlendMode.kSrcOver: 3>
    kXor: typing.ClassVar[BlendMode]  # value = <BlendMode.kXor: 11>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BlendModeCoeff:
    """

        For Porter-Duff SkBlendModes (those <= kLastCoeffMode), these coefficients
        describe the blend equation used.

        Coefficient-based blend modes specify an equation: ('dstCoeff' * dst +
        'srcCoeff' * src), where the coefficient values are constants, functions of
        the src or dst alpha, or functions of the src or dst color.


    Members:

      kZero : 0

      kOne : 1

      kSC : src color

      kISC : inverse src color (i.e. 1 - sc)

      kDC : dst color

      kIDC : inverse dst color (i.e. 1 - dc)

      kSA : src alpha

      kISA : inverse src alpha (i.e. 1 - sa)

      kDA : dst alpha

      kIDA : inverse dst alpha (i.e. 1 - da)

      kCoeffCount
    """

    __members__: typing.ClassVar[
        dict[str, BlendModeCoeff]
    ]  # value = {'kZero': <BlendModeCoeff.kZero: 0>, 'kOne': <BlendModeCoeff.kOne: 1>, 'kSC': <BlendModeCoeff.kSC: 2>, 'kISC': <BlendModeCoeff.kISC: 3>, 'kDC': <BlendModeCoeff.kDC: 4>, 'kIDC': <BlendModeCoeff.kIDC: 5>, 'kSA': <BlendModeCoeff.kSA: 6>, 'kISA': <BlendModeCoeff.kISA: 7>, 'kDA': <BlendModeCoeff.kDA: 8>, 'kIDA': <BlendModeCoeff.kIDA: 9>, 'kCoeffCount': <BlendModeCoeff.kCoeffCount: 10>}
    kCoeffCount: typing.ClassVar[
        BlendModeCoeff
    ]  # value = <BlendModeCoeff.kCoeffCount: 10>
    kDA: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kDA: 8>
    kDC: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kDC: 4>
    kIDA: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kIDA: 9>
    kIDC: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kIDC: 5>
    kISA: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kISA: 7>
    kISC: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kISC: 3>
    kOne: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kOne: 1>
    kSA: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kSA: 6>
    kSC: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kSC: 2>
    kZero: typing.ClassVar[BlendModeCoeff]  # value = <BlendModeCoeff.kZero: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BlurMaskFilter:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class BlurStyle:
    """
    Members:

      kNormal_BlurStyle : fuzzy inside and outside

      kSolid_BlurStyle : solid inside, fuzzy outside

      kOuter_BlurStyle : nothing inside, fuzzy outside

      kInner_BlurStyle : fuzzy inside, nothing outside

      kLastEnum_BlurStyle :
    """

    __members__: typing.ClassVar[
        dict[str, BlurStyle]
    ]  # value = {'kNormal_BlurStyle': <BlurStyle.kNormal_BlurStyle: 0>, 'kSolid_BlurStyle': <BlurStyle.kSolid_BlurStyle: 1>, 'kOuter_BlurStyle': <BlurStyle.kOuter_BlurStyle: 2>, 'kInner_BlurStyle': <BlurStyle.kInner_BlurStyle: 3>, 'kLastEnum_BlurStyle': <BlurStyle.kInner_BlurStyle: 3>}
    kInner_BlurStyle: typing.ClassVar[
        BlurStyle
    ]  # value = <BlurStyle.kInner_BlurStyle: 3>
    kLastEnum_BlurStyle: typing.ClassVar[
        BlurStyle
    ]  # value = <BlurStyle.kInner_BlurStyle: 3>
    kNormal_BlurStyle: typing.ClassVar[
        BlurStyle
    ]  # value = <BlurStyle.kNormal_BlurStyle: 0>
    kOuter_BlurStyle: typing.ClassVar[
        BlurStyle
    ]  # value = <BlurStyle.kOuter_BlurStyle: 2>
    kSolid_BlurStyle: typing.ClassVar[
        BlurStyle
    ]  # value = <BlurStyle.kSolid_BlurStyle: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Budgeted:
    """

        Indicates whether an allocation should count against a cache budget.


    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, Budgeted]
    ]  # value = {'kNo': <Budgeted.kNo: 0>, 'kYes': <Budgeted.kYes: 1>}
    kNo: typing.ClassVar[Budgeted]  # value = <Budgeted.kNo: 0>
    kYes: typing.ClassVar[Budgeted]  # value = <Budgeted.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Canvas:
    """

    :py:class:`Canvas` provides an interface for drawing, and how the drawing is
    clipped and transformed.

    :py:class:`Canvas` contains a stack of :py:class:`Matrix` and clip values.

    :py:class:`Canvas` and :py:class:`Paint` together provide the state to draw
    into :py:class:`Surface` or :py:class:`BaseDevice`. Each :py:class:`Canvas`
    draw call transforms the geometry of the object by the concatenation of all
    :py:class:`Matrix` values in the stack. The transformed geometry is clipped
    by the intersection of all of clip values in the stack. The
    :py:class:`Canvas` draw calls use :py:class:`Paint` to supply drawing state
    such as color, :py:class:`Typeface`, text size, stroke width,
    :py:class:`Shader` and so on.

    To draw to a pixel-based destination, create raster surface or GPU surface.
    Request :py:class:`Canvas` from :py:class:`Surface` to obtain the interface
    to draw. :py:class:`Canvas` generated by raster surface draws to memory
    visible to the CPU. :py:class:`Canvas` generated by GPU surface uses Vulkan
    or OpenGL to draw to the GPU.

    To draw to a document, obtain :py:class:`Canvas` from SVG canvas, document
    PDF, or :py:class:`PictureRecorder`. :py:class:`Document` based
    :py:class:`Canvas` and other :py:class:`Canvas` subclasses reference
    :py:class:`BaseDevice` describing the destination.

    :py:class:`Canvas` can be constructed to draw to :py:class:`Bitmap` without
    first creating raster surface. This approach may be deprecated in the
    future.

    """
    class Lattice:
        """

        :py:class:`Canvas.Lattice` divides :py:class:`Bitmap` or :py:class:`Image`
        into a rectangular grid.

        Grid entries on even columns and even rows are fixed; these entries are
        always drawn at their original size if the destination is large enough. If
        the destination side is too small to hold the fixed entries, all fixed
        entries are proportionately scaled down to fit. The grid entries not on even
        columns and rows are scaled to fit the remaining space, if any.

        """
        class RectType:
            """
            Members:

              kDefault :
                    draws :py:class:`Bitmap` into lattice rectangle


              kTransparent :
                    skips lattice rectangle by making it transparent


              kFixedColor :
                    draws one of fColors into lattice rectangle

            """

            __members__: typing.ClassVar[
                dict[str, Canvas.Lattice.RectType]
            ]  # value = {'kDefault': <RectType.kDefault: 0>, 'kTransparent': <RectType.kTransparent: 1>, 'kFixedColor': <RectType.kFixedColor: 2>}
            kDefault: typing.ClassVar[
                Canvas.Lattice.RectType
            ]  # value = <RectType.kDefault: 0>
            kFixedColor: typing.ClassVar[
                Canvas.Lattice.RectType
            ]  # value = <RectType.kFixedColor: 2>
            kTransparent: typing.ClassVar[
                Canvas.Lattice.RectType
            ]  # value = <RectType.kTransparent: 1>
            @staticmethod
            def _pybind11_conduit_v1_(*args, **kwargs): ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __init__(self, value: int) -> None: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...

        kDefault: typing.ClassVar[
            Canvas.Lattice.RectType
        ]  # value = <RectType.kDefault: 0>
        kFixedColor: typing.ClassVar[
            Canvas.Lattice.RectType
        ]  # value = <RectType.kFixedColor: 2>
        kTransparent: typing.ClassVar[
            Canvas.Lattice.RectType
        ]  # value = <RectType.kTransparent: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @property
        def fBounds(self) -> IRect:
            """
            source bounds to draw from
            """
        @fBounds.setter
        def fBounds(self, arg0: IRect) -> None: ...
        @property
        def fColors(self) -> int:
            """
            array of colors
            """
        @fColors.setter
        def fColors(self, arg0: int) -> None: ...
        @property
        def fRectTypes(self) -> Canvas.Lattice.RectType:
            """
            array of fill types
            """
        @fRectTypes.setter
        def fRectTypes(self, arg0: Canvas.Lattice.RectType) -> None: ...
        @property
        def fXCount(self) -> int:
            """
            number of x-coordinates
            """
        @fXCount.setter
        def fXCount(self, arg0: int) -> None: ...
        @property
        def fXDivs(self) -> int:
            """
            x-axis values dividing bitmap
            """
        @fXDivs.setter
        def fXDivs(self, arg0: int) -> None: ...
        @property
        def fYCount(self) -> int:
            """
            number of y-coordinates
            """
        @fYCount.setter
        def fYCount(self, arg0: int) -> None: ...
        @property
        def fYDivs(self) -> int:
            """
            y-axis values dividing bitmap
            """
        @fYDivs.setter
        def fYDivs(self, arg0: int) -> None: ...

    class PointMode:
        """
        Members:

          kPoints_PointMode :
                draw each point separately


          kLines_PointMode :
                draw each pair of points as a line segment


          kPolygon_PointMode :
                draw the array of points as a open polygon

        """

        __members__: typing.ClassVar[
            dict[str, Canvas.PointMode]
        ]  # value = {'kPoints_PointMode': <PointMode.kPoints_PointMode: 0>, 'kLines_PointMode': <PointMode.kLines_PointMode: 1>, 'kPolygon_PointMode': <PointMode.kPolygon_PointMode: 2>}
        kLines_PointMode: typing.ClassVar[
            Canvas.PointMode
        ]  # value = <PointMode.kLines_PointMode: 1>
        kPoints_PointMode: typing.ClassVar[
            Canvas.PointMode
        ]  # value = <PointMode.kPoints_PointMode: 0>
        kPolygon_PointMode: typing.ClassVar[
            Canvas.PointMode
        ]  # value = <PointMode.kPolygon_PointMode: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class QuadAAFlags:
        """
        Members:

          kLeft_QuadAAFlag

          kTop_QuadAAFlag

          kRight_QuadAAFlag

          kBottom_QuadAAFlag

          kNone_QuadAAFlags

          kAll_QuadAAFlags
        """

        __members__: typing.ClassVar[
            dict[str, Canvas.QuadAAFlags]
        ]  # value = {'kLeft_QuadAAFlag': <QuadAAFlags.kLeft_QuadAAFlag: 1>, 'kTop_QuadAAFlag': <QuadAAFlags.kTop_QuadAAFlag: 2>, 'kRight_QuadAAFlag': <QuadAAFlags.kRight_QuadAAFlag: 4>, 'kBottom_QuadAAFlag': <QuadAAFlags.kBottom_QuadAAFlag: 8>, 'kNone_QuadAAFlags': <QuadAAFlags.kNone_QuadAAFlags: 0>, 'kAll_QuadAAFlags': <QuadAAFlags.kAll_QuadAAFlags: 15>}
        kAll_QuadAAFlags: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kAll_QuadAAFlags: 15>
        kBottom_QuadAAFlag: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kBottom_QuadAAFlag: 8>
        kLeft_QuadAAFlag: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kLeft_QuadAAFlag: 1>
        kNone_QuadAAFlags: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kNone_QuadAAFlags: 0>
        kRight_QuadAAFlag: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kRight_QuadAAFlag: 4>
        kTop_QuadAAFlag: typing.ClassVar[
            Canvas.QuadAAFlags
        ]  # value = <QuadAAFlags.kTop_QuadAAFlag: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SaveLayerFlags:
        """
        Members:

          kPreserveLCDText_SaveLayerFlag

          kInitWithPrevious_SaveLayerFlag : initializes with previous contents

          kF16ColorType
        """

        __members__: typing.ClassVar[
            dict[str, Canvas.SaveLayerFlags]
        ]  # value = {'kPreserveLCDText_SaveLayerFlag': <SaveLayerFlags.kPreserveLCDText_SaveLayerFlag: 2>, 'kInitWithPrevious_SaveLayerFlag': <SaveLayerFlags.kInitWithPrevious_SaveLayerFlag: 4>, 'kF16ColorType': <SaveLayerFlags.kF16ColorType: 16>}
        kF16ColorType: typing.ClassVar[
            Canvas.SaveLayerFlags
        ]  # value = <SaveLayerFlags.kF16ColorType: 16>
        kInitWithPrevious_SaveLayerFlag: typing.ClassVar[
            Canvas.SaveLayerFlags
        ]  # value = <SaveLayerFlags.kInitWithPrevious_SaveLayerFlag: 4>
        kPreserveLCDText_SaveLayerFlag: typing.ClassVar[
            Canvas.SaveLayerFlags
        ]  # value = <SaveLayerFlags.kPreserveLCDText_SaveLayerFlag: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SaveLayerRec:
        """

        SaveLayerRec contains the state used to create the layer.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None:
            """
            Sets :py:attr:`fBounds`, :py:attr:`fPaint`, and :py:attr:`fBackdrop` to
            nullptr.

            Clears :py:attr:`fSaveLayerFlags`.
            """
        @typing.overload
        def __init__(self, bounds: Rect, paint: Paint, saveLayerFlags: int = 0) -> None:
            """
            Sets :py:attr:`fBounds`, :py:attr:`fPaint`, and
            :py:attr:`fSaveLayerFlags`; sets :py:attr:`fBackdrop` to nullptr.

            :bounds: layer dimensions; may be nullptr
            :paint: applied to layer when overlaying prior layer;
                may be nullptr
            :saveLayerFlags: SaveLayerRec options to
                modify layer
            """
        @typing.overload
        def __init__(
            self,
            bounds: Rect,
            paint: Paint,
            backdrop: ImageFilter,
            saveLayerFlags: int,
        ) -> None:
            """
            Sets :py:attr:`fBounds`, :py:attr:`fPaint`, :py:attr:`fBackdrop`, and
            :py:attr:`fSaveLayerFlags`.

            :bounds: layer dimensions; may be nullptr
            :paint: applied to layer when overlaying prior layer;
                may be nullptr
            :backdrop: If not null, this causes the current
                layer to be filtered by backdrop, and then drawn into the new layer
                (respecting the current clip). If null, the new layer is initialized
                with transparent-black.
            :saveLayerFlags: SaveLayerRec options to
                modify layer
            """
        @property
        def fBackdrop(self) -> ImageFilter:
            """
            If not null, this triggers the same initialization behavior as setting
            :py:attr:`Canvas.SaveLayerFlags.kInitWithPrevious` on
            :py:attr:`fSaveLayerFlags`: the current layer is copied into the new
            layer, rather than initializing the new layer with transparent-black.

            This is then filtered by fBackdrop (respecting the current clip).
            """
        @fBackdrop.setter
        def fBackdrop(self, arg0: ImageFilter) -> None: ...
        @property
        def fBounds(self) -> Rect:
            """
            hints at layer size limit
            """
        @fBounds.setter
        def fBounds(self, arg0: Rect) -> None: ...
        @property
        def fPaint(self) -> Paint:
            """
            modifies overlay
            """
        @fPaint.setter
        def fPaint(self, arg0: Paint) -> None: ...
        @property
        def fSaveLayerFlags(self) -> int:
            """
            preserves LCD text, creates with prior layer contents
            """
        @fSaveLayerFlags.setter
        def fSaveLayerFlags(self, arg0: int) -> None: ...

    class SrcRectConstraint:
        """
        Members:

          kStrict_SrcRectConstraint :
                sample only inside bounds; slower


          kFast_SrcRectConstraint :
                sample outside bounds; faster

        """

        __members__: typing.ClassVar[
            dict[str, Canvas.SrcRectConstraint]
        ]  # value = {'kStrict_SrcRectConstraint': <SrcRectConstraint.kStrict_SrcRectConstraint: 0>, 'kFast_SrcRectConstraint': <SrcRectConstraint.kFast_SrcRectConstraint: 1>}
        kFast_SrcRectConstraint: typing.ClassVar[
            Canvas.SrcRectConstraint
        ]  # value = <SrcRectConstraint.kFast_SrcRectConstraint: 1>
        kStrict_SrcRectConstraint: typing.ClassVar[
            Canvas.SrcRectConstraint
        ]  # value = <SrcRectConstraint.kStrict_SrcRectConstraint: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kAll_QuadAAFlags: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kAll_QuadAAFlags: 15>
    kBottom_QuadAAFlag: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kBottom_QuadAAFlag: 8>
    kF16ColorType: typing.ClassVar[
        Canvas.SaveLayerFlags
    ]  # value = <SaveLayerFlags.kF16ColorType: 16>
    kFast_SrcRectConstraint: typing.ClassVar[
        Canvas.SrcRectConstraint
    ]  # value = <SrcRectConstraint.kFast_SrcRectConstraint: 1>
    kInitWithPrevious_SaveLayerFlag: typing.ClassVar[
        Canvas.SaveLayerFlags
    ]  # value = <SaveLayerFlags.kInitWithPrevious_SaveLayerFlag: 4>
    kLeft_QuadAAFlag: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kLeft_QuadAAFlag: 1>
    kLines_PointMode: typing.ClassVar[
        Canvas.PointMode
    ]  # value = <PointMode.kLines_PointMode: 1>
    kNone_QuadAAFlags: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kNone_QuadAAFlags: 0>
    kPoints_PointMode: typing.ClassVar[
        Canvas.PointMode
    ]  # value = <PointMode.kPoints_PointMode: 0>
    kPolygon_PointMode: typing.ClassVar[
        Canvas.PointMode
    ]  # value = <PointMode.kPolygon_PointMode: 2>
    kPreserveLCDText_SaveLayerFlag: typing.ClassVar[
        Canvas.SaveLayerFlags
    ]  # value = <SaveLayerFlags.kPreserveLCDText_SaveLayerFlag: 2>
    kRight_QuadAAFlag: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kRight_QuadAAFlag: 4>
    kStrict_SrcRectConstraint: typing.ClassVar[
        Canvas.SrcRectConstraint
    ]  # value = <SrcRectConstraint.kStrict_SrcRectConstraint: 0>
    kTop_QuadAAFlag: typing.ClassVar[
        Canvas.QuadAAFlags
    ]  # value = <QuadAAFlags.kTop_QuadAAFlag: 2>
    @staticmethod
    def MakeRasterDirect(
        imageInfo: ImageInfo,
        pixels: typing_extensions.Buffer,
        rowBytes: int = 0,
        surfaceProps: SurfaceProps | None = None,
    ) -> Canvas:
        """
        Allocates raster :py:class:`Canvas` that will draw directly into pixels.

        :py:class:`Canvas` is returned if all parameters are valid. Valid
        parameters include: info dimensions are zero or positive; info contains
        :py:class:`ColorType` and :py:class:`AlphaType` supported by raster
        surface; pixels is buffer object of sufficient length; rowBytes is zero
        or large enough to contain info width pixels of :py:class:`ColorType`.

        Pass zero for rowBytes to compute rowBytes from info width and size of
        pixel. If rowBytes is greater than zero, it must be equal to or greater
        than info width times bytes required for :py:class:`ColorType`.

        Pixel buffer size should be info height times computed rowBytes. Pixels
        are not initialized. To access pixels after drawing, call flush() or
        peekPixels().

        :param skia.ImageInfo info: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`, of raster surface;
            width, or height, or both, may be zero
        :param Union[bytes,bytearray,memoryview] pixels: destination pixels
            buffer
        :param int rowBytes: interval from one :py:class:`Surface` row to the
            next, or zero
        :param skia.SurfaceProps props: LCD striping orientation and setting for
            device independent fonts; may be `None`
        """
    @staticmethod
    def MakeRasterDirectN32(
        width: int,
        height: int,
        pixels: typing_extensions.Buffer,
        rowBytes: int = 0,
    ) -> Canvas:
        """
        Allocates raster :py:class:`Canvas` specified by inline image
        specification.

        Subsequent :py:class:`Canvas` calls draw into pixels.
        :py:class:`ColorType` is set to :py:attr:`ColorType.kN32_ColorType`.
        :py:class:`AlphaType` is set to :py:attr:`AlphaType.kPremul_AlphaType`.
        To access pixels after drawing, call flush() or peekPixels().

        :py:class:`Canvas` is returned if all parameters are valid. Valid
        parameters include: width and height are zero or positive; pixels is
        buffer object with sufficient length; rowBytes is zero or large enough
        to contain width pixels of :py:attr:`ColorType.kN32_ColorType`.

        Pass zero for rowBytes to compute rowBytes from width and size of pixel.
        If rowBytes is greater than zero, it must be equal to or greater than
        width times bytes required for :py:class:`ColorType`.

        Pixel buffer size should be height times rowBytes.

        :param int width: pixel column count on raster surface created; must be
            zero or greater
        :param int height: pixel row count on raster surface created; must be
            zero or greater
        :param Union[bytes,bytearray,memoryview] pixels: pointer to destination
            pixels buffer; buffer size should be height times rowBytes
        :param int rowBytes: interval from one :py:class:`Surface` row to the
            next, or zero
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None:
        """
        Creates an empty :py:class:`Canvas` with no backing device or pixels,
        with a width and height of zero.
        """
    @typing.overload
    def __init__(
        self,
        array: numpy.ndarray,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
        surfaceProps: SurfaceProps | None = None,
    ) -> None:
        """
        Creates raster :py:class:`Canvas` backed by numpy array.

        Subsequent :py:class:`Canvas` calls draw into pixels. To access pixels
        after drawing, call flush() or peekPixels().

        :array: numpy ndarray of shape=(height, width, channels) and appropriate
            dtype. Must have non-zero width and height, and the valid number of
            channels for the specified color type.
        :colorType: color type of the array
        :alphaType: alpha type of the array
        :colorSpace: range of colors; may be nullptr
        """
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        props: SurfaceProps | None = None,
    ) -> None:
        """
        Creates :py:class:`Canvas` of the specified dimensions without a
        :py:class:`Surface`.

        Used by subclasses with custom implementations for draw member
        functions.

        If props equals `None`, :py:class:`SurfaceProps` are created with
        :py:class:`SurfaceProps.InitType` settings, which choose the pixel
        striping direction and order. Since a platform may dynamically change
        its direction when the device is rotated, and since a platform may have
        multiple monitors with different characteristics, it is best not to rely
        on this legacy behavior.

        :width: zero or greater
        :height: zero or greater
        :props: LCD striping orientation and setting for device independent
            fonts; may be `None`
        """
    @typing.overload
    def __init__(self, bitmap: Bitmap) -> None:
        """
        Constructs a canvas that draws into bitmap.

        Sets :py:attr:`SurfaceProps.kLegacyFontHost` in constructed
        :py:class:`Surface`.

        :py:class:`Bitmap` is copied so that subsequently editing bitmap will
        not affect constructed :py:class:`Canvas`.

        May be deprecated in the future.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        """
    @typing.overload
    def __init__(self, bitmap: Bitmap, props: SurfaceProps) -> None:
        """
        Constructs a canvas that draws into bitmap.

        Use props to match the device characteristics, like LCD striping.

        bitmap is copied so that subsequently editing bitmap will not affect
        constructed :py:class:`Canvas`.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        :props: order and orientation of RGB striping; and whether to use device
            independent fonts
        """
    def accessTopLayerPixels(self, origin: IPoint | None = None) -> typing.Any:
        """
        Returns the pixel base address, and origin if the pixels can be read
        directly.

        The returned address is only valid while :py:class:`Canvas` is in scope
        and unchanged. Any :py:class:`Canvas` call or :py:class:`Surface` call
        may invalidate the returned address and other returned values.

        If pixels are inaccessible, returns None.

        :param origin: storage for :py:class:`Canvas` top layer origin, its
            top-left corner; may be nullptr
        :return: address of pixels, or nullptr if inaccessible
        """
    def androidFramework_setDeviceClipRestriction(self, rect: IRect) -> None:
        """
        Sets the maximum clip rectangle, which can be set by
        :py:meth:`clipRect`, :py:meth:`clipRRect` and :py:meth:`clipPath` and
        intersect the current clip with the specified rect.

        The maximum clip affects only future clipping operations; it is not
        retroactive. The clip restriction is not recorded in pictures.

        Pass an empty rect to disable maximum clip. This private API is for use
        by Android framework only.

        :param skia.IRect rect: maximum allowed clip in device coordinates
        """
    @typing.overload
    def clear(self, color: int) -> None:
        """
        Fills clip with color color using :py:attr:`BlendMode.kSrc`.

        This has the effect of replacing all pixels contained by clip with
        color.

        :param int color: unpremultiplied ARGB
        """
    @typing.overload
    def clear(self, color: Color4f) -> None:
        """
        Fills clip with color color using :py:attr:`BlendMode.kSrc`.

        This has the effect of replacing all pixels contained by clip with
        color.

        :param color: :py:class:`Color4f` representing unpremultiplied color.
        """
    @typing.overload
    def clipPath(self, path: Path, op: ClipOp, doAntiAlias: bool) -> None:
        """
        Replaces clip with the intersection or difference of clip and path, with
        an aliased or anti-aliased clip edge.

        :py:class:`Path.FillType` determines if path describes the area inside
        or outside its contours; and if path contour overlaps itself or another
        path contour, whether the overlaps form part of the area. path is
        transformed by :py:class:`Matrix` before it is combined with clip.

        :path: :py:class:`Path` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    @typing.overload
    def clipPath(self, path: Path, op: ClipOp) -> None:
        """
        Replaces clip with the intersection or difference of clip and path.

        Resulting clip is aliased; pixels are fully contained by the clip.
        :py:class:`Path.FillType` determines if path describes the area inside
        or outside its contours; and if path contour overlaps itself or another
        path contour, whether the overlaps form part of the area. path is
        transformed by :py:class:`Matrix` before it is combined with clip.

        :path: :py:class:`Path` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        """
    @typing.overload
    def clipPath(self, path: Path, doAntiAlias: bool = False) -> None:
        """
        Replaces clip with the intersection of clip and path.

        Resulting clip is aliased; pixels are fully contained by the clip.
        :py:class:`Path.FillType` determines if path describes the area inside
        or outside its contours; and if path contour overlaps itself or another
        path contour, whether the overlaps form part of the area. path is
        transformed by :py:class:`Matrix` before it is combined with clip.

        :path: :py:class:`Path` to combine with clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    @typing.overload
    def clipRRect(self, rrect: RRect, op: ClipOp, doAntiAlias: bool) -> None:
        """
        Replaces clip with the intersection or difference of clip and rrect,
        with an aliased or anti-aliased clip edge.

        rrect is transformed by :py:class:`Matrix` before it is combined with
        clip.

        :rrect: :py:class:`RRect` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    @typing.overload
    def clipRRect(self, rrect: RRect, op: ClipOp) -> None:
        """
        Replaces clip with the intersection or difference of clip and rrect.

        Resulting clip is aliased; pixels are fully contained by the clip. rrect
        is transformed by :py:class:`Matrix` before it is combined with clip.

        :rrect: :py:class:`RRect` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        """
    @typing.overload
    def clipRRect(self, rrect: RRect, doAntiAlias: bool = False) -> None:
        """
        Replaces clip with the intersection of clip and rrect, with an aliased
        or anti-aliased clip edge.

        rrect is transformed by :py:class:`Matrix` before it is combined with
        clip.

        :rrect: :py:class:`RRect` to combine with clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    @typing.overload
    def clipRect(self, rect: Rect, op: ClipOp, doAntiAlias: bool) -> None:
        """
        Replaces clip with the intersection or difference of clip and rect, with
        an aliased or anti-aliased clip edge.

        rect is transformed by :py:class:`Matrix` before it is combined with
        clip.

        :rect: :py:class:`Rect` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    @typing.overload
    def clipRect(self, rect: Rect, op: ClipOp) -> None:
        """
        Replaces clip with the intersection or difference of clip and rect.

        Resulting clip is aliased; pixels are fully contained by the clip. rect
        is transformed by :py:class:`Matrix` before it is combined with clip.

        :rect: :py:class:`Rect` to combine with clip
        :op: :py:class:`ClipOp` to apply to clip
        """
    @typing.overload
    def clipRect(self, rect: Rect, doAntiAlias: bool = False) -> None:
        """
        Replaces clip with the intersection of clip and rect.

        Resulting clip is aliased; pixels are fully contained by the clip. rect
        is transformed by :py:class:`Matrix` before it is combined with clip.

        :rect: :py:class:`Rect` to combine with clip
        :doAntiAlias: true if clip is to be anti-aliased
        """
    def clipRegion(self, deviceRgn: Region, op: ClipOp = ...) -> None:
        """
        Replaces clip with the intersection or difference of clip and
        :py:class:`Region` deviceRgn.

        Resulting clip is aliased; pixels are fully contained by the clip.
        deviceRgn is unaffected by :py:class:`Matrix`.

        :param skia.Region deviceRgn: :py:class:`Region` to combine with clip
        :param skia.ClipOp op: :py:class:`ClipOp` to apply to clip
        """
    @typing.overload
    def concat(self, matrix: Matrix) -> None:
        """
        Replaces :py:class:`Matrix` with matrix premultiplied with existing
        :py:class:`Matrix`.

        This has the effect of transforming the drawn geometry by matrix, before
        transforming the result with existing :py:class:`Matrix`.

        :matrix: matrix to premultiply with existing :py:class:`Matrix`
        """
    @typing.overload
    def concat(self, m44: M44) -> None: ...
    def discard(self) -> None:
        """
        Makes :py:class:`Canvas` contents undefined.

        Subsequent calls that read :py:class:`Canvas` pixels, such as drawing
        with :py:class:`BlendMode`, return undefined results. :py:meth:`discard`
        does not change clip or :py:class:`Matrix`.

        :py:meth:`discard` may do nothing, depending on the implementation of
        :py:class:`Surface` or :py:class:`BaseDevice` that created
        :py:class:`Canvas`.

        :py:meth:`discard` allows optimized performance on subsequent draws by
        removing cached data associated with :py:class:`Surface` or
        :py:class:`BaseDevice`. It is not necessary to call :py:meth:`discard`
        once done with SkCanvas; any cached data is deleted when owning
        :py:class:`Surface` or :py:class:`BaseDevice` is deleted.
        """
    def drawAnnotation(self, rect: Rect, key: str, value: Data) -> None:
        """
        Associates :py:class:`Rect` on :py:class:`Canvas` when an annotation; a
        key-value pair, where the key is an UTF-8 string, and optional value is
        stored as :py:class:`Data`.

        Only some canvas implementations, such as recording to
        :py:class:`Picture`, or drawing to document PDF, use annotations.

        :param skia.Rect rect: :py:class:`Rect` extent of canvas to annotate
        :param str key: string used for lookup
        :param skia.Data value: data holding value stored in annotation
        """
    def drawArc(
        self,
        oval: Rect,
        startAngle: float,
        sweepAngle: float,
        useCenter: bool,
        paint: Paint,
    ) -> None:
        """
        Draws arc using clip, :py:class:`Matrix`, and :py:class:`Paint` paint.

        Arc is part of oval bounded by oval, sweeping from startAngle to
        startAngle plus sweepAngle. startAngle and sweepAngle are in degrees.

        startAngle of zero places start point at the right middle edge of oval.
        A positive sweepAngle places arc end point clockwise from start point; a
        negative sweepAngle places arc end point counterclockwise from start
        point. sweepAngle may exceed 360 degrees, a full circle. If useCenter is
        true, draw a wedge that includes lines from oval center to arc end
        points. If useCenter is false, draw arc between end points.

        If :py:class:`Rect` oval is empty or sweepAngle is zero, nothing is
        drawn.

        :param skia.Rect oval: :py:class:`Rect` bounds of oval containing arc to
            draw
        :param float startAngle: angle in degrees where arc begins
        :param float sweepAngle: sweep angle in degrees; positive is clockwise
        :param bool useCenter: if true, include the center of the oval
        :param skia.Paint paint: :py:class:`Paint` stroke or fill, blend, color,
            and so on, used to draw
        """
    def drawAtlas(
        self,
        atlas: Image,
        xform: list[RSXform],
        tex: list[Rect],
        colors: list[int],
        mode: BlendMode,
        options: SamplingOptions = ...,
        cullRect: Rect | None = None,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws a set of sprites from atlas, using clip, :py:class:`Matrix`, and
        optional :py:class:`Paint` paint.

        paint uses anti-alias, alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode` to draw, if present.
        For each entry in the array, :py:class:`Rect` tex locates sprite in
        atlas, and :py:class:`RSXform` xform transforms it into destination
        space.

        xform, text, and colors if present, must contain count entries. Optional
        colors are applied for each sprite using :py:class:`BlendMode` mode,
        treating sprite as source and colors as destination. Optional cullRect
        is a conservative bounds of all transformed sprites. If cullRect is
        outside of clip, canvas can skip drawing.

        If atlas is `None`, this draws nothing.

        :param skia.Image atlas: :py:class:`Image` containing sprites
        :param List[skia.RSXform] xform: :py:class:`RSXform` mappings for
            sprites in atlas
        :param List[skia.Rect] tex: :py:class:`Rect` locations of sprites in
            atlas
        :param List[int] colors: one per sprite, blended with sprite using
            :py:class:`BlendMode`; may be `None`
        :param skia.BlendMode mode: :py:class:`BlendMode` combining colors and
            sprites
        :param Union[skia.Rect,None] cullRect: bounds of transformed sprites
            for efficient clipping; may be `None`
        :param Union[skia.Paint,None] paint: :py:class:`ColorFilter`,
            :py:class:`ImageFilter`, :py:class:`BlendMode`, and so on; may be
            `None`
        """
    def drawBitmap(
        self,
        bitmap: Bitmap,
        left: float,
        top: float,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws :py:class:`Bitmap` bitmap, with its top-left corner at (left,
        top), using clip, :py:class:`Matrix`, and optional :py:class:`Paint`
        paint.

        If :py:class:`Paint` paint is not nullptr, apply
        :py:class:`ColorFilter`, alpha, :py:class:`ImageFilter`,
        :py:class:`BlendMode`, and :py:class:`DrawLooper`. If bitmap is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from bitmap bounds.

        If generated mask extends beyond bitmap bounds, replicate bitmap edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Shader.MakeBitmapShader` with :py:attr:`TileMode.kClamp` set
        replicates the bitmap edge color when it samples outside of its bounds.

        :param skia.Bitmap bitmap:  :py:class:`Bitmap` containing pixels,
            dimensions, and format
        :param left: left side of bitmap
        :param top: top side of bitmap
        :param paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        """
    @typing.overload
    def drawBitmapRect(
        self,
        bitmap: Bitmap,
        src: Rect,
        dst: Rect,
        paint: Paint | None = None,
        constraint: Canvas.SrcRectConstraint = ...,
    ) -> None:
        """
        Draws :py:class:`Rect` src of :py:class:`Bitmap` bitmap, scaled and
        translated to fill :py:class:`Rect` dst.

        Additionally transform draw using clip, :py:class:`Matrix`, and optional
        :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`,
        and :py:class:`DrawLooper`. If bitmap is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from bitmap bounds.

        If generated mask extends beyond bitmap bounds, replicate bitmap edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Shader.MakeBitmapShader` with :py:attr:`TileMode.kClamp` set
        replicates the bitmap edge color when it samples outside of its bounds.

        constraint set to :py:attr:`kStrict_SrcRectConstraint` limits
        :py:class:`Paint` :py:class:`FilterQuality` to sample within src; set to
        :py:attr:`kFast_SrcRectConstraint` allows sampling outside to improve
        performance.

        :bitmap: :py:class:`Bitmap` containing pixels, dimensions, and format
        :src: source :py:class:`Rect` of image to draw from
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within src or draw faster
        """
    @typing.overload
    def drawBitmapRect(
        self,
        bitmap: Bitmap,
        isrc: Rect,
        dst: Rect,
        paint: Paint | None = None,
        constraint: Canvas.SrcRectConstraint = ...,
    ) -> None:
        """
        Draws :py:class:`IRect` isrc of :py:class:`Bitmap` bitmap, scaled and
        translated to fill :py:class:`Rect` dst.

        Additionally transform draw using clip, :py:class:`Matrix`, and optional
        :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`,
        and :py:class:`DrawLooper`. If bitmap is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from bitmap bounds.

        If generated mask extends beyond bitmap bounds, replicate bitmap edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Shader.MakeBitmapShader` with :py:attr:`TileMode.kClamp` set
        replicates the bitmap edge color when it samples outside of its bounds.

        constraint set to :py:attr:`kStrict_SrcRectConstraint` limits
        :py:class:`Paint` :py:class:`FilterQuality` to sample within isrc; set
        to :py:attr:`kFast_SrcRectConstraint` allows sampling outside to improve
        performance.

        :bitmap: :py:class:`Bitmap` containing pixels, dimensions, and format
        :isrc: source :py:class:`IRect` of image to draw from
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within isrc or draw faster
        """
    @typing.overload
    def drawBitmapRect(
        self,
        bitmap: Bitmap,
        dst: Rect,
        paint: Paint | None = None,
        constraint: Canvas.SrcRectConstraint = ...,
    ) -> None:
        """
        Draws :py:class:`Bitmap` bitmap, scaled and translated to fill
        :py:class:`Rect` dst.

        bitmap bounds is on integer pixel boundaries; dst may include fractional
        boundaries. Additionally transform draw using clip, :py:class:`Matrix`,
        and optional :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`,
        and :py:class:`DrawLooper`. If bitmap is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from bitmap bounds.

        If generated mask extends beyond bitmap bounds, replicate bitmap edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Shader.MakeBitmapShader` with :py:attr:`TileMode.kClamp` set
        replicates the bitmap edge color when it samples outside of its bounds.

        constraint set to :py:attr:`kStrict_SrcRectConstraint` limits
        :py:class:`Paint` :py:class:`FilterQuality` to sample within isrc; set
        to :py:attr:`kFast_SrcRectConstraint` allows sampling outside to improve
        performance.

        :bitmap: :py:class:`Bitmap` containing pixels, dimensions, and format
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within bitmap or draw faster
        """
    @typing.overload
    def drawCircle(self, cx: float, cy: float, radius: float, paint: Paint) -> None:
        """
        Draws circle at (cx, cy) with radius using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        If radius is zero or less, nothing is drawn. In paint:
        :py:class:`Paint.Style` determines if circle is stroked or filled; if
        stroked, :py:class:`Paint` stroke width describes the line thickness.

        :cx: circle center on the x-axis
        :cy: circle center on the y-axis
        :radius: half the diameter of circle
        :paint: :py:class:`Paint` stroke or fill, blend, color, and so on, used
            to draw
        """
    @typing.overload
    def drawCircle(self, center: Point, radius: float, paint: Paint) -> None:
        """
        Draws circle at center with radius using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        If radius is zero or less, nothing is drawn. In paint:
        :py:class:`Paint.Style` determines if circle is stroked or filled; if
        stroked, :py:class:`Paint` stroke width describes the line thickness.

        :center: circle center
        :radius: half the diameter of circle
        :paint: :py:class:`Paint` stroke or fill, blend, color, and so on, used
            to draw
        """
    @typing.overload
    def drawColor(self, color: int, mode: BlendMode = ...) -> None:
        """
        Fills clip with color color.

        mode determines how ARGB is combined with destination.

        :param int color: unpremultiplied ARGB
        :param skia.BlendMode mode: :py:class:`BlendMode` used to combine source
            color and destination
        """
    @typing.overload
    def drawColor(self, color: Color4f, mode: BlendMode = ...) -> None:
        """
        Fills clip with color color.

        mode determines how ARGB is combined with destination.

        :param color: :py:class:`Color4f` representing unpremultiplied color.
        :param skia.BlendMode mode: :py:class:`BlendMode` used to combine source
            color and destination
        """
    def drawDRRect(self, outer: RRect, inner: RRect, paint: Paint) -> None:
        """
        Draws :py:class:`RRect` outer and inner using clip, :py:class:`Matrix`,
        and :py:class:`Paint` paint.

        outer must contain inner or the drawing is undefined. In paint:
        :py:class:`Paint.Style` determines if :py:class:`RRect` is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        GPU-backed platforms optimize drawing when both outer and inner are
        concave and outer contains inner. These platforms may not be able to
        draw :py:class:`Path` built with identical data as fast.

        :param skia.RRect outer: :py:class:`RRect` outer bounds to draw
        :param skia.RRect inner: :py:class:`RRect` inner bounds to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawIRect(self, rect: IRect, paint: Paint) -> None:
        """
        Draws :py:class:`IRect` rect using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        In paint: :py:class:`Paint.Style` determines if rectangle is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        :param skia.IRect rect: rectangle to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawImage(
        self,
        image: Image,
        left: float,
        top: float,
        options: SamplingOptions = ...,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws :py:class:`Image` image, with its top-left corner at (left, top),
        using clip, :py:class:`Matrix`, and optional :py:class:`Paint` paint.

        This is equivalent to drawImageRect() using a dst rect at (x,y) with the
        same width and height of the image.

        :image: uncompressed rectangular map of pixels
        :left: left side of image
        :top: top side of image
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        """
    @typing.overload
    def drawImageRect(
        self,
        image: Image,
        src: Rect,
        dst: Rect,
        options: SamplingOptions = ...,
        paint: Paint | None = None,
        constraint: Canvas.SrcRectConstraint = ...,
    ) -> None:
        """
        Draws :py:class:`Rect` src of :py:class:`Image` image, scaled and
        translated to fill :py:class:`Rect` dst.

        Additionally transform draw using clip, :py:class:`Matrix`, and optional
        :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`, and
        :py:class:`DrawLooper`. If image is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from image bounds.

        If generated mask extends beyond image bounds, replicate image edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Image.makeShader` with :py:attr:`TileMode.kClamp`
        set replicates the image edge color when it samples outside of its
        bounds.

        When using a shader or shader mask filter, its coordinate system is
        based on the current CTM, so will reflect the dst rect geometry and is
        equivalent to drawRect(dst). The src rect is only used to access the
        provided image.

        constraint set to :py:attr:`kStrict_SrcRectConstraint` limits
        :py:class:`Paint` :py:class:`FilterQuality` to sample within src; set to
        :py:attr:`kFast_SrcRectConstraint` allows sampling outside to improve
        performance.

        :image: :py:class:`Image` containing pixels, dimensions, and format
        :src: source :py:class:`Rect` of image to draw from
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within src or draw faster
        """
    @typing.overload
    def drawImageRect(
        self,
        image: Image,
        isrc: Rect,
        dst: Rect,
        options: SamplingOptions = ...,
        paint: Paint | None = None,
        constraint: Canvas.SrcRectConstraint = ...,
    ) -> None:
        """
        Draws :py:class:`IRect` isrc of :py:class:`Image` image, scaled and
        translated to fill :py:class:`Rect` dst.

        Additionally transform draw using clip, :py:class:`Matrix`, and optional
        :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`, and
        :py:class:`DrawLooper`. If image is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from image bounds.

        If generated mask extends beyond image bounds, replicate image edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Image.makeShader` with :py:attr:`TileMode.kClamp`
        set replicates the image edge color when it samples outside of its
        bounds.

        When using a shader or shader mask filter, its coordinate system is
        based on the current CTM, so will reflect the dst rect geometry and is
        equivalent to drawRect(dst). The isrc rect is only used to access the
        provided image.

        constraint set to :py:attr:`kStrict_SrcRectConstraint` limits
        :py:class:`Paint` :py:class:`FilterQuality` to sample within isrc; set
        to :py:attr:`kFast_SrcRectConstraint` allows sampling outside to improve
        performance.

        :image: :py:class:`Image` containing pixels, dimensions, and format
        :isrc: source :py:class:`IRect` of image to draw from
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within isrc or draw faster
        """
    @typing.overload
    def drawImageRect(
        self,
        image: Image,
        dst: Rect,
        options: SamplingOptions = ...,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws :py:class:`Image` image, scaled and translated to fill
        :py:class:`Rect` dst, using clip, :py:class:`Matrix`, and optional
        :py:class:`Paint` paint.

        If :py:class:`Paint` paint is supplied, apply :py:class:`ColorFilter`,
        alpha, :py:class:`ImageFilter`, :py:class:`BlendMode`, and
        :py:class:`DrawLooper`. If image is
        :py:attr:`ColorType.kAlpha_8_ColorType`, apply :py:class:`Shader`. If
        paint contains :py:class:`MaskFilter`, generate mask from image bounds.

        If generated mask extends beyond image bounds, replicate image edge
        colors, just as :py:class:`Shader` made from
        :py:meth:`Image.makeShader` with :py:attr:`TileMode.kClamp`
        set replicates the image edge color when it samples outside of its
        bounds.

        When using a shader or shader mask filter, its coordinate system is
        based on the current CTM, so will reflect the dst rect geometry and is
        equivalent to drawRect(dst).

        :image: :py:class:`Image` containing pixels, dimensions, and format
        :dst: destination :py:class:`Rect` of image to draw to
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        :constraint: filter strictly within src or draw faster
        """
    @typing.overload
    def drawLine(
        self,
        x0: float,
        y0: float,
        x1: float,
        y1: float,
        paint: Paint,
    ) -> None:
        """
        Draws line segment from (x0, y0) to (x1, y1) using clip,
        :py:class:`Matrix`, and :py:class:`Paint` paint.

        In paint: :py:class:`Paint` stroke width describes the line thickness;
        :py:class:`Paint.Cap` draws the end rounded or square;
        :py:class:`Paint.Style` is ignored, as if were set to
        :py:attr:`Paint.Style.kStroke`.

        :x0: start of line segment on x-axis
        :y0: start of line segment on y-axis
        :x1: end of line segment on x-axis
        :y1: end of line segment on y-axis
        :paint: stroke, blend, color, and so on, used to draw
        """
    @typing.overload
    def drawLine(self, p0: Point, p1: Point, paint: Paint) -> None:
        """
        Draws line segment from p0 to p1 using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        In paint: :py:class:`Paint` stroke width describes the line thickness;
        :py:class:`Paint.Cap` draws the end rounded or square;
        :py:class:`Paint.Style` is ignored, as if were set to
        :py:attr:`Paint.Style.kStroke`.

        :p0: start of line segment
        :p1: end of line segment
        :paint: stroke, blend, color, and so on, used to draw
        """
    def drawOval(self, oval: Rect, paint: Paint) -> None:
        """
        Draws oval using clip, :py:class:`Matrix`, and :py:class:`Paint` paint.

        In paint: :py:class:`Paint.Style` determines if oval is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        :param skia.Rect oval: oval to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawPaint(self, paint: Paint) -> None:
        """
        Fills clip with :py:class:`Paint` paint.

        :py:class:`Paint` components :py:class:`MaskFilter`, :py:class:`Shader`,
        :py:class:`ColorFilter`, :py:class:`ImageFilter`, and
        :py:class:`BlendMode` affect drawing; :py:class:`PathEffect` in paint is
        ignored.

        :param skia.Paint paint: graphics state used to fill :py:class:`Canvas`
        """
    def drawPatch(
        self,
        cubics: list[Point],
        colors: list[int],
        texCoords: list[Point],
        mode: BlendMode,
        paint: Paint,
    ) -> None:
        """
        Draws a Coons patch: the interpolation of four cubics with shared
        corners, associating a color, and optionally a texture
        :py:class:`Point`, with each corner.

        Coons patch uses clip and :py:class:`Matrix`, paint :py:class:`Shader`,
        :py:class:`ColorFilter`, alpha, :py:class:`ImageFilter`, and
        :py:class:`BlendMode`. If :py:class:`Shader` is provided it is treated
        as Coons patch texture; :py:class:`BlendMode` mode combines color colors
        and :py:class:`Shader` if both are provided.

        :py:class:`Point` array cubics specifies four :py:class:`Path` cubic
        starting at the top-left corner, in clockwise order, sharing every
        fourth point. The last :py:class:`Path` cubic ends at the first point.

        Color array color associates colors with corners in top-left, top-right,
        bottom-right, bottom-left order.

        If paint contains :py:class:`Shader`, :py:class:`Point` array texCoords
        maps :py:class:`Shader` as texture to corners in top-left, top-right,
        bottom-right, bottom-left order. If texCoords is nullptr,
        :py:class:`Shader` is mapped using positions (derived from cubics).

        :param List[skia.Point] cubics: :py:class:`Path` cubic array, sharing
            common points (length 12)
        :param List[int] colors: color array, one for each corner (length 4)
        :param List[skia.Point] texCoords: :py:class:`Point` array of texture
            coordinates, mapping :py:class:`Shader` to corners (length 4); may
            be an empty list
        :param mode: :py:class:`BlendMode` for colors, and for
            :py:class:`Shader` if paint has one
        :param paint: :py:class:`Shader`, :py:class:`ColorFilter`,
            :py:class:`BlendMode`, used to draw
        """
    def drawPath(self, path: Path, paint: Paint) -> None:
        """
        Draws :py:class:`Path` path using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        :py:class:`Path` contains an array of path contour, each of which may be
        open or closed.

        In paint: :py:class:`Paint.Style` determines if :py:class:`RRect` is
        stroked or filled: if filled, :py:class:`Path.FillType` determines
        whether path contour describes inside or outside of fill; if stroked,
        :py:class:`Paint` stroke width describes the line thickness,
        :py:class:`Paint`::Cap describes line ends, and :py:class:`Paint.Join`
        describes how corners are drawn.

        :param skia.Path path: :py:class:`Path` to draw
        :param skia.Paint paint: stroke, blend, color, and so on, used to draw
        """
    def drawPicture(
        self,
        picture: Picture,
        matrix: Matrix | None = None,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws :py:class:`Picture` picture, using clip and :py:class:`Matrix`;
        transforming picture with :py:class:`Matrix` matrix, if provided; and
        use :py:class:`Paint` paint alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode`, if provided.

        :py:class:`Picture` records a series of draw commands for later
        playback.

        matrix transformation is equivalent to: save(), concat(), drawPicture(),
        restore(). paint use is equivalent to: saveLayer(), drawPicture(),
        restore().

        :param skia.Picture picture: recorded drawing commands to play
        :param skia.Matrix matrix:  :py:class:`Matrix` to rotate, scale,
            translate, and so on; may be `None`
        :param skia.Paint paint: :py:class:`Paint` to apply transparency,
            filtering, and so on; may be `None`
        """
    @typing.overload
    def drawPoint(self, x: float, y: float, paint: Paint) -> None:
        """
        Draws point at (x, y) using clip, :py:class:`Matrix` and
        :py:class:`Paint` paint.

        The shape of point drawn depends on paint :py:class:`Paint.Cap`. If
        paint is set to :py:attr:`Paint.Cap.kRound`, draw a circle of diameter
        :py:class:`Paint` stroke width. If paint is set to
        :py:attr:`Paint.Cap.kSquare` or :py:class:`Paint.Cap.Butt`, draw a
        square of width and height :py:class:`Paint` stroke width.
        :py:class:`Paint.Style` is ignored, as if were set to
        :py:class:`Paint.Style.kStroke`.

        :x: left edge of circle or square
        :y: top edge of circle or square
        :paint: stroke, blend, color, and so on, used to draw
        """
    @typing.overload
    def drawPoint(self, p: Point, paint: Paint) -> None:
        """
        Draws point p using clip, :py:class:`Matrix` and :py:class:`Paint`
        paint.

        The shape of point drawn depends on paint :py:class:`Paint.Cap`. If
        paint is set to :py:attr:`Paint.Cap.kRound`, draw a circle of diameter
        :py:class:`Paint` stroke width. If paint is set to
        :py:attr:`Paint.Cap.kSquare` or :py:class:`Paint.Cap.Butt`, draw a
        square of width and height :py:class:`Paint` stroke width.
        :py:class:`Paint.Style` is ignored, as if were set to
        :py:class:`Paint.Style.kStroke`.

        :p: top-left edge of circle or square
        :paint: stroke, blend, color, and so on, used to draw
        """
    def drawPoints(
        self,
        mode: Canvas.PointMode,
        pts: list[Point],
        paint: Paint,
    ) -> None:
        """
        Draws pts using clip, :py:class:`Matrix` and :py:class:`Paint`
        paint.

        mode may be one of: :py:attr:`~Canvas.PointMode.kPoints`,
        :py:attr:`~Canvas.PointMode.kLines`, or
        :py:attr:`~Canvas.PointMode.kPolygon`.

        If mode is :py:attr:`kPoints`, the shape of point drawn depends on
        paint :py:class:`Paint.Cap`. If paint is set to :py:attr:`Paint.kRound`,
        each point draws a circle of diameter :py:class:`Paint` stroke width. If
        paint is set to :py:attr:`Paint.kSquare` or :py:attr:`Paint.kButt`, each
        point draws a square of width and height :py:attr:`Paint` stroke width.

        If mode is :py:attr:`kLines`, each pair of points draws a line segment.
        One line is drawn for every two points; each point is used once. If
        count is odd, the final point is ignored.

        If mode is :py:attr:`kPolygon`, each adjacent pair of points draws a
        line segment. count minus one lines are drawn; the first and last point
        are used once.

        Each line segment respects paint :py:class:`Paint.Cap` and
        :py:class:`Paint` stroke width. :py:class:`Paint.Style` is ignored, as
        if were set to :py:attr:`Paint.kStroke`.

        Always draws each element one at a time; is not affected by
        :py:class:`Paint.Join`, and unlike :py:meth:`drawPath`, does not create
        a mask from all points and lines before drawing.

        :param skia.Canvas.PointMode mode: whether pts draws points or lines
        :param Iterable[skia.Point] pts: array of points to draw
        :param skia.Paint paint: stroke, blend, color, and so on, used to draw
        """
    def drawRRect(self, rrect: RRect, paint: Paint) -> None:
        """
        Draws :py:class:`RRect` rrect using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        In paint: :py:class:`Paint.Style` determines if rrect is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        rrect may represent a rectangle, circle, oval, uniformly rounded
        rectangle, or may have any combination of positive non-square radii for
        the four corners.

        :param skia.RRect rrect: rrect to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawRect(self, rect: Rect, paint: Paint) -> None:
        """
        Draws :py:class:`Rect` rect using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        In paint: :py:class:`Paint.Style` determines if rectangle is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        :param skia.Rect rect: rectangle to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawRegion(self, region: Region, paint: Paint) -> None:
        """
        Draws :py:class:`Region` region using clip, :py:class:`Matrix`, and
        :py:class:`Paint` paint.

        In paint: :py:class:`Paint.Style` determines if rectangle is stroked or
        filled; if stroked, :py:class:`Paint` stroke width describes the line
        thickness, and :py:class:`Paint.Join` draws the corners rounded or
        square.

        :param skia.Region region: region to draw
        :param skia.Paint paint: stroke or fill, blend, color, and so on, used
            to draw
        """
    def drawRoundRect(self, rect: Rect, rx: float, ry: float, paint: Paint) -> None:
        """
        Draws :py:class:`RRect` bounded by :py:class:`Rect` rect, with corner
        radii (rx, ry) using clip, :py:class:`Matrix`, and :py:class:`Paint`
        paint.

        In paint: :py:class:`Paint.Style` determines if :py:class:`RRect` is
        stroked or filled; if stroked, :py:class:`Paint` stroke width describes
        the line thickness. If rx or ry are less than zero, they are treated as
        if they are zero. If rx plus ry exceeds rect width or rect height, radii
        are scaled down to fit. If rx and ry are zero, :py:class:`RRect` is
        drawn as :py:class:`Rect` and if stroked is affected by
        :py:class:`Paint.Join`.

        :param skia.Rect rect: SkRect bounds of SkRRect to draw
        :param float rx: axis length on x-axis of oval describing rounded
            corners
        :param float ry: axis length on y-axis of oval describing rounded
            corners
        :param skia.Paint paint: stroke, blend, color, and so on, used to draw
        """
    def drawSimpleText(
        self,
        text: str,
        x: float,
        y: float,
        font: Font,
        paint: Paint,
    ) -> None:
        """
        Draws text, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        Text size is affected by :py:class:`Matrix` and :py:class:`Font` text
        size. Default text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points or glyphs drawn
        :param float x: start of text on x-axis
        :param float y: start of text on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        """
    def drawString(
        self,
        text: str,
        x: float,
        y: float,
        font: Font,
        paint: Paint,
    ) -> None:
        """
        Draws string, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning; glyphs are positioned based on their default advances.

        String `text` is encoded as UTF-8.

        Text size is affected by :py:class:`Matrix` and font text size. Default
        text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points drawn, ending with a char value
            of zero
        :param float x: start of string on x-axis
        :param float y: start of string on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        """
    def drawTextBlob(self, blob: TextBlob, x: float, y: float, paint: Paint) -> None:
        """
        Draws :py:class:`TextBlob` blob at (x, y), using clip,
        :py:class:`Matrix`, and :py:class:`Paint` paint.

        `blob` contains glyphs, their positions, and paint attributes specific
        to text: :py:class:`Typeface`, :py:class:`Paint` text size,
        :py:class:`Paint` text scale x, :py:class:`Paint` text skew x,
        :py:class:`Paint`::Align, :py:class:`Paint`::Hinting, anti-alias,
        :py:class:`Paint` fake bold, :py:class:`Paint` font embedded bitmaps,
        :py:class:`Paint` full hinting spacing, LCD text, :py:class:`Paint`
        linear text, and :py:class:`Paint` subpixel text.

        :py:class:`TextEncoding` must be set to
        :py:attr:`TextEncoding.kGlyphID`.

        Elements of paint: anti-alias, :py:class:`BlendMode`, color including
        alpha, :py:class:`ColorFilter`, :py:class:`Paint` dither,
        :py:class:`DrawLooper`, :py:class:`MaskFilter`, :py:class:`PathEffect`,
        :py:class:`Shader`, and :py:class:`Paint.Style`; apply to blob. If
        :py:class:`Paint` contains :py:attr:`Paint.kStroke`: :py:class:`Paint`
        iter limit, :py:class:`Paint.Cap`, :py:class:`Paint.Join`, and
        :py:class:`Paint` stroke width; apply to :py:class:`Path` created from
        blob.

        :param skia.TextBlob blob: glyphs, positions, and their paints' text
            size, typeface, and so on
        :param float x: horizontal offset applied to blob
        :param float y: vertical offset applied to blob
        :param skia.Paint paint: blend, color, stroking, and so on, used to draw
        """
    def drawVertices(
        self,
        vertices: Vertices,
        paint: Paint,
        mode: BlendMode = ...,
    ) -> None:
        """
        Draws :py:class:`Vertices` vertices, a triangle mesh, using clip and
        :py:class:`Matrix`. If paint contains an :py:class:`Shader` and vertices
        does not contain texCoords, the shader is mapped using the vertices'
        positions.

        If vvertices colors are defined in vertices, and :py:class:`Paint` paint
        contains :py:class:`Shader`, :py:class:`BlendMode` mode combines
        vertices colors with :py:class:`Shader`.

        :param skia.Vertices vertices: triangle mesh to draw
        :param skia.BlendMode mode: combines vertices colors with
            :py:class:`Shader`, if both are present
        :param skia.Paint paint: specifies the :py:class:`Shader`, used as
            :py:class:`Vertices` texture
        """
    def flush(self) -> None:
        """
        Triggers the immediate execution of all pending draw operations.

        If :py:class:`Canvas` is associated with GPU surface, resolves all
        pending GPU operations. If :py:class:`Canvas` is associated with raster
        surface, has no effect; raster draw operations are never deferred.
        """
    def getBaseLayerSize(self) -> ISize:
        """
        Gets the size of the base or root layer in global canvas coordinates.

        The origin of the base layer is always (0,0). The area available for
        drawing may be smaller (due to clipping or saveLayer).

        :return: integral width and height of base layer
        :rtype: skia.ISize
        """
    @typing.overload
    def getDeviceClipBounds(self) -> IRect:
        """
        Returns :py:class:`IRect` bounds of clip, unaffected by
        :py:class:`Matrix`.

        If clip is empty, return :py:meth:`Rect.MakeEmpty`, where all
        :py:class:`Rect` sides equal zero.

        Unlike :py:meth:`getLocalClipBounds`, returned :py:class:`IRect` is not
        outset.

        :return: bounds of clip in :py:class:`BaseDevice` coordinates
        """
    @typing.overload
    def getDeviceClipBounds(self, bounds: IRect) -> bool:
        """
        Returns :py:class:`IRect` bounds of clip, unaffected by
        :py:class:`Matrix`.

        If clip is empty, return false, and set bounds to
        :py:meth:`Rect.MakeEmpty`, where all :py:class:`Rect` sides equal zero.

        Unlike :py:meth:`getLocalClipBounds`, returned :py:class:`IRect` is not
        outset.

        :param skia.Rect bounds: :py:class:`Rect` of clip in device coordinates
        :return: bounds of clip in :py:class:`BaseDevice` coordinates
        """
    @typing.overload
    def getLocalClipBounds(self) -> Rect:
        """
        Returns bounds of clip, transformed by inverse of :py:class:`Matrix`.

        If clip is empty, return :py:meth:`Rect.MakeEmpty`, where all
        :py:class:`Rect` sides equal zero.

        :py:class:`Rect` returned is outset by one to account for partial pixel
        coverage if clip is anti-aliased.

        :return: bounds of clip in local coordinates
        """
    @typing.overload
    def getLocalClipBounds(self, bounds: Rect) -> bool:
        """
        Returns bounds of clip, transformed by inverse of :py:class:`Matrix`.

        If clip is empty, return false, and set bounds to
        :py:meth:`Rect.MakeEmpty`, where all :py:class:`Rect` sides equal zero.

        bounds is outset by one to account for partial pixel coverage if clip is
        anti-aliased.

        :bounds: :py:class:`Rect` of clip in local coordinates
        :return: true if clip bounds is not empty
        """
    def getLocalToDevice(self) -> M44: ...
    def getProps(self, props: SurfaceProps) -> bool:
        """
        Copies :py:class:`SurfaceProps`, if :py:class:`Canvas` is associated
        with raster surface or GPU surface, and returns true.

        Otherwise, returns false and leave props unchanged.

        :param skia.SurfaceProps props: storage for writable SurfaceProps
        :return: true if :py:class:`SurfaceProps` was copied
        """
    def getSaveCount(self) -> int:
        """
        Returns the number of saved states, each containing: :py:class:`Matrix`
        and clip.

        Equals the number of :py:meth:`save` calls less the number of
        :py:meth:`restore` calls plus one. The save count of a new canvas is
        one.

        :return: depth of save state stack
        """
    def getSurface(self) -> Surface:
        """
        Sometimes a canvas is owned by a surface.

        If it is, getSurface() will return a bare pointer to that surface, else
        this will return nullptr.

        :rtype: skia.Surface or None
        """
    def getTotalMatrix(self) -> Matrix:
        """
        Legacy version of :py:meth:`getLocalToDevice`, which strips away any Z
        information, and just returns a 3x3 version.

        :return: 3x3 version of :py:meth:`getLocalToDevice`
        """
    def imageInfo(self) -> ImageInfo:
        """
        Returns :py:class:`ImageInfo` for :py:class:`Canvas`.

        If :py:class:`Canvas` is not associated with raster surface or GPU
        surface, returned :py:class:`ColorType` is set to
        :py:attr:`ColorType.kUnknown_ColorType`.

        :return: dimensions and :py:class:`ColorType` of :py:class:`Canvas`
        """
    def isClipEmpty(self) -> bool:
        """
        Returns true if clip is empty; that is, nothing will draw.

        May do work when called; it should not be called more often than needed.
        However, once called, subsequent calls perform no work until clip
        changes.

        :return: true if clip is empty
        """
    def isClipRect(self) -> bool:
        """
        Returns true if clip is :py:class:`Rect` and not empty.

        Returns false if the clip is empty, or if it is not :py:class:`Rect`.

        :return: true if clip is :py:class:`Rect` and not empty
        """
    def makeSurface(
        self,
        info: ImageInfo,
        props: SurfaceProps | None = None,
    ) -> Surface:
        """
        Creates :py:class:`Surface` matching info and props, and associates it
        with :py:class:`Canvas`.

        Returns nullptr if no match found.

        If props is nullptr, matches :py:class:`SurfaceProps` in
        :py:class:`Canvas`. If props is nullptr and :py:class:`Canvas` does not
        have :py:class:`SurfaceProps`, creates :py:class:`Surface` with default
        :py:class:`SurfaceProps`.

        :param skia.ImageInfo info: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, and :py:class:`ColorSpace`
        :param skia.SurfaceProps props: :py:class:`SurfaceProps` to match; may
            be nullptr to match :py:class:`Canvas`
        :return: SkSurface matching info and props, or nullptr if no match is
            available
        :rtype: skia.Surface or None
        """
    def peekPixels(self, pixmap: Pixmap) -> bool:
        """
        Returns true if :py:class:`Canvas` has direct access to its pixels.

        Pixels are readable when :py:class:`BaseDevice` is raster. Pixels are
        not readable when :py:class:`Canvas` is returned from GPU surface,
        returned by :py:class:`Document`::beginPage, returned by
        :py:class:`PictureRecorder`::beginRecording, or :py:class:`Canvas` is
        the base of a utility class like DebugCanvas.

        pixmap is valid only while :py:class:`Canvas` is in scope and unchanged.
        Any :py:class:`Canvas` or :py:class:`Surface` call may invalidate the
        pixmap values.

        :param skia.Pixmap pixmap: storage for pixel state if pixels are
            readable; otherwise, ignored
        :return: true if :py:class:`Canvas` has direct access to pixels
        """
    @typing.overload
    def quickReject(self, rect: Rect) -> bool:
        """
        Returns true if :py:class:`Rect` rect, transformed by
        :py:class:`Matrix`, can be quickly determined to be outside of clip.

        May return false even though rect is outside of clip.

        Use to check if an area to be drawn is clipped out, to skip subsequent
        draw calls.

        :rect: :py:class:`Rect` to compare with clip
        :return: true if rect, transformed by :py:class:`Matrix`, does not
            intersect clip
        """
    @typing.overload
    def quickReject(self, path: Path) -> bool:
        """
        Returns true if path, transformed by :py:class:`Matrix`, can be
        quickly determined to be outside of clip.

        May return false even though path is outside of clip.

        Use to check if an area to be drawn is clipped out, to skip subsequent
        draw calls.

        :path: :py:class:`Path` to compare with clip
        :return: true if path, transformed by :py:class:`Matrix`, does not
            intersect clip
        """
    @typing.overload
    def readPixels(
        self,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int = 0,
        srcX: int = 0,
        srcY: int = 0,
    ) -> bool:
        """
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into
        dstPixels.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination :py:class:`Rect`
        corners are (0, 0) and (array.shape[1], array.shape[0]). Copies each
        readable pixel intersecting both rectangles, without scaling, converting
        to :py:attr:`ColorType.kN32_ColorType` and
        :py:attr:`AlphaType.kPremul_AlphaType` if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        The destination pixel storage must be allocated by the caller.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. array contents outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        destination.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to
            :py:attr:`ColorType.kN32_ColorType` or
            :py:attr:`AlphaType.kPremul_AlphaType`.
        - :py:class:`Canvas` pixels are not readable; for instance,
        - :py:class:`Canvas` is document-based.

        :dstInfo: width, height, :py:class:`ColorType`, and
            :py:class:`AlphaType` of dstPixels
        :dstPixels: storage for pixels; dstInfo.height() times dstRowBytes, or
            larger
        :dstRowBytes: size of one destination row; dstInfo.width() times pixel
            size, or larger. Ignored when dstPixels has more than one-dimension.
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        """
    @typing.overload
    def readPixels(self, pixmap: Pixmap, srcX: int = 0, srcY: int = 0) -> bool:
        """
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into pixmap.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination
        :py:class:`Rect` corners are (0, 0) and (pixmap.width(),
        pixmap.height()). Copies each readable pixel intersecting both
        rectangles, without scaling, converting to pixmap.colorType() and
        pixmap.alphaType() if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Caller must allocate pixel storage in pixmap if needed.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination :py:class:`Rect` are copied. pixmap pixels contents outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        pixmap.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to
            pixmap.colorType() or pixmap.alphaType().
        - :py:class:`Canvas` pixels are not readable; for instance,
            :py:class:`Canvas` is document-based.
        - :py:class:`Pixmap` pixels could not be allocated.
        - pixmap.rowBytes() is too small to contain one row of pixels.

        :pixmap: storage for pixels copied from
            :py:class:`Canvas`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        """
    @typing.overload
    def readPixels(self, bitmap: Bitmap, srcX: int = 0, srcY: int = 0) -> bool:
        """
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into bitmap.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination
        :py:class:`Rect` corners are (0, 0) and (bitmap.width(),
        bitmap.height()). Copies each readable pixel intersecting both
        rectangles, without scaling, converting to bitmap.colorType() and
        bitmap.alphaType() if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Caller must allocate pixel storage in bitmap if needed.

        :py:class:`Bitmap` values are converted only if :py:class:`ColorType`
        and :py:class:`AlphaType` do not match. Only pixels within both source
        and destination rectangles are copied. :py:class:`Bitmap` pixels outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        bitmap.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to bitmap.colorType()
            or bitmap.alphaType().
        - :py:class:`Canvas` pixels are not readable; for instance,
            :py:class:`Canvas` is document-based.
        - bitmap pixels could not be allocated.
        - bitmap.rowBytes() is too small to contain one row of pixels.

        :bitmap: storage for pixels copied from
            :py:class:`Canvas`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative

        :return: true if pixels were copied
        """
    def resetMatrix(self) -> None:
        """
        Sets SkMatrix to the identity matrix.

        Any prior matrix state is overwritten.
        """
    def restore(self) -> None:
        """
        Removes changes to :py:class:`Matrix` and clip since :py:class:`Canvas`
        state was last saved.

        The state is removed from the stack.

        Does nothing if the stack is empty.
        """
    def restoreToCount(self, saveCount: int) -> None:
        """
        Restores state to :py:class:`Matrix` and clip values when
        :py:meth:`save`, :py:meth:`saveLayer`,
        :py:meth:`saveLayerPreserveLCDTextRequests`, or
        :py:meth:`saveLayerAlpha` returned saveCount.

        Does nothing if saveCount is greater than state stack count. Restores
        state to initial values if saveCount is less than or equal to one.

        :param int saveCount: depth of state stack to restore
        """
    @typing.overload
    def rotate(self, degrees: float) -> None:
        """
        Rotates :py:class:`Matrix` by degrees.

        Positive degrees rotates clockwise.

        Mathematically, replaces :py:class:`Matrix` with a rotation matrix
        premultiplied with :py:class:`Matrix`.

        This has the effect of rotating the drawing by degrees before
        transforming the result with :py:class:`Matrix`.

        :degrees: amount to rotate, in degrees
        """
    @typing.overload
    def rotate(self, degrees: float, px: float, py: float) -> None:
        """
        Rotates :py:class:`Matrix` by degrees about a point at (px, py).

        Positive degrees rotates clockwise.

        Mathematically, constructs a rotation matrix; premultiplies the rotation
        matrix by a translation matrix; then replaces :py:class:`Matrix` with
        the resulting matrix premultiplied with :py:class:`Matrix`.

        This has the effect of rotating the drawing about a given point before
        transforming the result with :py:class:`Matrix`.

        :degrees: amount to rotate, in degrees
        :px: x-axis value of the point to rotate about
        :py: y-axis value of the point to rotate about
        """
    def save(self) -> int:
        """
        Saves :py:class:`Matrix` and clip.

        Calling :py:meth:`restore` discards changes to :py:class:`Matrix` and
        clip, restoring the :py:class:`Matrix` and clip to their state when
        :py:meth:`save` was called.

        :py:class:`Matrix` may be changed by :py:meth:`translate`,
        :py:meth:`scale`, :py:meth:`rotate`, :py:meth:`skew`, :py:meth:`concat`,
        :py:meth:`setMatrix`, and :py:meth:`resetMatrix`. Clip may be changed by
        :py:meth:`clipRect`, :py:meth:`clipRRect`, :py:meth:`clipPath`,
        :py:meth:`clipRegion`.

        Saved :py:class:`Canvas` state is put on a stack; multiple calls to
        :py:meth:`save` should be balance by an equal number of calls to
        :py:meth:`restore`.

        Call :py:meth:`restoreToCount` with result to restore this and
        subsequent saves.

        :return: depth of saved stack
        """
    @typing.overload
    def saveLayer(self, bounds: Rect | None = None, paint: Paint | None = None) -> int:
        """
        Saves :py:class:`Matrix` and clip, and allocates a :py:class:`Bitmap`
        for subsequent drawing.

        Calling :py:meth:`restore` discards changes to :py:class:`Matrix` and
        clip, and draws the :py:class:`Bitmap`.

        :py:class:`Matrix` may be changed by :py:meth:`translate`,
        :py:meth:`scale`, :py:meth:`rotate`, :py:meth:`skew`, :py:meth:`concat`,
        :py:meth:`setMatrix`, and :py:meth:`resetMatrix`. Clip may be changed by
        :py:meth:`clipRect`, :py:meth:`clipRRect`, :py:meth:`clipPath`,
        :py:meth:`clipRegion`.

        :py:class:`Rect` bounds suggests but does not define the
        :py:class:`Bitmap` size. To clip drawing to a specific rectangle, use
        :py:meth:`clipRect`.

        Optional :py:class:`Paint` paint applies alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode` when
        :py:meth:`restore` is called.

        Call :py:meth:`restoreToCount` with returned value to restore this and
        subsequent saves.

        :bounds: hint to limit the size of the layer; may be nullptr
        :paint: graphics state for layer; may be nullptr

        :return: depth of saved stack
        """
    @typing.overload
    def saveLayer(self, layerRec: Canvas.SaveLayerRec) -> int:
        """
        Saves :py:class:`Matrix` and clip, and allocates a :py:class:`Bitmap`
        for subsequent drawing.

        Calling :py:meth:`restore` discards changes to :py:class:`Matrix` and
        clip, and blends :py:class:`Bitmap` with alpha opacity onto the prior
        layer.

        :py:class:`Matrix` may be changed by :py:meth:`translate`,
        :py:meth:`scale`, :py:meth:`rotate`, :py:meth:`skew`, :py:meth:`concat`,
        :py:meth:`setMatrix`, and :py:meth:`resetMatrix`. Clip may be changed by
        :py:meth:`clipRect`, :py:meth:`clipRRect`, :py:meth:`clipPath`,
        :py:meth:`clipRegion`.

        :py:class:`SaveLayerRec` contains the state used to create the layer.

        Call :py:meth:`restoreToCount` with returned value to restore this and
        subsequent saves.

        :layerRec: layer state

        :return: depth of save state stack before this call was made.
        """
    def saveLayerAlpha(self, bounds: Rect, alpha: int) -> int:
        """
        Saves :py:class:`Matrix` and clip, and allocates a :py:class:`Bitmap`
        for subsequent drawing.

        Calling :py:meth:`restore` discards changes to :py:class:`Matrix` and
        clip, and blends layer with alpha opacity onto prior layer.

        :py:class:`Matrix` may be changed by :py:meth:`translate`,
        :py:meth:`scale`, :py:meth:`rotate`, :py:meth:`skew`, :py:meth:`concat`,
        :py:meth:`setMatrix`, and :py:meth:`resetMatrix`. Clip may be changed by
        :py:meth:`clipRect`, :py:meth:`clipRRect`, :py:meth:`clipPath`,
        :py:meth:`clipRegion`.

        :py:class:`Rect` bounds suggests but does not define the
        :py:class:`Bitmap` size. To clip drawing to a specific rectangle, use
        :py:meth:`clipRect`.

        alpha of zero is fully transparent, 255 is fully opaque.

        Call :py:meth:`restoreToCount` with returned value to restore this and
        subsequent saves.

        :param skia.Rect bounds: hint to limit the size of the layer; may be
            nullptr
        :param int alpha: opacity of layer

        :return: depth of saved stack
        """
    def scale(self, sx: float, sy: float) -> None:
        """
        Scales :py:class:`Matrix` by sx on the x-axis and sy on the y-axis.

        Mathematically, replaces :py:class:`Matrix` with a scale matrix
        premultiplied with :py:class:`Matrix`.

        This has the effect of scaling the drawing by (sx, sy) before
        transforming the result with :py:class:`Matrix`.

        :param float sx: amount to scale on x-axis
        :param float sy: amount to scale on y-axis
        """
    @typing.overload
    def setMatrix(self, matrix: M44) -> None:
        """
        Replaces :py:class:`Matrix` with matrix.

        Unlike :py:meth:`concat`, any prior matrix state is overwritten.

        :param skia.Matrix matrix: matrix to copy, replacing existing
            :py:class:`Matrix`
        """
    @typing.overload
    def setMatrix(self, matrix: Matrix) -> None:
        """
        DEPRECATED -- use SkM44 version

        Unlike :py:meth:`concat`, any prior matrix state is overwritten.

        :param skia.Matrix matrix: matrix to copy, replacing existing
            :py:class:`Matrix`
        """
    def skew(self, sx: float, sy: float) -> None:
        """
        Skews :py:class:`Matrix` by sx on the x-axis and sy on the y-axis.

        A positive value of sx skews the drawing right as y-axis values
        increase; a positive value of sy skews the drawing down as x-axis values
        increase.

        Mathematically, replaces :py:class:`Matrix` with a skew matrix
        premultiplied with :py:class:`Matrix`.

        This has the effect of skewing the drawing by (sx, sy) before
        transforming the result with :py:class:`Matrix`.

        :param float sx: amount to skew on x-axis
        :param float sy: amount to skew on y-axis
        """
    def toarray(
        self,
        srcX: int = 0,
        srcY: int = 0,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> numpy.ndarray:
        """
        Exports a ``numpy.ndarray``.

        :param srcX: offset into readable pixels on x-axis; may be negative
        :param srcY: offset into readable pixels on y-axis; may be negative
        :param colorType: target :py:class:`ColorType`
        :param alphaType: target :py:class:`AlphaType`
        :param colorSpace: target :py:class:`ColorSpace`
        :return: numpy.ndarray
        """
    def translate(self, dx: float, dy: float) -> None:
        """
        Translates :py:class:`Matrix` by dx along the x-axis and dy along the
        y-axis.

        Mathematically, replaces :py:class:`Matrix` with a translation matrix
        premultiplied with :py:class:`Matrix`.

        This has the effect of moving the drawing by (dx, dy) before
        transforming the result with :py:class:`Matrix`.

        :param dx: distance to translate on x-axis
        :param dy: distance to translate on y-axis
        """
    @typing.overload
    def writePixels(
        self,
        info: ImageInfo,
        pixels: typing_extensions.Buffer,
        rowBytes: int = 0,
        x: int = 0,
        y: int = 0,
    ) -> bool:
        """
        Copies :py:class:`Rect` from pixels to :py:class:`Canvas`.

        :py:class:`Matrix` and clip are ignored. Source :py:class:`Rect` corners
        are (0, 0) and (info.width(), info.height()). Destination
        :py:class:`Rect` corners are (x, y) and (imageInfo().width(),
        imageInfo().height()).

        Copies each readable pixel intersecting both rectangles, without
        scaling, converting to imageInfo().colorType() and
        imageInfo().alphaType() if required.

        Pixels are writable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not writable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. :py:class:`Canvas` pixels outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for x or y to offset pixels to the left or above
        :py:class:`Canvas` pixels.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - pixels could not be converted to :py:class:`Canvas`
            imageInfo().colorType() or imageInfo().alphaType().
        - :py:class:`Canvas` pixels are not writable; for instance,
            :py:class:`Canvas` is document-based.
        - rowBytes is too small to contain one row of pixels.

        :array: pixels to copy, in native 32-bit colors.
        :x: offset into :py:class:`Canvas` writable pixels on x-axis; may be
            negative
        :y: offset into :py:class:`Canvas` writable pixels on y-axis; may be
            negative

        :return: true if pixels were written to :py:class:`Canvas`
        """
    @typing.overload
    def writePixels(self, bitmap: Bitmap, x: int = 0, y: int = 0) -> bool:
        """
        Copies :py:class:`Rect` from pixels to :py:class:`Canvas`.

        :py:class:`Matrix` and clip are ignored. Source :py:class:`Rect` corners
        are (0, 0) and (bitmap.width(), bitmap.height()).

        Destination :py:class:`Rect` corners are (x, y) and
        (imageInfo().width(), imageInfo().height()).

        Copies each readable pixel intersecting both rectangles, without
        scaling, converting to imageInfo().colorType() and
        imageInfo().alphaType() if required.

        Pixels are writable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not writable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. :py:class:`Canvas` pixels outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for x or y to offset pixels to the left or above
        :py:class:`Canvas` pixels.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - bitmap does not have allocated pixels.
        - bitmap pixels could not be converted to
            :py:meth:`Canvas.imageInfo()`.colorType() or alphaType().
        - :py:class:`Canvas` pixels are not writable; for instance,
            :py:class:`Canvas` is document-based.
        - bitmap pixels are inaccessible; for instance, bitmap wraps a texture.

        :bitmap: contains pixels copied to :py:class:`Canvas`.
        :x: offset into :py:class:`Canvas` writable pixels on x-axis; may be
            negative
        :y: offset into :py:class:`Canvas` writable pixels on y-axis; may be
            negative

        :return: true if pixels were written to :py:class:`Canvas`
        """

class ClipOp:
    """
    Members:

      kDifference

      kIntersect
    """

    __members__: typing.ClassVar[
        dict[str, ClipOp]
    ]  # value = {'kDifference': <ClipOp.kDifference: 0>, 'kIntersect': <ClipOp.kIntersect: 1>}
    kDifference: typing.ClassVar[ClipOp]  # value = <ClipOp.kDifference: 0>
    kIntersect: typing.ClassVar[ClipOp]  # value = <ClipOp.kIntersect: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Codec:
    """

    :py:class:`Codec` Abstraction layer directly on top of an image codec.

    """
    class DisposalMethod:
        """

            This specifies how the next frame is based on this frame.

            Names are based on the GIF 89a spec.

            The numbers correspond to values in a GIF.


        Members:

          kKeep :
                The next frame should be drawn on top of this one.

                In a GIF, a value of 0 (not specified) is also treated as Keep.


          kRestoreBGColor :
                Similar to Keep, except the area inside this frame's rectangle
                should be cleared to the BackGround color (transparent) before
                drawing the next frame.


          kRestorePrevious :
                The next frame should be drawn on top of the previous frame - i.e.
                disregarding this one.

                In a GIF, a value of 4 is also treated as RestorePrevious.

        """

        __members__: typing.ClassVar[
            dict[str, Codec.DisposalMethod]
        ]  # value = {'kKeep': <DisposalMethod.kKeep: 1>, 'kRestoreBGColor': <DisposalMethod.kRestoreBGColor: 2>, 'kRestorePrevious': <DisposalMethod.kRestorePrevious: 3>}
        kKeep: typing.ClassVar[
            Codec.DisposalMethod
        ]  # value = <DisposalMethod.kKeep: 1>
        kRestoreBGColor: typing.ClassVar[
            Codec.DisposalMethod
        ]  # value = <DisposalMethod.kRestoreBGColor: 2>
        kRestorePrevious: typing.ClassVar[
            Codec.DisposalMethod
        ]  # value = <DisposalMethod.kRestorePrevious: 3>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FrameInfo:
        """

        Information about individual frames in a multi-framed image.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self) -> None: ...
        @property
        def fAlphaType(self) -> AlphaType:
            """
            This is conservative; it will still return non-opaque if e.g. a
            color index-based frame has a color with alpha but does not use it.
            """
        @fAlphaType.setter
        def fAlphaType(self, arg0: AlphaType) -> None: ...
        @property
        def fDisposalMethod(self) -> ...:
            """
            How this frame should be modified before decoding the next one.
            """
        @fDisposalMethod.setter
        def fDisposalMethod(self, arg0: ...) -> None: ...
        @property
        def fDuration(self) -> int:
            """
            Number of milliseconds to show this frame.
            """
        @fDuration.setter
        def fDuration(self, arg0: int) -> None: ...
        @property
        def fFullyReceived(self) -> bool:
            """
            Whether the end marker for this frame is contained in the stream.

            Note: this does not guarantee that an attempt to decode will be
            complete. There could be an error in the stream.
            """
        @fFullyReceived.setter
        def fFullyReceived(self, arg0: bool) -> None: ...
        @property
        def fRequiredFrame(self) -> int:
            """
            The frame that this frame needs to be blended with, or
            kNoFrame if this frame is independent (so it can be
            drawn over an uninitialized buffer).

            Note that this is the *earliest* frame that can be used
            for blending. Any frame from [fRequiredFrame, i) can be
            used, unless its fDisposalMethod is kRestorePrevious.
            """
        @fRequiredFrame.setter
        def fRequiredFrame(self, arg0: int) -> None: ...

    class Options:
        """

        Additional options to pass to getPixels.

        """

        fZeroInitialized: Codec.ZeroInitialized
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self) -> None: ...
        @property
        def fFrameIndex(self) -> int:
            """
            The frame to decode.

            Only meaningful for multi-frame images.
            """
        @fFrameIndex.setter
        def fFrameIndex(self, arg0: int) -> None: ...
        @property
        def fPriorFrame(self) -> int:
            """
            If not kNoFrame, the dst already contains the prior frame at this index.

            Only meaningful for multi-frame images.

            If fFrameIndex needs to be blended with a prior frame (as reported by
            getFrameInfo[fFrameIndex].fRequiredFrame), the client can set this to
            any non-kRestorePrevious frame in [fRequiredFrame, fFrameIndex) to
            indicate that that frame is already in the dst. Options.fZeroInitialized
            is ignored in this case.

            If set to kNoFrame, the codec will decode any necessary required
            frame(s) first.
            """
        @fPriorFrame.setter
        def fPriorFrame(self, arg0: int) -> None: ...
        @property
        def fSubset(self) -> IRect:
            """
            If not NULL, represents a subset of the original image to decode.
            Must be within the bounds returned by :py:meth:`~SkCodec.getInfo`.
            If the EncodedFormat is :py:attr:`EncodedImageFormat.kWEBP` (the only
            one which currently supports subsets), the top and left values must be
            even.

            In getPixels and incremental decode, we will attempt to decode the
            exact rectangular subset specified by fSubset.

            In a scanline decode, it does not make sense to specify a subset
            top or subset height, since the client already controls which rows
            to get and which rows to skip.  During scanline decodes, we will
            require that the subset top be zero and the subset height be equal
            to the full height.  We will, however, use the values of
            subset left and subset width to decode partial scanlines on calls
            to :py:meth:`~SkCodec.getScanlines`.
            """
        @fSubset.setter
        def fSubset(self, arg0: IRect) -> None: ...

    class Result:
        """

            Error codes for various :py:class:`Codec` methods.


        Members:

          kSuccess :
                General return value for success.


          kIncompleteInput :
                The input is incomplete. A partial image was generated.


          kErrorInInput :
                Like kIncompleteInput, except the input had an error.

                If returned from an incremental decode, decoding cannot continue, even
                with more data.


          kInvalidConversion :
                The generator cannot convert to match the request, ignoring dimensions.


          kInvalidScale :
                The generator cannot scale to requested size.


          kInvalidParameters :
                Parameters (besides info) are invalid. e.g. NULL pixels, rowBytes too
                small, etc.


          kInvalidInput :
                The input did not contain a valid image.


          kCouldNotRewind :
                Fulfilling this request requires rewinding the input, which is not
                supported for this input.


          kInternalError :
                An internal error, such as OOM.


          kUnimplemented :
                This method is not implemented by this codec.

        """

        __members__: typing.ClassVar[
            dict[str, Codec.Result]
        ]  # value = {'kSuccess': <Result.kSuccess: 0>, 'kIncompleteInput': <Result.kIncompleteInput: 1>, 'kErrorInInput': <Result.kErrorInInput: 2>, 'kInvalidConversion': <Result.kInvalidConversion: 3>, 'kInvalidScale': <Result.kInvalidScale: 4>, 'kInvalidParameters': <Result.kInvalidParameters: 5>, 'kInvalidInput': <Result.kInvalidInput: 6>, 'kCouldNotRewind': <Result.kCouldNotRewind: 7>, 'kInternalError': <Result.kInternalError: 8>, 'kUnimplemented': <Result.kUnimplemented: 9>}
        kCouldNotRewind: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kCouldNotRewind: 7>
        kErrorInInput: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kErrorInInput: 2>
        kIncompleteInput: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kIncompleteInput: 1>
        kInternalError: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kInternalError: 8>
        kInvalidConversion: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kInvalidConversion: 3>
        kInvalidInput: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kInvalidInput: 6>
        kInvalidParameters: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kInvalidParameters: 5>
        kInvalidScale: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kInvalidScale: 4>
        kSuccess: typing.ClassVar[Codec.Result]  # value = <Result.kSuccess: 0>
        kUnimplemented: typing.ClassVar[
            Codec.Result
        ]  # value = <Result.kUnimplemented: 9>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ScanlineOrder:
        """

            The order in which rows are output from the scanline decoder is not the
            same for all variations of all image types.  This explains the possible
            output row orderings.


        Members:

          kKeep :
                By far the most common, this indicates that the image can be decoded
                reliably using the scanline decoder, and that rows will be output in
                the logical order.


          kRestoreBGColor :
                This indicates that the scanline decoder reliably outputs rows, but
                they will be returned in reverse order.  If the scanline format is
                kBottomUp, the nextScanline() API can be used to determine the actual
                y-coordinate of the next output row, but the client is not forced
                to take advantage of this, given that it's not too tough to keep
                track independently.

                For full image decodes, it is safe to get all of the scanlines at
                once, since the decoder will handle inverting the rows as it
                decodes.

                For subset decodes and sampling, it is simplest to get and skip
                scanlines one at a time, using the nextScanline() API.  It is
                possible to ask for larger chunks at a time, but this should be used
                with caution.  As with full image decodes, the decoder will handle
                inverting the requested rows, but rows will still be delivered
                starting from the bottom of the image.

                Upside down bmps are an example.

        """

        __members__: typing.ClassVar[
            dict[str, Codec.ScanlineOrder]
        ]  # value = {'kKeep': <ScanlineOrder.kKeep: 0>, 'kRestoreBGColor': <ScanlineOrder.kRestoreBGColor: 1>}
        kKeep: typing.ClassVar[Codec.ScanlineOrder]  # value = <ScanlineOrder.kKeep: 0>
        kRestoreBGColor: typing.ClassVar[
            Codec.ScanlineOrder
        ]  # value = <ScanlineOrder.kRestoreBGColor: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SelectionPolicy:
        """

            For container formats that contain both still images and image sequences,
            instruct the decoder how the output should be selected.


        Members:

          kPreferStillImage :
                If the container format contains both still images and image sequences,
                :py:class:`Codec` should choose one of the still images. This is the
                default.


          kPreferAnimation :
                If the container format contains both still images and image sequences,
                :py:class:`Codec` should choose one of the image sequences for
                animation.

        """

        __members__: typing.ClassVar[
            dict[str, Codec.SelectionPolicy]
        ]  # value = {'kPreferStillImage': <SelectionPolicy.kPreferStillImage: 0>, 'kPreferAnimation': <SelectionPolicy.kPreferAnimation: 1>}
        kPreferAnimation: typing.ClassVar[
            Codec.SelectionPolicy
        ]  # value = <SelectionPolicy.kPreferAnimation: 1>
        kPreferStillImage: typing.ClassVar[
            Codec.SelectionPolicy
        ]  # value = <SelectionPolicy.kPreferStillImage: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ZeroInitialized:
        """

            Whether or not the memory passed to getPixels is zero initialized.


        Members:

          kYes_ZeroInitialized :
                The memory passed to getPixels is zero initialized. The
                :py:class:`Codec` may take advantage of this by skipping writing zeroes.


          kNo_ZeroInitialized :
                The memory passed to `getPixels` has not been initialized to zero,
                so the :py:class:`Codec` must write all zeroes to memory.

                This is the default. It will be used if no Options struct is used.

        """

        __members__: typing.ClassVar[
            dict[str, Codec.ZeroInitialized]
        ]  # value = {'kYes_ZeroInitialized': <ZeroInitialized.kYes_ZeroInitialized: 0>, 'kNo_ZeroInitialized': <ZeroInitialized.kNo_ZeroInitialized: 1>}
        kNo_ZeroInitialized: typing.ClassVar[
            Codec.ZeroInitialized
        ]  # value = <ZeroInitialized.kNo_ZeroInitialized: 1>
        kYes_ZeroInitialized: typing.ClassVar[
            Codec.ZeroInitialized
        ]  # value = <ZeroInitialized.kYes_ZeroInitialized: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kCouldNotRewind: typing.ClassVar[
        Codec.Result
    ]  # value = <Result.kCouldNotRewind: 7>
    kErrorInInput: typing.ClassVar[Codec.Result]  # value = <Result.kErrorInInput: 2>
    kIncompleteInput: typing.ClassVar[
        Codec.Result
    ]  # value = <Result.kIncompleteInput: 1>
    kInternalError: typing.ClassVar[Codec.Result]  # value = <Result.kInternalError: 8>
    kInvalidConversion: typing.ClassVar[
        Codec.Result
    ]  # value = <Result.kInvalidConversion: 3>
    kInvalidInput: typing.ClassVar[Codec.Result]  # value = <Result.kInvalidInput: 6>
    kInvalidParameters: typing.ClassVar[
        Codec.Result
    ]  # value = <Result.kInvalidParameters: 5>
    kInvalidScale: typing.ClassVar[Codec.Result]  # value = <Result.kInvalidScale: 4>
    kKeep: typing.ClassVar[Codec.DisposalMethod]  # value = <DisposalMethod.kKeep: 1>
    kNoFrame: typing.ClassVar[int] = -1
    kNo_ZeroInitialized: typing.ClassVar[
        Codec.ZeroInitialized
    ]  # value = <ZeroInitialized.kNo_ZeroInitialized: 1>
    kPreferAnimation: typing.ClassVar[
        Codec.SelectionPolicy
    ]  # value = <SelectionPolicy.kPreferAnimation: 1>
    kPreferStillImage: typing.ClassVar[
        Codec.SelectionPolicy
    ]  # value = <SelectionPolicy.kPreferStillImage: 0>
    kRepetitionCountInfinite: typing.ClassVar[int] = -1
    kRestoreBGColor: typing.ClassVar[
        Codec.DisposalMethod
    ]  # value = <DisposalMethod.kRestoreBGColor: 2>
    kRestorePrevious: typing.ClassVar[
        Codec.DisposalMethod
    ]  # value = <DisposalMethod.kRestorePrevious: 3>
    kSuccess: typing.ClassVar[Codec.Result]  # value = <Result.kSuccess: 0>
    kUnimplemented: typing.ClassVar[Codec.Result]  # value = <Result.kUnimplemented: 9>
    kYes_ZeroInitialized: typing.ClassVar[
        Codec.ZeroInitialized
    ]  # value = <ZeroInitialized.kYes_ZeroInitialized: 0>
    @staticmethod
    def MakeFromData(data: typing_extensions.Buffer) -> Codec:
        """
        If this data represents an encoded image that we know how to decode,
        return an :py:class:`Codec` that can decode it. Otherwise return NULL.
        """
    @staticmethod
    def MinBufferedBytesNeeded() -> int: ...
    @staticmethod
    def ResultToString(result: Codec.Result) -> str:
        """
        Returns a textual representation of :py:class:`Codec.Result`
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self, data: typing_extensions.Buffer) -> None:
        """
        If this stream represents an encoded image that we know how to decode,
        return an :py:class:`Codec` that can decode it. Otherwise return None.
        """
    def bounds(self) -> IRect: ...
    def dimensions(self) -> ISize: ...
    def getEncodedFormat(self) -> EncodedImageFormat:
        """
        Format of the encoded data.
        """
    def getFrameCount(self) -> int:
        """
        Return the number of frames in the image.

        May require reading through the stream.
        """
    @typing.overload
    def getFrameInfo(self, index: int, info: Codec.FrameInfo) -> bool:
        """
        Return info about a single frame.

        Only supported by multi-frame images. Does not read through the stream,
        so it should be called after :py:meth:`getFrameCount` to parse any
        frames that have not already been parsed.
        """
    @typing.overload
    def getFrameInfo(self) -> list[Codec.FrameInfo]:
        """
        Return info about all the frames in the image.

        May require reading through the stream to determine info about the
        frames (including the count).

        As such, future decoding calls may require a rewind.

        For still (non-animated) image codecs, this will return an empty vector.
        """
    def getInfo(self) -> ImageInfo:
        """
        Return a reasonable :py:class:`ImageInfo` to decode into.

        If the image has an ICC profile that does not map to an
        :py:class:`ColorSpace`, the returned :py:class:`ImageInfo` will use
        SRGB.
        """
    def getOrigin(self) -> EncodedOrigin:
        """
        Returns the image orientation stored in the EXIF data.
        If there is no EXIF data, or if we cannot read the EXIF data, returns
        :py:attr:`~EncodedOrigin.kTopLeft`.
        """
    @typing.overload
    def getPixels(
        self,
        info: ImageInfo,
        data: typing_extensions.Buffer,
        rowBytes: int,
        options: Codec.Options | None = None,
    ) -> Codec.Result:
        """
        Decode into the given pixels, a block of memory of size at
        least (info.fHeight - 1) * rowBytes + (info.fWidth *
        bytesPerPixel)

        Repeated calls to this function should give the same results,
        allowing the PixelRef to be immutable.

        If a scanline decode is in progress, scanline mode will end, requiring
        the client to call :py:meth:`startScanlineDecode` in order to return to
        decoding scanlines.

        :info: A description of the format (config, size)
            expected by the caller.  This can simply be identical
            to the info returned by getInfo().

            This contract also allows the caller to specify
            different output-configs, which the implementation can
            decide to support or not.

            A size that does not match getInfo() implies a request
            to scale. If the generator cannot perform this scale,
            it will return kInvalidScale.

            If the info contains a non-null SkColorSpace, the codec
            will perform the appropriate color space transformation.

            If the caller passes in the SkColorSpace that maps to the
            ICC profile reported by getICCProfile(), the color space
            transformation is a no-op.

            If the caller passes a null SkColorSpace, no color space
            transformation will be done.

        :return: Result kSuccess, or another value explaining the type of
            failure.
        """
    @typing.overload
    def getPixels(
        self,
        pixmap: Pixmap,
        options: Codec.Options | None = None,
    ) -> Codec.Result: ...
    def getRepetitionCount(self) -> int:
        """
        Return the number of times to repeat, if this image is animated. This
        number does notinclude the first play through of each frame. For
        example, a repetition count of 4 meansthat each frame is played 5
        times and then the animation stops.

        It can return kRepetitionCountInfinite, a negative number, meaning that
        the animationshould loop forever.

        May require reading the stream to find the repetition count.

        As such, future decoding calls may require a rewind.

        For still (non-animated) image codecs, this will return 0.
        """
    def getScaledDimensions(self, desiredScale: float) -> ISize:
        """
        Return a size that approximately supports the desired scale factor.
        The codec may not be able to scale efficiently to the exact scale
        factor requested, so return a size that approximates that scale.
        The returned value is the codec's suggestion for the closest valid
        scale that it can natively support
        """
    def getScanlineOrder(self) -> Codec.ScanlineOrder:
        """
        An enum representing the order in which scanlines will be returned by
        the scanline decoder.

        This is undefined before :py:meth:`startScanlineDecode` is called.
        """
    def getScanlines(
        self,
        dst: typing_extensions.Buffer,
        countLines: int,
        rowBytes: int,
    ) -> int:
        """
        Write the next countLines scanlines into dst.

        Not valid to call before calling startScanlineDecode().

        :param dst: Must be non-null, and large enough to hold countLines
            scanlines of size rowBytes.
        :param countLines: Number of lines to write.
        :param rowBytes: Number of bytes per row. Must be large enough to hold
            a scanline based on the :py:class:`ImageInfo` used to create this
            object.
        :return: the number of lines successfully decoded.  If this value is
            less than countLines, this will fill the remaining lines with a
            default value.
        """
    def getValidSubset(self, desiredSubset: IRect) -> bool:
        """
        Return (via `desiredSubset`) a subset which can decoded from this codec,
        or false if this codec cannot decode subsets or anything similar to
        `desiredSubset`.

        :param desiredSubset: In/out parameter. As input, a desired subset of
            the original bounds (as specified by getInfo). If true is returned,
            desiredSubset may have been modified to a subset which is
            supported. Although a particular change may have been made to
            desiredSubset to create something supported, it is possible other
            changes could result in a valid subset.
            If false is returned, desiredSubset's value is undefined.
        :return: true if this codec supports decoding `desiredSubset` (as
            returned, potentially modified)
        """
    def getYUVAPlanes(self, yuvaPixmaps: YUVAPixmaps) -> Codec.Result:
        """
        Returns kSuccess, or another value explaining the type of failure.
        This always attempts to perform a full decode. To get the planar
        configuration without decoding use queryYUVAInfo().

        :param yuvaPixmaps: Contains preallocated pixmaps configured according
            to a successful call to :py:meth:`~queryYUVAInfo`.
        """
    def incrementalDecode(self, rowsDecoded: int | None = None) -> Codec.Result:
        """
        Start/continue the incremental decode.

        Not valid to call before a call to :py:meth:`startIncrementalDecode`
        returns kSuccess.

        If kIncompleteInput is returned, may be called again after more data has
        been provided to the source SkStream.

        Unlike getPixels and getScanlines, this does not do any filling. This is
        left up to the caller, since they may be skipping lines or continuing
        the decode later. In the latter case, they may choose to initialize all
        lines first, or only initialize the remaining lines after the first
        call.

        :param rowsDecoded: Optional output variable returning the total number
            of lines initialized. Only meaningful if this method returns
            kIncompleteInput. Otherwise the implementation may not set it.
            Note that some implementations may have initialized this many rows,
            but not necessarily finished those rows (e.g. interlaced PNG). This
            may be useful for determining what rows the client needs to
            initialize.
        :return: kSuccess if all lines requested in startIncrementalDecode have
            been completely decoded. kIncompleteInput otherwise.
        """
    def nextScanline(self) -> int:
        """
        Returns the y-coordinate of the next row to be returned by the scanline
        decoder.

        This will equal fCurrScanline, except in the case of strangely
        encoded image types (bottom-up bmps).

        Results are undefined when not in scanline decoding mode.
        """
    def outputScanline(self, inputScanline: int) -> int:
        """
        Returns the output y-coordinate of the row that corresponds to an input
        y-coordinate.  The input y-coordinate represents where the scanline
        is located in the encoded data.

        This will equal inputScanline, except in the case of strangely
        encoded image types (bottom-up bmps, interlaced gifs).
        """
    def queryYUVAInfo(self, supportedDataTypes: ...) -> typing.Any:
        """
        If decoding to YUV is supported, this returns true. Otherwise, this
        returns false;

        :param supportedDataTypes: Indicates the data type/planar config
            combinations that are supported by the caller. If the generator
            supports decoding to YUV(A), but not as a type in
            supportedDataTypes, this method returns false.
        :return: Output that specifies the planar configuration, subsampling,
            orientation, chroma siting, plane color types, and row bytes.
        """
    def skipScanlines(self, countLines: int) -> bool:
        """
        Skip count scanlines.

        Not valid to call before calling startScanlineDecode().

        The default version just calls onGetScanlines and discards the dst.
        NOTE: If skipped lines are the only lines with alpha, this default
        will make reallyHasAlpha return true, when it could have returned
        false.

        :return: true if the scanlines were successfully skipped
            false on failure, possible reasons for failure include:

            - An incomplete input image stream.
            - Calling this function before calling startScanlineDecode().
            - If countLines is less than zero or so large that it moves
                the current scanline past the end of the image.
        """
    def startIncrementalDecode(
        self,
        dstInfo: ImageInfo,
        dst: typing_extensions.Buffer,
        rowBytes: int,
        options: Codec.Options | None = None,
    ) -> Codec.Result:
        """
        Prepare for an incremental decode with the specified options.

        This may require a rewind.

        If kIncompleteInput is returned, may be called again after more data has
        been provided to the source :py:class:`Stream`.

        :param dstInfo: Info of the destination. If the dimensions do not match
            those of getInfo, this implies a scale.
        :param dst: Memory to write to. Needs to be large enough to hold the
            subset, if present, or the full image as described in dstInfo.
        :param options: Contains decoding options, including if memory is zero
            initialized and whether to decode a subset.
        :return: Enum representing success or reason for failure.
        """
    def startScanlineDecode(
        self,
        dstInfo: ImageInfo,
        options: Codec.Options | None = None,
    ) -> Codec.Result:
        """
        Prepare for a scanline decode with the specified options.

        After this call, this class will be ready to decode the first scanline.

        This must be called in order to call :py:meth:`getScanlines` or
        :py:meth:`skipScanlines`.

        This may require rewinding the stream.

        Not all Codecs support this.

        :param dstInfo: Info of the destination. If the dimensions do not match
            those of getInfo, this implies a scale.
        :param options: Contains decoding options, including if memory is zero
            initialized.
        :return: Enum representing success or reason for failure.
        """

class Color4f:
    """

    RGBA color value, holding four floating point components.

    Color components are always in a known order, and are unpremultiplied.

    Skia's public API always uses unpremultiplied colors.

    Example::

        color4f = skia.Color4f(0xFFFFFFFF)  # From int format
        color4f = skia.Color4f(1.0, 0.0, 0.0, 1.0)  # From elements
        color4f = skia.Color4f((1.0, 0.0, 0.0, 1.0))  # From tuple
        color = color4f.toColor()  # Convert to int format
        color = int(color4f)  # Convert to int format
        r, g, b, a = tuple(color4f)  # Convert to tuple

    """

    __hash__: typing.ClassVar[None] = None
    kBlack: typing.ClassVar[Color4f]  # value = Color4f(0, 0, 0, 1)
    kBlue: typing.ClassVar[Color4f]  # value = Color4f(0, 0, 1, 1)
    kCyan: typing.ClassVar[Color4f]  # value = Color4f(0, 1, 1, 1)
    kDkGray: typing.ClassVar[Color4f]  # value = Color4f(0.25, 0.25, 0.25, 1)
    kGray: typing.ClassVar[Color4f]  # value = Color4f(0.5, 0.5, 0.5, 1)
    kGreen: typing.ClassVar[Color4f]  # value = Color4f(0, 1, 0, 1)
    kLtGray: typing.ClassVar[Color4f]  # value = Color4f(0.75, 0.75, 0.75, 1)
    kMagenta: typing.ClassVar[Color4f]  # value = Color4f(1, 0, 1, 1)
    kRed: typing.ClassVar[Color4f]  # value = Color4f(1, 0, 0, 1)
    kTransparent: typing.ClassVar[Color4f]  # value = Color4f(0, 0, 0, 0)
    kWhite: typing.ClassVar[Color4f]  # value = Color4f(1, 1, 1, 1)
    kYellow: typing.ClassVar[Color4f]  # value = Color4f(1, 1, 0, 1)
    @staticmethod
    def FromBytes_RGBA(rgba: int) -> Color4f: ...
    @staticmethod
    def FromColor(color: int) -> Color4f:
        """
        Returns closest :py:class:`Color4f` to Color int.

        :param int color: Color with Alpha, red, blue, and green components
            (e.g., 0xFFFFFFFF)
        :return: Color int as :py:class:`Color4f`
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: Color4f) -> bool:
        """
        Compares :py:class:`Color4f` with other, and returns true if all
        components are equal.

        :param other: :py:class:`Color4f` to compare
        :return: true if :py:class:`Color4f` equals other
        """
    def __getitem__(self, index: int) -> float:
        """
        Returns one component.

        Asserts if index is out of range and SK_DEBUG is defined.

        :param index: one of: 0 (fR), 1 (fG), 2 (fB), 3 (fA)
        :return: value corresponding to index
        """
    @typing.overload
    def __init__(self, color: int) -> None:
        """
        Returns closest :py:class:`Color4f` to ARGB Color.
        See :py:meth:`FromColor`.
        """
    @typing.overload
    def __init__(
        self,
        red: float,
        green: float,
        blue: float,
        alpha: float = 1.0,
    ) -> None:
        """
        Returns a new Color4f instance initialized with the given values.

        :red: red components
        :green: green components
        :blue: blue components
        :alpha: alpha components
        """
    @typing.overload
    def __init__(self, t: tuple) -> None:
        """
        Returns a new Color4f instance given (R, G, B) or (R, G, B, A) tuple.
        """
    def __int__(self) -> int: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __mul__(self, arg0: float) -> Color4f:
        """
        Returns :py:class:`Color4f` multiplied by scale.
        """
    @typing.overload
    def __mul__(self, arg0: Color4f) -> Color4f:
        """
        Returns :py:class:`Color4f` multiplied component-wise by scale.
        """
    def __ne__(self, other: Color4f) -> bool:
        """
        Compares :py:class:`Color4f` with other, and returns true if not all
        components are equal.

        :param other: :py:class:`Color4f` to compare
        :return: true if :py:class:`Color4f` is not equal to other
        """
    def __setitem__(self, index: int, value: float) -> None:
        """
        Sets one component.

        Asserts if index is out of range and SK_DEBUG is defined.

        :param index: one of: 0 (fR), 1 (fG), 2 (fB), 3 (fA)
        :param value: float value
        """
    def fitsInBytes(self) -> bool:
        """
        Returns true if all channels are in [0, 1].
        """
    def isOpaque(self) -> bool:
        """
        Returns true if :py:class:`Color4f` is an opaque color.

        Asserts if fA is out of range and SK_DEBUG is defined.

        :return: true if :py:class:`Color4f` is opaque
        """
    def makeOpaque(self) -> Color4f: ...
    def toBytes_RGBA(self) -> int: ...
    def toColor(self) -> int:
        """
        Returns closest Color to :py:class:`Color4f`.

        :return: color as Color int
        """
    def vec(self) -> memoryview:
        """
        Returns a memoryview to components of :py:class:`Color4f`, for array
        access.
        """
    @property
    def fA(self) -> float:
        """
        alpha component
        """
    @fA.setter
    def fA(self, arg0: float) -> None: ...
    @property
    def fB(self) -> float:
        """
        blue component
        """
    @fB.setter
    def fB(self, arg0: float) -> None: ...
    @property
    def fG(self) -> float:
        """
        green component
        """
    @fG.setter
    def fG(self, arg0: float) -> None: ...
    @property
    def fR(self) -> float:
        """
        red component
        """
    @fR.setter
    def fR(self, arg0: float) -> None: ...

class ColorChannel:
    """

        Describes different color channels one can manipulate.


    Members:

      kR

      kG

      kB

      kA

      kLastEnum
    """

    __members__: typing.ClassVar[
        dict[str, ColorChannel]
    ]  # value = {'kR': <ColorChannel.kR: 0>, 'kG': <ColorChannel.kG: 1>, 'kB': <ColorChannel.kB: 2>, 'kA': <ColorChannel.kA: 3>, 'kLastEnum': <ColorChannel.kA: 3>}
    kA: typing.ClassVar[ColorChannel]  # value = <ColorChannel.kA: 3>
    kB: typing.ClassVar[ColorChannel]  # value = <ColorChannel.kB: 2>
    kG: typing.ClassVar[ColorChannel]  # value = <ColorChannel.kG: 1>
    kLastEnum: typing.ClassVar[ColorChannel]  # value = <ColorChannel.kA: 3>
    kR: typing.ClassVar[ColorChannel]  # value = <ColorChannel.kR: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorChannelFlag:
    """

        Used to represent the channels available in a color type or texture format
        as a mask.


    Members:

      kRed_ColorChannelFlag

      kGreen_ColorChannelFlag

      kBlue_ColorChannelFlag

      kAlpha_ColorChannelFlag

      kGray_ColorChannelFlag

      kRG_ColorChannelFlags

      kRGB_ColorChannelFlags

      kRGBA_ColorChannelFlags
    """

    __members__: typing.ClassVar[
        dict[str, ColorChannelFlag]
    ]  # value = {'kRed_ColorChannelFlag': <ColorChannelFlag.kRed_ColorChannelFlag: 1>, 'kGreen_ColorChannelFlag': <ColorChannelFlag.kGreen_ColorChannelFlag: 2>, 'kBlue_ColorChannelFlag': <ColorChannelFlag.kBlue_ColorChannelFlag: 4>, 'kAlpha_ColorChannelFlag': <ColorChannelFlag.kAlpha_ColorChannelFlag: 8>, 'kGray_ColorChannelFlag': <ColorChannelFlag.kGray_ColorChannelFlag: 16>, 'kRG_ColorChannelFlags': <ColorChannelFlag.kRG_ColorChannelFlags: 3>, 'kRGB_ColorChannelFlags': <ColorChannelFlag.kRGB_ColorChannelFlags: 7>, 'kRGBA_ColorChannelFlags': <ColorChannelFlag.kRGBA_ColorChannelFlags: 15>}
    kAlpha_ColorChannelFlag: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kAlpha_ColorChannelFlag: 8>
    kBlue_ColorChannelFlag: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kBlue_ColorChannelFlag: 4>
    kGray_ColorChannelFlag: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kGray_ColorChannelFlag: 16>
    kGreen_ColorChannelFlag: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kGreen_ColorChannelFlag: 2>
    kRGBA_ColorChannelFlags: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kRGBA_ColorChannelFlags: 15>
    kRGB_ColorChannelFlags: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kRGB_ColorChannelFlags: 7>
    kRG_ColorChannelFlags: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kRG_ColorChannelFlags: 3>
    kRed_ColorChannelFlag: typing.ClassVar[
        ColorChannelFlag
    ]  # value = <ColorChannelFlag.kRed_ColorChannelFlag: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ColorFilter(Flattanable):
    """

    ColorFilters are optional objects in the drawing pipeline.

    When present in a paint, they are called with the "src" colors, and return
    new colors, which are then passed onto the next stage (either ImageFilter or
    Xfermode).

    All subclasses are required to be reentrant-safe : it must be legal to share
    the same instance between several threads.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~skia.ColorFilters
        ~skia.ColorMatrixFilter
        ~skia.HighContrastFilter
        ~skia.LumaColorFilter
        ~skia.OverdrawColorFilter
        ~skia.TableColorFilter

    """
    @staticmethod
    def Deserialize(data: typing_extensions.Buffer) -> ColorFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def asAColorMatrix(self) -> typing.Any:
        """
        If the filter can be represented by a 5x4 matrix, this returns list of
        floats appropriately.

        If not, this returns None.

        :rtype: List[float] or None
        """
    def asAColorMode(self) -> typing.Any:
        """
        If the filter can be represented by a source color plus Mode, this
        returns color and mode appropriately.

        If not, this returns None.

        :rtype: Tuple[int,skia.BlendMode] or None
        """
    def asColorMode(self) -> typing.Any: ...
    def filterColor(self, color: int) -> int: ...
    def filterColor4f(
        self,
        srcColor: Color4f,
        srcCS: ColorSpace,
        dstCS: ColorSpace,
    ) -> Color4f:
        """
        Converts the src color (in src colorspace), into the dst colorspace,
        then applies this filter to it, returning the filtered color in the dst
        colorspace.
        """
    def makeComposed(self, inner: ColorFilter) -> ColorFilter:
        """
        Construct a colorfilter whose effect is to first apply the inner filter
        and then apply this filter, applied to the output of the inner filter.

        result = this(inner(...))
        """

class ColorFilters:
    @staticmethod
    @typing.overload
    def Blend(c: Color4f, colorspace: ColorSpace, mode: BlendMode) -> ColorFilter: ...
    @staticmethod
    @typing.overload
    def Blend(c: int, mode: BlendMode) -> ColorFilter: ...
    @staticmethod
    def Compose(outer: ColorFilter, inner: ColorFilter) -> ColorFilter: ...
    @staticmethod
    @typing.overload
    def HSLAMatrix(rowMajor: list[float]) -> ColorFilter: ...
    @staticmethod
    @typing.overload
    def HSLAMatrix(colorMatrix: ColorMatrix) -> ColorFilter:
        """
        A version of Matrix which operates in HSLA space instead of RGBA.
        i.e. ``HSLA-to-RGBA(Matrix(RGBA-to-HSLA(input)))``.
        """
    @staticmethod
    def Lerp(t: float, dst: ColorFilter, src: ColorFilter) -> ColorFilter: ...
    @staticmethod
    def LinearToSRGBGamma() -> ColorFilter: ...
    @staticmethod
    def Matrix(rowMajor: list[float]) -> ColorFilter: ...
    @staticmethod
    def SRGBToLinearGamma() -> ColorFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class ColorInfo:
    """

    Describes pixel and encoding.

    :py:class:`ImageInfo` can be created from :py:class:`ColorInfo` by providing
    dimensions.

    It encodes how pixel bits describe alpha, transparency; color components
    red, blue, and green; and :py:class:`ColorSpace`, the range and linearity of
    colors.

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: ColorInfo) -> bool:
        """
        Does other represent the same color type, alpha type, and color space?
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Creates an :py:class:`ColorInfo` with
        :py:attr:`~ColorType.kUnknown_ColorType`,
        :py:attr:`~AlphaType.kUnknown_AlphaType`, and no :py:class:`ColorSpace`.
        """
    @typing.overload
    def __init__(
        self,
        ct: ColorType,
        at: AlphaType,
        cs: ColorSpace | None = None,
    ) -> None:
        """
        Creates :py:class:`ColorInfo` from :py:class:`ColorType` ct,
        :py:class:`AlphaType` at, and optionally :py:class:`ColorSpace` cs.

        If :py:class:`ColorSpace` cs is nullptr and :py:class:`ColorInfo` is
        part of drawing source: :py:class:`ColorSpace` defaults to sRGB, mapping
        into :py:class:`Surface` :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.
        """
    @typing.overload
    def __init__(self, arg0: ColorInfo) -> None: ...
    def __ne__(self, arg0: ColorInfo) -> bool:
        """
        Does other represent a different color type, alpha type, or color space?
        """
    def alphaType(self) -> AlphaType: ...
    def bytesPerPixel(self) -> int:
        """
        Returns number of bytes per pixel required by :py:class:`ColorType`.

        Returns zero if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: bytes in pixel
        """
    def colorSpace(self) -> ColorSpace: ...
    def colorType(self) -> ColorType: ...
    def gammaCloseToSRGB(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def makeAlphaType(self, newAlphaType: AlphaType) -> ColorInfo:
        """
        Creates :py:class:`ColorInfo` with same :py:class:`ColorType`,
        :py:class:`ColorSpace`, with :py:class:`AlphaType` set to newAlphaType.

        Created :py:class:`ColorInfo` contains newAlphaType even if it is
        incompatible with :py:class:`ColorType`, in which case
        :py:class:`AlphaType` in :py:class:`ColorInfo` is ignored.
        """
    def makeColorSpace(self, cs: ColorSpace) -> ColorInfo:
        """
        Creates :py:class:`ColorInfo` with same :py:class:`AlphaType`,
        :py:class:`ColorType`, with :py:class:`ColorSpace` set to cs.

        cs may be nullptr.
        """
    def makeColorType(self, newColorType: ColorType) -> ColorInfo:
        """
        Creates new :py:class:`ColorInfo` with same :py:class:`AlphaType`,
        :py:class:`ColorSpace`, with :py:class:`ColorType` set to newColorType.
        """
    def refColorSpace(self) -> ColorSpace: ...
    def shiftPerPixel(self) -> int:
        """
        Returns bit shift converting row bytes to row pixels.

        Returns zero for :py:attr:`ColorType.kUnknown_ColorType`.

        :return: one of: 0, 1, 2, 3, 4; left shift to convert pixels to bytes
        """

class ColorMatrix:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class ColorMatrixFilter(ColorFilter):
    @staticmethod
    def MakeLightingFilter(mul: int, add: int) -> ColorFilter:
        """
        Create a colorfilter that multiplies the RGB channels by one color, and
        then adds a second color, pinning the result for each component to
        [0..255].

        The alpha components of the mul and add arguments are ignored.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class ColorSpace:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Deserialize(data: capsule, length: int) -> ColorSpace: ...
    @staticmethod
    def Make(profile: cms.ICCProfile) -> ColorSpace:
        """
        Create an :py:class:`ColorSpace` from a parsed (skcms) ICC profile.
        """
    @staticmethod
    def MakeRGB(transferFn: cms.TransferFunction, toXYZ: cms.Matrix3x3) -> ColorSpace:
        """
        Create an :py:class:`ColorSpace` from a transfer function and a
        row-major 3x3 transformation to XYZ.
        """
    @staticmethod
    def MakeSRGB() -> ColorSpace:
        """
        Create the sRGB color space.
        """
    @staticmethod
    def MakeSRGBLinear() -> ColorSpace:
        """
        Colorspace with the sRGB primaries, but a linear (1.0) gamma.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def Equals(self, other: ColorSpace) -> bool:
        """
        If both are null, we return true.

        If one is null and the other is not, we return false. If both are
        non-null, we do a deeper compare.
        """
    def __eq__(self, arg0: ColorSpace) -> bool: ...
    def deref(self) -> None: ...
    def gammaCloseToSRGB(self) -> bool:
        """
        Returns true if the color space gamma is near enough to be approximated
        as sRGB.
        """
    def gammaIsLinear(self) -> bool:
        """
        Returns true if the color space gamma is linear.
        """
    def gamutTransformTo(self, dst: ColorSpace, src_to_dst: cms.Matrix3x3) -> None: ...
    def hash(self) -> int: ...
    def invTransferFn(self, fn: cms.TransferFunction) -> None: ...
    def isNumericalTransferFn(self, fn: cms.TransferFunction) -> bool:
        """
        Sets ``|fn|`` to the transfer function from this color space.

        Returns true if the transfer function can be represented as coefficients
        to the standard ICC 7-parameter equation. Returns false otherwise (eg,
        PQ, HLG).
        """
    def isSRGB(self) -> bool:
        """
        Returns true if the color space is sRGB.

        Returns false otherwise.

        This allows a little bit of tolerance, given that we might see small
        numerical error in some cases: converting ICC fixed point to float,
        converting white point to D50, rounding decisions on transfer function
        and matrix.

        This does not consider a 2.2f exponential transfer function to be sRGB.
        While these functions are similar (and it is sometimes useful to
        consider them together), this function checks for logical equality.
        """
    def makeColorSpin(self) -> ColorSpace:
        """
        Returns a color space with the same transfer function as this one, but
        with the primary colors rotated.

        For any XYZ space, this produces a new color space that maps RGB to GBR
        (when applied to a source), and maps RGB to BRG (when applied to a
        destination). For other types of color spaces, returns nullptr.

        This is used for testing, to construct color spaces that have severe and
        testable behavior.
        """
    def makeLinearGamma(self) -> ColorSpace:
        """
        Returns a color space with the same gamut as this one, but with a linear
        gamma.

        For color spaces whose gamut can not be described in terms of XYZ D50,
        returns linear sRGB.
        """
    def makeSRGBGamma(self) -> ColorSpace:
        """
        Returns a color space with the same gamut as this one, with with the
        sRGB transfer function.

        For color spaces whose gamut can not be described in terms of XYZ D50,
        returns sRGB.
        """
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def serialize(self) -> Data:
        """
        Returns nullptr on failure.

        Fails when we fallback to serializing ICC data and the data is too large
        to serialize.
        """
    def toProfile(self) -> cms.ICCProfile:
        """
        Convert this color space to an skcms ICC profile struct.
        """
    def toXYZD50(self, matrix: cms.Matrix3x3) -> bool:
        """
        Returns true and sets ``|toXYZD50|`` if the color gamut can be described
        as a matrix.

        Returns false otherwise.
        """
    def toXYZD50Hash(self) -> int:
        """
        Returns a hash of the gamut transformation to XYZ D50.

        Allows for fast equality checking of gamuts, at the (very small) risk of
        collision.
        """
    @typing.overload
    def transferFn(self, gabcdef: float) -> None: ...
    @typing.overload
    def transferFn(self, fn: cms.TransferFunction) -> None: ...
    def transferFnHash(self) -> int: ...
    def unique(self) -> bool: ...
    def unref(self) -> None: ...
    def writeToMemory(self, memory: capsule) -> int:
        """
        If ``|memory|`` is nullptr, returns the size required to serialize.

        Otherwise, serializes into ``|memory|`` and returns the size.
        """

class ColorType:
    """
    Members:

      kUnknown_ColorType : uninitialized

      kAlpha_8_ColorType : pixel with alpha in 8-bit byte

      kRGB_565_ColorType : pixel with 5 bits red, 6 bits green, 5 bits blue, in 16-bit word

      kARGB_4444_ColorType : pixel with 4 bits for alpha, red, green, blue; in 16-bit word

      kRGBA_8888_ColorType : pixel with 8 bits for red, green, blue, alpha; in 32-bit word

      kRGB_888x_ColorType : pixel with 8 bits each for red, green, blue; in 32-bit word

      kBGRA_8888_ColorType : pixel with 8 bits for blue, green, red, alpha; in 32-bit word

      kRGBA_1010102_ColorType : 10 bits for red, green, blue; 2 bits for alpha; in 32-bit word

      kBGRA_1010102_ColorType : 10 bits for blue, green, red; 2 bits for alpha; in 32-bit word

      kRGB_101010x_ColorType : pixel with 10 bits each for red, green, blue; in 32-bit word

      kBGR_101010x_ColorType : pixel with 10 bits each for blue, green, red; in 32-bit word

      kGray_8_ColorType : pixel with grayscale level in 8-bit byte

      kRGBA_F16Norm_ColorType : pixel with half floats in [0,1] for red, green, blue, alpha; in 64-bit word

      kRGBA_F16_ColorType : pixel with half floats for red, green, blue, alpha; in 64-bit word

      kRGBA_F32_ColorType : pixel using C float for red, green, blue, alpha; in 128-bit word

      kR8G8_unorm_ColorType

      kA16_float_ColorType

      kR16G16_float_ColorType

      kA16_unorm_ColorType

      kR16G16_unorm_ColorType : pixel with a little endian uint16_t for red and green

      kR16G16B16A16_unorm_ColorType : pixel with a little endian uint16_t for red, green, blue

      kN32_ColorType
    """

    __members__: typing.ClassVar[
        dict[str, ColorType]
    ]  # value = {'kUnknown_ColorType': <ColorType.kUnknown_ColorType: 0>, 'kAlpha_8_ColorType': <ColorType.kAlpha_8_ColorType: 1>, 'kRGB_565_ColorType': <ColorType.kRGB_565_ColorType: 2>, 'kARGB_4444_ColorType': <ColorType.kARGB_4444_ColorType: 3>, 'kRGBA_8888_ColorType': <ColorType.kRGBA_8888_ColorType: 4>, 'kRGB_888x_ColorType': <ColorType.kRGB_888x_ColorType: 5>, 'kBGRA_8888_ColorType': <ColorType.kBGRA_8888_ColorType: 6>, 'kRGBA_1010102_ColorType': <ColorType.kRGBA_1010102_ColorType: 7>, 'kBGRA_1010102_ColorType': <ColorType.kBGRA_1010102_ColorType: 8>, 'kRGB_101010x_ColorType': <ColorType.kRGB_101010x_ColorType: 9>, 'kBGR_101010x_ColorType': <ColorType.kBGR_101010x_ColorType: 10>, 'kGray_8_ColorType': <ColorType.kGray_8_ColorType: 14>, 'kRGBA_F16Norm_ColorType': <ColorType.kRGBA_F16Norm_ColorType: 15>, 'kRGBA_F16_ColorType': <ColorType.kRGBA_F16_ColorType: 16>, 'kRGBA_F32_ColorType': <ColorType.kRGBA_F32_ColorType: 18>, 'kR8G8_unorm_ColorType': <ColorType.kR8G8_unorm_ColorType: 19>, 'kA16_float_ColorType': <ColorType.kA16_float_ColorType: 20>, 'kR16G16_float_ColorType': <ColorType.kR16G16_float_ColorType: 21>, 'kA16_unorm_ColorType': <ColorType.kA16_unorm_ColorType: 22>, 'kR16G16_unorm_ColorType': <ColorType.kR16G16_unorm_ColorType: 23>, 'kR16G16B16A16_unorm_ColorType': <ColorType.kR16G16B16A16_unorm_ColorType: 24>, 'kN32_ColorType': <ColorType.kBGRA_8888_ColorType: 6>}
    kA16_float_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kA16_float_ColorType: 20>
    kA16_unorm_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kA16_unorm_ColorType: 22>
    kARGB_4444_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kARGB_4444_ColorType: 3>
    kAlpha_8_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kAlpha_8_ColorType: 1>
    kBGRA_1010102_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kBGRA_1010102_ColorType: 8>
    kBGRA_8888_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kBGRA_8888_ColorType: 6>
    kBGR_101010x_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kBGR_101010x_ColorType: 10>
    kGray_8_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kGray_8_ColorType: 14>
    kN32_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kBGRA_8888_ColorType: 6>
    kR16G16B16A16_unorm_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kR16G16B16A16_unorm_ColorType: 24>
    kR16G16_float_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kR16G16_float_ColorType: 21>
    kR16G16_unorm_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kR16G16_unorm_ColorType: 23>
    kR8G8_unorm_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kR8G8_unorm_ColorType: 19>
    kRGBA_1010102_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGBA_1010102_ColorType: 7>
    kRGBA_8888_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGBA_8888_ColorType: 4>
    kRGBA_F16Norm_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGBA_F16Norm_ColorType: 15>
    kRGBA_F16_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGBA_F16_ColorType: 16>
    kRGBA_F32_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGBA_F32_ColorType: 18>
    kRGB_101010x_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGB_101010x_ColorType: 9>
    kRGB_565_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGB_565_ColorType: 2>
    kRGB_888x_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kRGB_888x_ColorType: 5>
    kUnknown_ColorType: typing.ClassVar[
        ColorType
    ]  # value = <ColorType.kUnknown_ColorType: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ConvergeMode:
    """

        Describes geometric operations (ala :py:class:`Region.Op`) that can be
        applied to coverage bytes.

        These can be thought of as variants of porter-duff (:py:class:`BlendMode`)
        modes, but only applied to the alpha channel.

        See :py:class:`MaskFilter` for ways to use these when combining two
        different masks.


    Members:

      kUnion

      kIntersect

      kDifference

      kReverseDifference

      kXor

      kLast
    """

    __members__: typing.ClassVar[
        dict[str, ConvergeMode]
    ]  # value = {'kUnion': <ConvergeMode.kUnion: 0>, 'kIntersect': <ConvergeMode.kIntersect: 1>, 'kDifference': <ConvergeMode.kDifference: 2>, 'kReverseDifference': <ConvergeMode.kReverseDifference: 3>, 'kXor': <ConvergeMode.kXor: 4>, 'kLast': <ConvergeMode.kXor: 4>}
    kDifference: typing.ClassVar[ConvergeMode]  # value = <ConvergeMode.kDifference: 2>
    kIntersect: typing.ClassVar[ConvergeMode]  # value = <ConvergeMode.kIntersect: 1>
    kLast: typing.ClassVar[ConvergeMode]  # value = <ConvergeMode.kXor: 4>
    kReverseDifference: typing.ClassVar[
        ConvergeMode
    ]  # value = <ConvergeMode.kReverseDifference: 3>
    kUnion: typing.ClassVar[ConvergeMode]  # value = <ConvergeMode.kUnion: 0>
    kXor: typing.ClassVar[ConvergeMode]  # value = <ConvergeMode.kXor: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CornerPathEffect:
    """

    :py:class:`CornerPathEffect` is a subclass of :py:class:`PathEffect` that
    can turn sharp corners into various treatments (e.g. rounded corners)

    """
    @staticmethod
    def Make(radius: float) -> PathEffect:
        """
        radius must be > 0 to have an effect.

        It specifies the distance from each corner that should be "rounded".
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class CubicResampler:
    B: float
    C: float
    @staticmethod
    def CatmullRom() -> CubicResampler: ...
    @staticmethod
    def Mitchell() -> CubicResampler: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class DashPathEffect:
    @staticmethod
    def Make(intervals: list[float], phase: float) -> PathEffect:
        """
        For example: if intervals[] = {10, 20}, count = 2, and phase = 25, this
        will set up a dashed path like so: 5 pixels off 10 pixels on 20 pixels
        off 10 pixels on 20 pixels off ... A phase of -5, 25, 55, 85, etc. would
        all result in the same path, because the sum of all the intervals is 30.

        Note: only affects stroked paths.

        :param List[skia.Point] intervals: array containing an even number of
            entries (>=2), with the even indices specifying the length of "on"
            intervals, and the odd indices specifying the length of "off"
            intervals.
        :param float phase: offset into the intervals array (mod the sum of all
            of the intervals).
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Data:
    """

    :py:class:`Data` holds an immutable data buffer.

    Not only is the data immutable, but the actual ptr that is returned (by
    :py:meth:`data` or :py:meth:`bytes`) is guaranteed to always be the same for
    the life of this instance.

    :py:class:`Data` supports Python buffer protocol, meaning that
    :py:class:`Data` can be converted to Python buffer types without copy::

        bytes(data)
        memoryview(data)
        np.array(data)

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def MakeEmpty() -> Data:
        """
        Returns a new empty dataref (or a reference to a shared empty dataref).

        New or shared, the caller must see that unref() is eventually called.
        """
    @staticmethod
    def MakeFromFileName(path: str) -> Data:
        """
        Create a new dataref the file with the specified path.

        If the file cannot be opened, this returns NULL.
        """
    @staticmethod
    def MakeSubset(src: Data, offset: int, length: int) -> Data:
        """
        Create a new dataref using a subset of the data in the specified src
        dataref.
        """
    @staticmethod
    def MakeUninitialized(length: int) -> Data:
        """
        Create a new data with uninitialized contents.

        The caller should call :py:meth:`writable_data` to write into the
        buffer, but this must be done before another :py:meth:`ref` is made.
        """
    @staticmethod
    def MakeWithCopy(data: typing_extensions.Buffer) -> Data:
        """
        Create a new dataref by copying the specified data.
        """
    @staticmethod
    def MakeWithoutCopy(data: typing_extensions.Buffer) -> Data:
        """
        Call this when the data parameter is already const and will outlive the
        lifetime of the :py:class:`Data`.

        Suitable for with const globals.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __eq__(self, other: Data) -> bool:
        """
        Returns true if these two objects have the same length and contents,
        effectively returning 0 == memcmp(...)
        """
    def __init__(self, buf: typing_extensions.Buffer, copy: bool = False) -> None:
        """
        Create a new :py:class:`Data`.

        :param Union[bytes,bytearray,memoryview] buf: Buffer object
        :param bool copy: Whether to copy data, default `False`.
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def bytes(self) -> bytes:
        """
        Like data(), returns a read-only ptr into the data, but in this case it
        is cast to ``bytes``.
        """
    def copyRange(self, offset: int, length: int, buffer: typing.Any) -> int:
        """
        Helper to copy a range of the data into a caller-provided buffer.

        Returns the actual number of bytes copied, after clamping offset and
        length to the size of the data. If buffer is NULL, it is ignored, and
        only the computed number of bytes is returned.
        """
    def data(self) -> memoryview:
        """
        Returns the read-only memoryview to the data.
        """
    def deref(self) -> None: ...
    def equals(self, other: Data) -> bool:
        """
        Returns true if these two objects have the same length and contents,
        effectively returning 0 == memcmp(...)
        """
    def isEmpty(self) -> bool: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def size(self) -> int:
        """
        Returns the number of bytes stored.
        """
    def unique(self) -> bool: ...
    def unref(self) -> None: ...
    def writable_data(self) -> memoryview:
        """
        USE WITH CAUTION.

        Returns the read-write memoryview to the data.

        This call will assert that the refcnt is 1, as a precaution against
        modifying the contents when another client/thread has access to the
        data.
        """

class DiscretePathEffect:
    @staticmethod
    def Make(segLength: float, dev: float, seedAssist: int = 0) -> PathEffect:
        """
        Break the path into segments of segLength length, and randomly move the
        endpoints away from the original path by a maximum of deviation.

        Note: works on filled or framed paths

        :param segLength: Segment length
        :param dev: Deviation
        :param seedAssist: This is a caller-supplied seedAssist that modifies
            the seed value that is used to randomize the path segments'
            endpoints. If not supplied it defaults to 0, in which case filtering
            a path multiple times will result in the same set of segments (this
            is useful for testing). If a caller does not want this behaviour
            they can pass in a different seedAssist to get a different set of
            path segments.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Document(RefCnt):
    """

    High-level API for creating a document-based canvas.

    To use:

    1. Create a document, specifying a stream to store the output.
    2. For each "page" of content:

        a. canvas = doc.beginPage(...)
        b. draw_my_content(canvas)
        c. doc.endPage()

    3. Close the document with doc.close().

    ``skia-python`` supports ``with`` syntax to build a document::

        stream = skia.FILEWStream("output.pdf")
        with skia.PDF.MakeDocument(stream) as document:
            with document.page(480, 640) as canvas:
                draw(canvas)


    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __enter__(self) -> Document: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def abort(self) -> None:
        """
        Call :py:meth:`abort` to stop producing the document immediately.

        The stream output must be ignored, and should not be trusted.
        """
    def beginPage(
        self,
        width: float,
        height: float,
        content: Rect | None = None,
    ) -> Canvas:
        """
        Begin a new page for the document, returning the canvas that will draw
        into the page.

        The document owns this canvas, and it will go out of scope when
        :py:meth:`endPage` or :py:meth:`close` is called, or the document is
        deleted.
        """
    def close(self) -> None:
        """
        Call :py:meth:`close` when all pages have been drawn.

        This will close the file or stream holding the document's contents.
        After :py:meth:`close` the document can no longer add new pages.
        Deleting the document will automatically call :py:meth:`close` if need
        be.
        """
    def endPage(self) -> None:
        """
        Call :py:meth:`endPage` when the content for the current page has been
        drawn (into the canvas returned by :py:meth:`beginPage`).

        After this call the canvas returned by :py:meth:`beginPage` will be
        out-of-scope.
        """
    def page(self, width: float, height: float) -> ...: ...

class Drawable(Flattanable):
    """

    Base-class for objects that draw into :py:class:`Canvas`.

    The object has a generation ID, which is guaranteed to be unique across all
    drawables. To allow for clients of the drawable that may want to cache the
    results, the drawable must change its generation ID whenever its internal
    state changes such that it will draw differently.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def draw(self, canvas: Canvas, matrix: Matrix | None = None) -> None:
        """
        Draws into the specified content.

        The drawing sequence will be balanced upon return (i.e. the
        ``saveLevel()`` on the canvas will match what it was when
        :py:meth:`draw` was called, and the current matrix and clip settings
        will not be changed.
        """
    @typing.overload
    def draw(self, canvas: Canvas, x: float, y: float) -> None: ...
    def getBounds(self) -> Rect:
        """
        Return the (conservative) bounds of what the drawable will draw.

        If the drawable can change what it draws (e.g. animation or in response
        to some external change), then this must return a bounds that is always
        valid for all possible states.
        """
    def getGenerationID(self) -> int:
        """
        Return a unique value for this instance.

        If two calls to this return the same value, it is presumed that calling
        the draw() method will render the same thing as well.

        Subclasses that change their state should call
        :py:meth:`notifyDrawingChanged` to ensure that a new value will be
        returned the next time it is called.
        """
    def newPictureSnapshot(self) -> Picture: ...
    def notifyDrawingChanged(self) -> None:
        """
        Calling this invalidates the previous generation ID, and causes a new
        one to be computed the next time getGenerationID() is called.

        Typically this is called by the object itself, in response to its
        internal state changing.
        """

class DynamicMemoryWStream(WStream):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def copyTo(self, dst: typing_extensions.Buffer) -> None:
        """
        More efficient version of read(dst, 0, :py:meth:`bytesWritten`).
        """
    def copyToAndReset(self, dst: typing_extensions.Buffer) -> None:
        """
        Equivalent to :py:meth:`copyTo` followed by :py:meth:`reset`, but may
        save memory use.
        """
    def detachAsData(self) -> Data:
        """
        Return the contents as :py:class:`Data`, and then reset the stream.
        """
    def detachAsStream(self) -> StreamAsset:
        """
        Reset, returning a reader stream with the current content.
        """
    def padToAlign4(self) -> None: ...
    def prependToAndReset(self, dst: DynamicMemoryWStream) -> None:
        """
        Prepend this stream to dst, resetting this.
        """
    def read(self, data: typing_extensions.Buffer, offset: int = 0) -> bool: ...
    def reset(self) -> None: ...
    # @typing.overload
    def writeToAndReset(self, dst: WStream) -> bool:
        """
        Equivalent to :py:meth:`writeToStream` followed by :py:meth:`reset`, but
        may save memory use.
        """
    # @typing.overload
    # def writeToAndReset(self, dst: DynamicMemoryWStream) -> bool:
    #     """
    #     Equivalent to :py:meth:`writeToStream` followed by :py:meth:`reset`, but
    #     may save memory use.
    #     When the dst is also a :py:class:`DynamicMemoryWStream`, the
    #     implementation is constant time.
    #     """
    def writeToStream(self, dst: WStream) -> bool: ...

class EncodedImageFormat:
    """

        Enum describing format of encoded data.


    Members:

      kBMP

      kGIF

      kICO

      kJPEG

      kPNG

      kWBMP

      kWEBP

      kPKM

      kKTX

      kASTC

      kDNG

      kHEIF
    """

    __members__: typing.ClassVar[
        dict[str, EncodedImageFormat]
    ]  # value = {'kBMP': <EncodedImageFormat.kBMP: 0>, 'kGIF': <EncodedImageFormat.kGIF: 1>, 'kICO': <EncodedImageFormat.kICO: 2>, 'kJPEG': <EncodedImageFormat.kJPEG: 3>, 'kPNG': <EncodedImageFormat.kPNG: 4>, 'kWBMP': <EncodedImageFormat.kWBMP: 5>, 'kWEBP': <EncodedImageFormat.kWEBP: 6>, 'kPKM': <EncodedImageFormat.kPKM: 7>, 'kKTX': <EncodedImageFormat.kKTX: 8>, 'kASTC': <EncodedImageFormat.kASTC: 9>, 'kDNG': <EncodedImageFormat.kDNG: 10>, 'kHEIF': <EncodedImageFormat.kHEIF: 11>}
    kASTC: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kASTC: 9>
    kBMP: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kBMP: 0>
    kDNG: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kDNG: 10>
    kGIF: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kGIF: 1>
    kHEIF: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kHEIF: 11>
    kICO: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kICO: 2>
    kJPEG: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kJPEG: 3>
    kKTX: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kKTX: 8>
    kPKM: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kPKM: 7>
    kPNG: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kPNG: 4>
    kWBMP: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kWBMP: 5>
    kWEBP: typing.ClassVar[EncodedImageFormat]  # value = <EncodedImageFormat.kWEBP: 6>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EncodedOrigin:
    """

        Image orientation values from their encoded EXIF data
        These values match the orientation www.exif.org/Exif2-2.PDF.


    Members:

      kTopLeft_EncodedOrigin

      kTopRight_EncodedOrigin

      kBottomRight_EncodedOrigin

      kBottomLeft_EncodedOrigin

      kLeftTop_EncodedOrigin

      kRightTop_EncodedOrigin

      kRightBottom_EncodedOrigin

      kLeftBottom_EncodedOrigin

      kDefault_EncodedOrigin

      kLast_EncodedOrigin
    """

    __members__: typing.ClassVar[
        dict[str, EncodedOrigin]
    ]  # value = {'kTopLeft_EncodedOrigin': <EncodedOrigin.kTopLeft_EncodedOrigin: 1>, 'kTopRight_EncodedOrigin': <EncodedOrigin.kTopRight_EncodedOrigin: 2>, 'kBottomRight_EncodedOrigin': <EncodedOrigin.kBottomRight_EncodedOrigin: 3>, 'kBottomLeft_EncodedOrigin': <EncodedOrigin.kBottomLeft_EncodedOrigin: 4>, 'kLeftTop_EncodedOrigin': <EncodedOrigin.kLeftTop_EncodedOrigin: 5>, 'kRightTop_EncodedOrigin': <EncodedOrigin.kRightTop_EncodedOrigin: 6>, 'kRightBottom_EncodedOrigin': <EncodedOrigin.kRightBottom_EncodedOrigin: 7>, 'kLeftBottom_EncodedOrigin': <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>, 'kDefault_EncodedOrigin': <EncodedOrigin.kTopLeft_EncodedOrigin: 1>, 'kLast_EncodedOrigin': <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>}
    kBottomLeft_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kBottomLeft_EncodedOrigin: 4>
    kBottomRight_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kBottomRight_EncodedOrigin: 3>
    kDefault_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kTopLeft_EncodedOrigin: 1>
    kLast_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>
    kLeftBottom_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>
    kLeftTop_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kLeftTop_EncodedOrigin: 5>
    kRightBottom_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kRightBottom_EncodedOrigin: 7>
    kRightTop_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kRightTop_EncodedOrigin: 6>
    kTopLeft_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kTopLeft_EncodedOrigin: 1>
    kTopRight_EncodedOrigin: typing.ClassVar[
        EncodedOrigin
    ]  # value = <EncodedOrigin.kTopRight_EncodedOrigin: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FILEStream(StreamAsset):
    @staticmethod
    def Make(path: str) -> FILEStream: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __enter__(self) -> FILEStream: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def __init__(self, path: str) -> None: ...
    def close(self) -> None: ...
    def isValid(self) -> bool: ...

class FILEWStream(WStream):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self, path: str) -> None: ...
    def fsync(self) -> None: ...
    def isValid(self) -> bool: ...

class FilterMode:
    """
    Members:

      kNearest : single sample point (nearest neighbor)

      kLinear : interporate between 2x2 sample points (bilinear interpolation)
    """

    __members__: typing.ClassVar[
        dict[str, FilterMode]
    ]  # value = {'kNearest': <FilterMode.kNearest: 0>, 'kLinear': <FilterMode.kLinear: 1>}
    kLinear: typing.ClassVar[FilterMode]  # value = <FilterMode.kLinear: 1>
    kNearest: typing.ClassVar[FilterMode]  # value = <FilterMode.kNearest: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Flattanable(RefCnt):
    """

    :py:class:`Flattenable` is the base class for objects that need to be
    flattened into a data stream for either transport or as part of the key to
    the font cache.

    """
    class Type:
        """
        Members:

          kColorFilter_Type

          kDrawable_Type

          kDrawLooper_Type

          kImageFilter_Type

          kMaskFilter_Type

          kPathEffect_Type
        """

        __members__: typing.ClassVar[
            dict[str, Flattanable.Type]
        ]  # value = {'kColorFilter_Type': <Type.kColorFilter_Type: 0>, 'kDrawable_Type': <Type.kDrawable_Type: 2>, 'kDrawLooper_Type': <Type.kDrawLooper_Type: 3>, 'kImageFilter_Type': <Type.kImageFilter_Type: 4>, 'kMaskFilter_Type': <Type.kMaskFilter_Type: 5>, 'kPathEffect_Type': <Type.kPathEffect_Type: 6>}
        kColorFilter_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kColorFilter_Type: 0>
        kDrawLooper_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kDrawLooper_Type: 3>
        kDrawable_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kDrawable_Type: 2>
        kImageFilter_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kImageFilter_Type: 4>
        kMaskFilter_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kMaskFilter_Type: 5>
        kPathEffect_Type: typing.ClassVar[
            Flattanable.Type
        ]  # value = <Type.kPathEffect_Type: 6>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kColorFilter_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kColorFilter_Type: 0>
    kDrawLooper_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kDrawLooper_Type: 3>
    kDrawable_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kDrawable_Type: 2>
    kImageFilter_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kImageFilter_Type: 4>
    kMaskFilter_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kMaskFilter_Type: 5>
    kPathEffect_Type: typing.ClassVar[
        Flattanable.Type
    ]  # value = <Type.kPathEffect_Type: 6>
    @staticmethod
    def Deserialize(
        type: Flattanable.Type,
        b: typing_extensions.Buffer,
    ) -> Flattanable: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def getFlattenableType(self) -> Flattanable.Type: ...
    def getTypeName(self) -> str:
        """
        Returns the name of the object's class.

        Implemented in :py:class:`~skia.Drawable`.
        """
    def serialize(self) -> Data: ...

class Font:
    """

    :py:class:`Font` controls options applied when drawing and measuring text.

    """
    class Edging:
        """

            Whether edge pixels draw opaque or with partial transparency.


        Members:

          kAlias

          kAntiAlias

          kSubpixelAntiAlias
        """

        __members__: typing.ClassVar[
            dict[str, Font.Edging]
        ]  # value = {'kAlias': <Edging.kAlias: 0>, 'kAntiAlias': <Edging.kAntiAlias: 1>, 'kSubpixelAntiAlias': <Edging.kSubpixelAntiAlias: 2>}
        kAlias: typing.ClassVar[Font.Edging]  # value = <Edging.kAlias: 0>
        kAntiAlias: typing.ClassVar[Font.Edging]  # value = <Edging.kAntiAlias: 1>
        kSubpixelAntiAlias: typing.ClassVar[
            Font.Edging
        ]  # value = <Edging.kSubpixelAntiAlias: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kAlias: typing.ClassVar[Font.Edging]  # value = <Edging.kAlias: 0>
    kAntiAlias: typing.ClassVar[Font.Edging]  # value = <Edging.kAntiAlias: 1>
    kSubpixelAntiAlias: typing.ClassVar[
        Font.Edging
    ]  # value = <Edging.kSubpixelAntiAlias: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: Font) -> bool:
        """
        Compares :py:class:`Font` and font, and returns true if they are
        equivalent.

        May return false if :py:class:`Typeface` has identical contents but
        different pointers.
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Constructs :py:class:`Font` with default values.
        """
    @typing.overload
    def __init__(self, typeface: typing.Any, size: float) -> None:
        """
        Constructs :py:class:`Font` with default values with
        :py:class:`Typeface` and size in points.

        :typeface: font and style used to draw and measure
            text
        :size: typographic height of text
        """
    @typing.overload
    def __init__(self, typeface: typing.Any) -> None:
        """
        Constructs :py:class:`Font` with default values with
        :py:class:`Typeface`.

        :typeface: font and style used to draw and measure
            text
        """
    @typing.overload
    def __init__(
        self,
        typeface: typing.Any,
        size: float,
        scaleX: float,
        skewX: float,
    ) -> None:
        """
        Constructs :py:class:`Font` with default values with
        :py:class:`Typeface` and size in points, horizontal scale, and
        horizontal skew.

        Horizontal scale emulates condensed and expanded fonts. Horizontal skew
        emulates oblique fonts.

        :typeface: font and style used to draw and measure
            text
        :size: typographic height of text
        :scaleX: text horizontal scale
        :skewX: additional shear on x-axis relative to y-axis
        """
    def __ne__(self, arg0: Font) -> bool:
        """
        Compares :py:class:`Font` and font, and returns true if they are not
        equivalent.

        May return true if :py:class:`Typeface` has identical contents but
        different pointers.
        """
    def countText(self, text: str, encoding: TextEncoding = ...) -> int:
        """
        Returns number of glyphs represented by text.

        If encoding is :py:attr:`TextEncoding.kUTF8`,
        :py:attr:`TextEncoding.kUTF16`, or :py:attr:`TextEncoding.kUTF32`; then
        each Unicode codepoint is mapped to a single glyph.

        :param str text: character storage encoded with :py:class:`TextEncoding`
        :param skia.TextEncoding encoding: text encoding
        """
    def dump(self) -> None:
        """
        Dumps fields of the font to SkDebugf.

        May change its output over time, so clients should not rely on this for
        anything specific. Used to aid in debugging.
        """
    def getBounds(self, glyphs: list[int], paint: Paint | None = None) -> list[Rect]:
        """
        Retrieves the bounds for each glyph in glyphs.

        If paint is not nullptr, its stroking, :py:class:`PathEffect`, and
        :py:class:`MaskFilter` fields are respected.

        :param List[int] glyphs: array of glyph indices to be measured
        :param skia.Paint paint: optional, specifies stroking,
            :py:class:`PathEffect`, and :py:class:`MaskFilter`
        :return: bounds for each glyph relative to (0, 0)
        :rtype: List[skia.Rect]
        """
    def getEdging(self) -> Font.Edging:
        """
        Whether edge pixels draw opaque or with partial transparency.
        """
    def getHinting(self) -> FontHinting:
        """
        Returns level of glyph outline adjustment.
        """
    def getMetrics(self) -> FontMetrics:
        """
        Returns :py:class:`FontMetrics` associated with :py:class:`Typeface`.

        Results are scaled by text size but does not take into account
        dimensions required by text scale, text skew, fake bold, style stroke,
        and :py:class:`PathEffect`.

        :rtype: :py:class:`FontMetrics`
        """
    def getPath(self, glyphID: int) -> typing.Any:
        """
        Modifies path to be the outline of the glyph.

        If the glyph has an outline, modifies path to be the glyph's outline and
        returns true. The glyph outline may be empty. Degenerate contours in the
        glyph outline will be skipped. If glyph is described by a bitmap,
        returns false and ignores path parameter.

        :param int glyphID: index of glyph
        :return: true if glyphID is described by path
        """
    def getPaths(self, glyphIDs: list[int]) -> typing.Any:
        """
        Returns path corresponding to glyph array.

        :param glyphIDs: array of glyph indices
        :return: list of :py:class:`Path`
        """
    def getPos(self, glyphs: list[int], origin: Point = ...) -> list[Point]:
        """
        Retrieves the positions for each glyph, beginning at the specified
        origin.

        :param List[int] glyphs: array of glyph indices to be positioned
        :param skia.Point origin: location of the first glyph. Defaults to
            (0, 0).
        :return: glyphs positions
        """
    def getScaleX(self) -> float:
        """
        Returns text scale on x-axis.

        Default value is 1.

        :return: text horizontal scale
        """
    def getSize(self) -> float:
        """
        Returns text size in points.

        :return: typographic height of text
        """
    def getSkewX(self) -> float:
        """
        Returns text skew on x-axis.

        Default value is zero.

        :return: additional shear on x-axis relative to y-axis
        """
    def getSpacing(self) -> float:
        """
        Returns the recommended spacing between lines: the sum of metrics
        descent, ascent, and leading.

        Result is scaled by text size but does not take into account dimensions
        required by stroking and :py:class:`PathEffect`. Returns the same result
        as :py:meth:`getMetrics`.

        :return: recommended spacing between lines
        """
    def getTypeface(self) -> Typeface:
        """
        Returns :py:class:`Typeface` if set, or nullptr.

        :return: :py:class:`Typeface` if previously set, nullptr otherwise
        """
    def getWidths(self, glyphs: list[int]) -> list[float]:
        """
        Retrieves the advance and bounds for each glyph in glyphs.

        :param List[int] glyphs: array of glyph indices to be measured
        :rtype: List[float]
        """
    def getWidthsBounds(self, glyphs: list[int], paint: Paint | None = None) -> tuple:
        """
        Retrieves the advance and bounds for each glyph in glyphs.

        :param List[int] glyphs: array of glyph indices to be measured
        :param skia.Paint paint: optional, specifies stroking,
            :py:class:`PathEffect` and :py:class:`MaskFilter`
        :return: Widths and bounds array
        :rtype: Tuple[List[float],List[skia.Rect]]
        """
    def getXPos(self, glyphs: list[int], origin: float = 0) -> list[float]:
        """
        Retrieves the x-positions for each glyph, beginning at the specified
        origin.

        :param List[int] glyphs: array of glyph indices to be positioned
        :param skia.Point origin: location of the first glyph. Defaults to 0.
        :return: glyphs x-positions
        """
    def isBaselineSnap(self) -> bool:
        """
        Returns true if baselines will be snapped to pixel positions when the
        current transformation matrix is axis aligned.

        :return: baselines may be snapped to pixels
        """
    def isEmbeddedBitmaps(self) -> bool:
        """
        Returns true if font engine may return glyphs from font bitmaps instead
        of from outlines.

        :return: true if glyphs may be font bitmaps
        """
    def isEmbolden(self) -> bool:
        """
        Returns true if bold is approximated by increasing the stroke width when
        creating glyph bitmaps from outlines.

        :return: bold is approximated through stroke width
        """
    def isForceAutoHinting(self) -> bool:
        """
        If true, instructs the font manager to always hint glyphs.

        Returned value is only meaningful if platform uses FreeType as the font
        manager.

        :return: true if all glyphs are hinted
        """
    def isLinearMetrics(self) -> bool:
        """
        Returns true if font and glyph metrics are requested to be linearly
        scalable.

        :return: true if font and glyph metrics are requested to be linearly
            scalable.
        """
    def isSubpixel(self) -> bool:
        """
        Returns true if glyphs may be drawn at sub-pixel offsets.

        :return: true if glyphs may be drawn at sub-pixel offsets.
        """
    def makeWithSize(self, size: float) -> Font:
        """
        Returns a font with the same attributes of this font, but with the
        specified size.

        Returns nullptr if size is less than zero, infinite, or NaN.

        :param float size: typographic height of text
        """
    def measureText(
        self,
        text: str,
        encoding: TextEncoding = ...,
        bounds: Rect | None = None,
        paint: Paint | None = None,
    ) -> float:
        """
        Returns the advance width of text.

        The advance is the normal distance to move before drawing additional
        text. Returns the bounding box of text if bounds is not nullptr. paint
        stroke width or :py:class:`PathEffect` may modify the advance with.

        :param str text: character storage encoded with :py:class:`TextEncoding`
        :param skia.TextEncoding encoding: text encoding
        :param skia.Rect bounds: returns bounding box relative to (0, 0) if not
            nullptr
        :param skia.Paint paint: optional; may be nullptr
        :return: the advance width of text
        """
    def refTypeface(self) -> Typeface:
        """
        Increases :py:class:`Typeface` :py:class:`RefCnt` by one.

        :return: :py:class:`Typeface` if previously set, nullptr otherwise
        """
    def setBaselineSnap(self, baselineSnap: bool) -> None:
        """
        Requests that baselines be snapped to pixels when the current
        transformation matrix is axis aligned.

        :param bool baselineSnap: setting for baseline snapping to pixels
        """
    def setEdging(self, edging: Font.Edging) -> None:
        """
        Requests, but does not require, that edge pixels draw opaque or with
        partial transparency.
        """
    def setEmbeddedBitmaps(self, embeddedBitmaps: bool) -> None:
        """
        Requests, but does not require, to use bitmaps in fonts instead of
        outlines.

        :param bool embeddedBitmaps setting to use bitmaps in fonts
        """
    def setEmbolden(self, embolden: bool) -> None:
        """
        Increases stroke width when creating glyph bitmaps to approximate a bold
        typeface.

        :param bool embolden: setting for bold approximation
        """
    def setForceAutoHinting(self, forceAutoHinting: bool) -> None:
        """
        Sets whether to always hint glyphs.

        If forceAutoHinting is set, instructs the font manager to always hint
        glyphs.

        Only affects platforms that use FreeType as the font manager.

        :param bool forceAutoHinting: setting to always hint glyphs
        """
    def setHinting(self, hintingLevel: FontHinting) -> None:
        """
        Sets level of glyph outline adjustment.

        Does not check for valid values of hintingLevel.
        """
    def setLinearMetrics(self, linearMetrics: bool) -> None:
        """
        Requests, but does not require, linearly scalable font and glyph
        metrics.

        For outline fonts 'true' means font and glyph metrics should ignore
        hinting and rounding. Note that some bitmap formats may not be able to
        scale linearly and will ignore this flag.

        :param bool linearMetrics: setting for linearly scalable font and glyph
            metrics.
        """
    def setScaleX(self, scaleX: float) -> None:
        """
        Sets text scale on x-axis.

        Default value is 1.

        :param float scaleX: text horizontal scale
        """
    def setSize(self, textSize: float) -> None:
        """
        Sets text size in points.

        Has no effect if textSize is not greater than or equal to zero.

        :param float textSize: typographic height of text
        """
    def setSkewX(self, skewX: float) -> None:
        """
        Sets text skew on x-axis.

        Default value is zero.

        :param float skewX: additional shear on x-axis relative to y-axis
        """
    def setSubpixel(self, subpixel: bool) -> None:
        """
        Requests, but does not require, that glyphs respect sub-pixel
        positioning.

        :param bool subpixel: setting for sub-pixel positioning
        """
    def setTypeface(self, typeface: Typeface) -> None:
        """
        Sets :py:class:`Typeface` to typeface, decreasing :py:class:`RefCnt` of
        the previous :py:class:`Typeface`.

        Pass nullptr to clear :py:class:`Typeface` and use the default typeface.
        Increments tf :py:class:`RefCnt` by one.

        :param typeface: font and style used to draw text
        """
    def textToGlyphs(self, text: str, encoding: TextEncoding = ...) -> list[int]:
        """
        Converts text into glyph indices.

        Returns the number of glyph indices represented by text.
        :py:class:`TextEncoding` specifies how text represents characters or
        glyphs.

        Does not check text for valid character codes or valid glyph indices.

        If encoding is :py:attr:`TextEncoding.kUTF8` and text contains an
        invalid UTF-8 sequence, empty array is returned.

        When encoding is :py:attr:`TextEncoding.kUTF8`,
        :py:attr:`TextEncoding.kUTF16`, or :py:attr:`TextEncoding.kUTF32`; then
        each Unicode codepoint is mapped to a single glyph. This function uses
        the default character-to-glyph mapping from the :py:class:`Typeface` and
        maps characters not found in the :py:class:`Typeface` to zero.

        :param str text: character storage encoded with :py:class:`TextEncoding`
        :param skia.TextEncoding encoding: text encoding
        :return: glyphs represented by text
        """
    def unicharToGlyph(self, uni: int) -> int:
        """
        Returns glyph index for Unicode character.

        If the character is not supported by the :py:class:`Typeface`, returns
        0.

        :param int uni: Unicode character
        """
    def unicharsToGlyphs(self, uni: list[int]) -> list[int]: ...

class FontArguments:
    """

    Represents a set of actual arguments for a font.

    """
    class VariationPosition:
        """

        Container of coordinates.

        """
        class Coordinate:
            axis: int
            value: float
            @staticmethod
            def _pybind11_conduit_v1_(*args, **kwargs): ...
            def __init__(self, axis: int, value: float) -> None: ...

        class Coordinates:
            @staticmethod
            def _pybind11_conduit_v1_(*args, **kwargs): ...
            def __bool__(self) -> bool:
                """
                Check whether the list is nonempty
                """
            @typing.overload
            def __delitem__(self, arg0: int) -> None:
                """
                Delete the list elements at index ``i``
                """
            @typing.overload
            def __delitem__(self, arg0: slice) -> None:
                """
                Delete list elements using a slice object
                """
            @typing.overload
            def __getitem__(
                self,
                s: slice,
            ) -> FontArguments.VariationPosition.Coordinates:
                """
                Retrieve list elements using a slice object
                """
            @typing.overload
            def __getitem__(
                self,
                arg0: int,
            ) -> FontArguments.VariationPosition.Coordinate: ...
            @typing.overload
            def __init__(self) -> None: ...
            @typing.overload
            def __init__(
                self,
                arg0: FontArguments.VariationPosition.Coordinates,
            ) -> None:
                """
                Copy constructor
                """
            @typing.overload
            def __init__(self, arg0: typing.Iterable) -> None: ...
            def __iter__(
                self,
            ) -> typing.Iterator[FontArguments.VariationPosition.Coordinate]: ...
            def __len__(self) -> int: ...
            @typing.overload
            def __setitem__(
                self,
                arg0: int,
                arg1: FontArguments.VariationPosition.Coordinate,
            ) -> None: ...
            @typing.overload
            def __setitem__(
                self,
                arg0: slice,
                arg1: FontArguments.VariationPosition.Coordinates,
            ) -> None:
                """
                Assign list elements using a slice object
                """
            def append(self, x: FontArguments.VariationPosition.Coordinate) -> None:
                """
                Add an item to the end of the list
                """
            def clear(self) -> None:
                """
                Clear the contents
                """
            @typing.overload
            def extend(self, L: FontArguments.VariationPosition.Coordinates) -> None:
                """
                Extend the list by appending all the items in the given list
                """
            @typing.overload
            def extend(self, L: typing.Iterable) -> None:
                """
                Extend the list by appending all the items in the given list
                """
            def insert(
                self,
                i: int,
                x: FontArguments.VariationPosition.Coordinate,
            ) -> None:
                """
                Insert an item at a given position.
                """
            @typing.overload
            def pop(self) -> FontArguments.VariationPosition.Coordinate:
                """
                Remove and return the last item
                """
            @typing.overload
            def pop(self, i: int) -> FontArguments.VariationPosition.Coordinate:
                """
                Remove and return the item at index ``i``
                """

        coordinates: FontArguments.VariationPosition.Coordinates
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(
            self,
            coordinates: FontArguments.VariationPosition.Coordinates,
        ) -> None: ...
        @property
        def coordinateCount(self) -> int: ...

    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def getCollectionIndex(self) -> int: ...
    def getVariationDesignPosition(self) -> FontArguments.VariationPosition: ...
    def setCollectionIndex(self, collectionIndex: int) -> FontArguments:
        """
        Specify the index of the desired font.

        Font formats like ttc, dfont, cff, cid, pfr, t42, t1, and fon may
        actually be indexed collections of fonts.
        """
    def setVariationDesignPosition(
        self,
        position: FontArguments.VariationPosition,
    ) -> FontArguments:
        """
        Specify a position in the variation design space.

        Any axis not specified will use the default value. Any specified axis
        not actually present in the font will be ignored.

        :param position: not copied. The value must remain valid for life of
            :py:class:`FontArguments`.
        """

class FontHinting:
    """
    Members:

      kNone

      kSlight

      kNormal

      kFull
    """

    __members__: typing.ClassVar[
        dict[str, FontHinting]
    ]  # value = {'kNone': <FontHinting.kNone: 0>, 'kSlight': <FontHinting.kSlight: 1>, 'kNormal': <FontHinting.kNormal: 2>, 'kFull': <FontHinting.kFull: 3>}
    kFull: typing.ClassVar[FontHinting]  # value = <FontHinting.kFull: 3>
    kNone: typing.ClassVar[FontHinting]  # value = <FontHinting.kNone: 0>
    kNormal: typing.ClassVar[FontHinting]  # value = <FontHinting.kNormal: 2>
    kSlight: typing.ClassVar[FontHinting]  # value = <FontHinting.kSlight: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FontMetrics:
    """

    The metrics of an :py:class:`Font`.

    The metric values are consistent with the Skia y-down coordinate system.

    """
    class FontMetricsFlags:
        """

            FontMetricsFlags indicate when certain metrics are valid; the underline or
            strikeout metrics may be valid and zero.

            Fonts with embedded bitmaps may not have valid underline or strikeout
            metrics.


        Members:

          kUnderlineThicknessIsValid_Flag : set if fUnderlineThickness is valid

          kUnderlinePositionIsValid_Flag : set if fUnderlinePosition is valid

          kStrikeoutThicknessIsValid_Flag : set if fStrikeoutThickness is valid

          kStrikeoutPositionIsValid_Flag : set if fStrikeoutPosition is valid
        """

        __members__: typing.ClassVar[
            dict[str, FontMetrics.FontMetricsFlags]
        ]  # value = {'kUnderlineThicknessIsValid_Flag': <FontMetricsFlags.kUnderlineThicknessIsValid_Flag: 1>, 'kUnderlinePositionIsValid_Flag': <FontMetricsFlags.kUnderlinePositionIsValid_Flag: 2>, 'kStrikeoutThicknessIsValid_Flag': <FontMetricsFlags.kStrikeoutThicknessIsValid_Flag: 4>, 'kStrikeoutPositionIsValid_Flag': <FontMetricsFlags.kStrikeoutPositionIsValid_Flag: 8>}
        kStrikeoutPositionIsValid_Flag: typing.ClassVar[
            FontMetrics.FontMetricsFlags
        ]  # value = <FontMetricsFlags.kStrikeoutPositionIsValid_Flag: 8>
        kStrikeoutThicknessIsValid_Flag: typing.ClassVar[
            FontMetrics.FontMetricsFlags
        ]  # value = <FontMetricsFlags.kStrikeoutThicknessIsValid_Flag: 4>
        kUnderlinePositionIsValid_Flag: typing.ClassVar[
            FontMetrics.FontMetricsFlags
        ]  # value = <FontMetricsFlags.kUnderlinePositionIsValid_Flag: 2>
        kUnderlineThicknessIsValid_Flag: typing.ClassVar[
            FontMetrics.FontMetricsFlags
        ]  # value = <FontMetricsFlags.kUnderlineThicknessIsValid_Flag: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kStrikeoutPositionIsValid_Flag: typing.ClassVar[
        FontMetrics.FontMetricsFlags
    ]  # value = <FontMetricsFlags.kStrikeoutPositionIsValid_Flag: 8>
    kStrikeoutThicknessIsValid_Flag: typing.ClassVar[
        FontMetrics.FontMetricsFlags
    ]  # value = <FontMetricsFlags.kStrikeoutThicknessIsValid_Flag: 4>
    kUnderlinePositionIsValid_Flag: typing.ClassVar[
        FontMetrics.FontMetricsFlags
    ]  # value = <FontMetricsFlags.kUnderlinePositionIsValid_Flag: 2>
    kUnderlineThicknessIsValid_Flag: typing.ClassVar[
        FontMetrics.FontMetricsFlags
    ]  # value = <FontMetricsFlags.kUnderlineThicknessIsValid_Flag: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def hasStrikeoutPosition(self, position: float) -> bool:
        """
        Returns true if :py:class:`FontMetrics` has a valid strikeout position,
        and sets position to that value.

        If the underline position is not valid, return false, and ignore
        position.

        :param float position: storage for strikeout position
        :return: true if font specifies strikeout position
        """
    def hasStrikeoutThickness(self, thickness: float) -> bool:
        """
        Returns true if :py:class:`FontMetrics` has a valid strikeout thickness,
        and sets thickness to that value.

        If the underline thickness is not valid, return false, and ignore
        thickness.

        :param float thickness: storage for strikeout width
        :return: true if font specifies strikeout width
        """
    def hasUnderlinePosition(self, position: float) -> bool:
        """
        Returns true if :py:class:`FontMetrics` has a valid underline position,
        and sets position to that value.

        If the underline position is not valid, return false, and ignore
        position.

        :param float position: storage for underline position
        :return: true if font specifies underline position
        """
    def hasUnderlineThickness(self, thickness: float) -> bool:
        """
        Returns true if :py:class:`FontMetrics` has a valid underline thickness,
        and sets thickness to that value.

        If the underline thickness is not valid, return false, and ignore
        thickness.

        :param thickness: storage for underline width
        :return: true if font specifies underline width
        """
    @property
    def fAscent(self) -> float:
        """
        distance to reserve above baseline, typically negative
        """
    @fAscent.setter
    def fAscent(self, arg0: float) -> None: ...
    @property
    def fAvgCharWidth(self) -> float:
        """
        average character width, zero if unknown
        """
    @fAvgCharWidth.setter
    def fAvgCharWidth(self, arg0: float) -> None: ...
    @property
    def fBottom(self) -> float:
        """
        greatest extent below origin of any glyph bounding box, typically
        positive; deprecated with variable fonts
        """
    @fBottom.setter
    def fBottom(self, arg0: float) -> None: ...
    @property
    def fCapHeight(self) -> float:
        """
        height of an upper-case letter, zero if unknown, typically negative
        """
    @fCapHeight.setter
    def fCapHeight(self, arg0: float) -> None: ...
    @property
    def fDescent(self) -> float:
        """
        distance to reserve below baseline, typically positive
        """
    @fDescent.setter
    def fDescent(self, arg0: float) -> None: ...
    @property
    def fFlags(self) -> int:
        """
        FontMetricsFlags indicating which metrics are valid.
        """
    @fFlags.setter
    def fFlags(self, arg0: int) -> None: ...
    @property
    def fLeading(self) -> float:
        """
        distance to add between lines, typically positive or zero
        """
    @fLeading.setter
    def fLeading(self, arg0: float) -> None: ...
    @property
    def fMaxCharWidth(self) -> float:
        """
        maximum character width, zero if unknown
        """
    @fMaxCharWidth.setter
    def fMaxCharWidth(self, arg0: float) -> None: ...
    @property
    def fStrikeoutPosition(self) -> float:
        """
        distance from baseline to bottom of stroke, typically negative
        """
    @fStrikeoutPosition.setter
    def fStrikeoutPosition(self, arg0: float) -> None: ...
    @property
    def fStrikeoutThickness(self) -> float:
        """
        strikeout thickness
        """
    @fStrikeoutThickness.setter
    def fStrikeoutThickness(self, arg0: float) -> None: ...
    @property
    def fTop(self) -> float:
        """
        greatest extent above origin of any glyph bounding box, typically
        negative; deprecated with variable fonts
        """
    @fTop.setter
    def fTop(self, arg0: float) -> None: ...
    @property
    def fUnderlinePosition(self) -> float:
        """
        distance from baseline to top of stroke, typically positive
        """
    @fUnderlinePosition.setter
    def fUnderlinePosition(self, arg0: float) -> None: ...
    @property
    def fUnderlineThickness(self) -> float:
        """
        underline thickness
        """
    @fUnderlineThickness.setter
    def fUnderlineThickness(self, arg0: float) -> None: ...
    @property
    def fXHeight(self) -> float:
        """
        height of lower-case 'x', zero if unknown, typically negative
        """
    @fXHeight.setter
    def fXHeight(self, arg0: float) -> None: ...
    @property
    def fXMax(self) -> float:
        """
        greatest extent to right of origin of any glyph bounding box, typically
        positive; deprecated with variable fonts
        """
    @fXMax.setter
    def fXMax(self, arg0: float) -> None: ...
    @property
    def fXMin(self) -> float:
        """
        greatest extent to left of origin of any glyph bounding box, typically
        negative; deprecated with variable fonts
        """
    @fXMin.setter
    def fXMin(self, arg0: float) -> None: ...

class FontMgr(RefCnt):
    """

    Font manager that knows system fonts.

    Example::

        fontmgr = skia.FontMgr()
        print(list(fontmgr))
        familyName = fontmgr[0]

        typeface = fontmgr.matchFamilyStyle(familyName, skia.FontStyle.Normal())
        assert typeface is not None


    """
    @staticmethod
    @typing.overload
    def New_Custom_Empty() -> FontMgr: ...
    @staticmethod
    @typing.overload
    def New_Custom_Empty(filename: str) -> FontMgr: ...
    @staticmethod
    @typing.overload
    def New_Custom_Empty(data: Data) -> FontMgr: ...
    @staticmethod
    def OneFontMgr(*args, **kwargs):
        """
        New_Custom_Empty(*args, **kwargs)
        Overloaded function.

        1. New_Custom_Empty() -> skia.FontMgr

        2. New_Custom_Empty(filename: str) -> skia.FontMgr

        3. New_Custom_Empty(data: skia.Data) -> skia.FontMgr
        """
    @staticmethod
    def RefDefault() -> FontMgr:
        """
        Return the default fontmgr.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __getitem__(self, index: int) -> str: ...
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def countFamilies(self) -> int: ...
    def createStyleSet(self, index: int) -> FontStyleSet: ...
    def getFamilyName(self, index: int) -> str: ...
    def legacyMakeTypeface(self, familyName: str, style: FontStyle) -> Typeface: ...
    def makeFromData(self, data: Data, ttcIndex: int = 0) -> Typeface:
        """
        Create a typeface for the specified data and TTC index (pass 0 for none)
        or NULL if the data is not recognized.
        """
    def makeFromFile(self, path: str, ttcIndex: int = 0) -> Typeface:
        """
        Create a typeface for the specified fileName and TTC index (pass 0 for
        none) or NULL if the file is not found, or its contents are not
        recognized.
        """
    def matchFamily(self, familyName: str) -> FontStyleSet:
        """
        Never returns NULL; will return an empty set if the name is not found.

        Passing nullptr as the parameter will return the default system family.
        Note that most systems don't have a default system family, so passing
        nullptr will often result in the empty set.

        It is possible that this will return a style set not accessible from
        createStyleSet(int) due to hidden or auto-activated fonts.
        """
    def matchFamilyStyle(self, familyName: typing.Any, style: FontStyle) -> Typeface:
        """
        Find the closest matching typeface to the specified familyName and style
        and return a ref to it.

        Will return nullptr if no 'good' match is found.

        Passing nullptr as the parameter for familyName will return the
        default system font.

        It is possible that this will return a style set not accessible from
        createStyleSet(int) or matchFamily(const char[]) due to hidden or
        auto-activated fonts.
        """
    def matchFamilyStyleCharacter(
        self,
        familyName: str,
        style: FontStyle,
        bcp47: list[str],
        character: int,
    ) -> Typeface:
        """
        Use the system fallback to find a typeface for the given character.

        Note that bcp47 is a combination of ISO 639, 15924, and 3166-1 codes, so
        it is fine to just pass a ISO 639 here.

        Will return NULL if no family can be found for the character in the
        system fallback.

        Passing nullptr as the parameter for familyName will return the
        default system font.

        bcp47[0] is the least significant fallback, bcp47[bcp47Count-1] is the
        most significant. If no specified bcp47 codes match, any font with the
        requested character will be matched.
        """

class FontParameters:
    class Variation:
        """

        Parameters in a variation font axis.

        """
        class Axis:
            @staticmethod
            def _pybind11_conduit_v1_(*args, **kwargs): ...
            def __init__(self) -> None: ...
            def isHidden(self) -> bool:
                """
                Return whether this axis is recommended to be remain hidden in user
                interfaces.
                """
            def setHidden(self, hidden: bool) -> None:
                """
                Set this axis to be remain hidden in user interfaces.
                """
            # @property
            # def def(self) -> float:
            #     """
            #             Default value set by this axis.
            #     """
            # @def.setter
            # def def(self, arg0: float) -> None:
            #     ...
            @property
            def max(self) -> float:
                """
                Maximum value supported by this axis. The maximum can equal the minimum.
                """
            @max.setter
            def max(self, arg0: float) -> None: ...
            @property
            def min(self) -> float:
                """
                Minimum value supported by this axis.
                """
            @min.setter
            def min(self, arg0: float) -> None: ...
            @property
            def tag(self) -> int:
                """
                Four character identifier of the font axis (weight, width, slant,
                italic...).
                """
            @tag.setter
            def tag(self, arg0: int) -> None: ...

        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...

    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class FontStyle:
    class Slant:
        """
        Members:

          kUpright_Slant

          kItalic_Slant

          kOblique_Slant
        """

        __members__: typing.ClassVar[
            dict[str, FontStyle.Slant]
        ]  # value = {'kUpright_Slant': <Slant.kUpright_Slant: 0>, 'kItalic_Slant': <Slant.kItalic_Slant: 1>, 'kOblique_Slant': <Slant.kOblique_Slant: 2>}
        kItalic_Slant: typing.ClassVar[
            FontStyle.Slant
        ]  # value = <Slant.kItalic_Slant: 1>
        kOblique_Slant: typing.ClassVar[
            FontStyle.Slant
        ]  # value = <Slant.kOblique_Slant: 2>
        kUpright_Slant: typing.ClassVar[
            FontStyle.Slant
        ]  # value = <Slant.kUpright_Slant: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Weight:
        """
        Members:

          kInvisible_Weight

          kThin_Weight

          kExtraLight_Weight

          kLight_Weight

          kNormal_Weight

          kMedium_Weight

          kSemiBold_Weight

          kBold_Weight

          kExtraBold_Weight

          kBlack_Weight

          kExtraBlack_Weight
        """

        __members__: typing.ClassVar[
            dict[str, FontStyle.Weight]
        ]  # value = {'kInvisible_Weight': <Weight.kInvisible_Weight: 0>, 'kThin_Weight': <Weight.kThin_Weight: 100>, 'kExtraLight_Weight': <Weight.kExtraLight_Weight: 200>, 'kLight_Weight': <Weight.kLight_Weight: 300>, 'kNormal_Weight': <Weight.kNormal_Weight: 400>, 'kMedium_Weight': <Weight.kMedium_Weight: 500>, 'kSemiBold_Weight': <Weight.kSemiBold_Weight: 600>, 'kBold_Weight': <Weight.kBold_Weight: 700>, 'kExtraBold_Weight': <Weight.kExtraBold_Weight: 800>, 'kBlack_Weight': <Weight.kBlack_Weight: 900>, 'kExtraBlack_Weight': <Weight.kExtraBlack_Weight: 1000>}
        kBlack_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kBlack_Weight: 900>
        kBold_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kBold_Weight: 700>
        kExtraBlack_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kExtraBlack_Weight: 1000>
        kExtraBold_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kExtraBold_Weight: 800>
        kExtraLight_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kExtraLight_Weight: 200>
        kInvisible_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kInvisible_Weight: 0>
        kLight_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kLight_Weight: 300>
        kMedium_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kMedium_Weight: 500>
        kNormal_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kNormal_Weight: 400>
        kSemiBold_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kSemiBold_Weight: 600>
        kThin_Weight: typing.ClassVar[
            FontStyle.Weight
        ]  # value = <Weight.kThin_Weight: 100>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Width:
        """
        Members:

          kUltraCondensed_Width

          kExtraCondensed_Width

          kCondensed_Width

          kSemiCondensed_Width

          kNormal_Width

          kSemiExpanded_Width

          kExpanded_Width

          kExtraExpanded_Width

          kUltraExpanded_Width
        """

        __members__: typing.ClassVar[
            dict[str, FontStyle.Width]
        ]  # value = {'kUltraCondensed_Width': <Width.kUltraCondensed_Width: 1>, 'kExtraCondensed_Width': <Width.kExtraCondensed_Width: 2>, 'kCondensed_Width': <Width.kCondensed_Width: 3>, 'kSemiCondensed_Width': <Width.kSemiCondensed_Width: 4>, 'kNormal_Width': <Width.kNormal_Width: 5>, 'kSemiExpanded_Width': <Width.kSemiExpanded_Width: 6>, 'kExpanded_Width': <Width.kExpanded_Width: 7>, 'kExtraExpanded_Width': <Width.kExtraExpanded_Width: 8>, 'kUltraExpanded_Width': <Width.kUltraExpanded_Width: 9>}
        kCondensed_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kCondensed_Width: 3>
        kExpanded_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kExpanded_Width: 7>
        kExtraCondensed_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kExtraCondensed_Width: 2>
        kExtraExpanded_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kExtraExpanded_Width: 8>
        kNormal_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kNormal_Width: 5>
        kSemiCondensed_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kSemiCondensed_Width: 4>
        kSemiExpanded_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kSemiExpanded_Width: 6>
        kUltraCondensed_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kUltraCondensed_Width: 1>
        kUltraExpanded_Width: typing.ClassVar[
            FontStyle.Width
        ]  # value = <Width.kUltraExpanded_Width: 9>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kBlack_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kBlack_Weight: 900>
    kBold_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kBold_Weight: 700>
    kCondensed_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kCondensed_Width: 3>
    kExpanded_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kExpanded_Width: 7>
    kExtraBlack_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kExtraBlack_Weight: 1000>
    kExtraBold_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kExtraBold_Weight: 800>
    kExtraCondensed_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kExtraCondensed_Width: 2>
    kExtraExpanded_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kExtraExpanded_Width: 8>
    kExtraLight_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kExtraLight_Weight: 200>
    kInvisible_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kInvisible_Weight: 0>
    kItalic_Slant: typing.ClassVar[FontStyle.Slant]  # value = <Slant.kItalic_Slant: 1>
    kLight_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kLight_Weight: 300>
    kMedium_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kMedium_Weight: 500>
    kNormal_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kNormal_Weight: 400>
    kNormal_Width: typing.ClassVar[FontStyle.Width]  # value = <Width.kNormal_Width: 5>
    kOblique_Slant: typing.ClassVar[
        FontStyle.Slant
    ]  # value = <Slant.kOblique_Slant: 2>
    kSemiBold_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kSemiBold_Weight: 600>
    kSemiCondensed_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kSemiCondensed_Width: 4>
    kSemiExpanded_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kSemiExpanded_Width: 6>
    kThin_Weight: typing.ClassVar[
        FontStyle.Weight
    ]  # value = <Weight.kThin_Weight: 100>
    kUltraCondensed_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kUltraCondensed_Width: 1>
    kUltraExpanded_Width: typing.ClassVar[
        FontStyle.Width
    ]  # value = <Width.kUltraExpanded_Width: 9>
    kUpright_Slant: typing.ClassVar[
        FontStyle.Slant
    ]  # value = <Slant.kUpright_Slant: 0>
    @staticmethod
    def Bold() -> FontStyle: ...
    @staticmethod
    def BoldItalic() -> FontStyle: ...
    @staticmethod
    def Italic() -> FontStyle: ...
    @staticmethod
    def Normal() -> FontStyle: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self, weight: int, width: int, slant: FontStyle.Slant) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    def slant(self) -> FontStyle.Slant: ...
    def weight(self) -> int: ...
    def width(self) -> int: ...

class FontStyleSet(RefCnt):
    @staticmethod
    def CreateEmpty() -> FontStyleSet: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __getitem__(self, index: int) -> tuple: ...
    def __len__(self) -> int: ...
    def count(self) -> int: ...
    def createTypeface(self, index: int) -> Typeface: ...
    def getStyle(self, index: int) -> tuple: ...
    def matchStyle(self, pattern: FontStyle) -> Typeface: ...

class GrBackendApi:
    """

        Possible 3D APIs that may be used by Ganesh.


    Members:

      kOpenGL

      kVulkan

      kMetal

      kDirect3D

      kMock :
            Mock is a backend that does not draw anything. It is used for unit tests
            and to measure CPU overhead.


      kOpenGL_GrBackend :
            Added here to support the legacy GrBackend enum value and clients who
            referenced it using :py:attr:`~skia.GrBackend.kOpenGL_GrBackend`.

    """

    __members__: typing.ClassVar[
        dict[str, GrBackendApi]
    ]  # value = {'kOpenGL': <GrBackendApi.kOpenGL: 0>, 'kVulkan': <GrBackendApi.kVulkan: 1>, 'kMetal': <GrBackendApi.kMetal: 2>, 'kDirect3D': <GrBackendApi.kDirect3D: 3>, 'kMock': <GrBackendApi.kMock: 4>, 'kOpenGL_GrBackend': <GrBackendApi.kOpenGL: 0>}
    kDirect3D: typing.ClassVar[GrBackendApi]  # value = <GrBackendApi.kDirect3D: 3>
    kMetal: typing.ClassVar[GrBackendApi]  # value = <GrBackendApi.kMetal: 2>
    kMock: typing.ClassVar[GrBackendApi]  # value = <GrBackendApi.kMock: 4>
    kOpenGL: typing.ClassVar[GrBackendApi]  # value = <GrBackendApi.kOpenGL: 0>
    kOpenGL_GrBackend: typing.ClassVar[
        GrBackendApi
    ]  # value = <GrBackendApi.kOpenGL: 0>
    kVulkan: typing.ClassVar[GrBackendApi]  # value = <GrBackendApi.kVulkan: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrBackendFormat:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def MakeGL(format: int, target: int) -> GrBackendFormat: ...
    @staticmethod
    def MakeMock(
        colorType: GrColorType,
        compression: TextureCompressionType,
        isStencilFormat: bool = False,
    ) -> GrBackendFormat: ...
    @staticmethod
    @typing.overload
    def MakeVk(
        format: VkFormat,
        willUseDRMFormatModifiers: bool = False,
    ) -> GrBackendFormat: ...
    @staticmethod
    @typing.overload
    def MakeVk(
        ycbcrInfo: ...,
        willUseDRMFormatModifiers: bool = False,
    ) -> GrBackendFormat: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: GrBackendFormat) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: GrBackendFormat) -> None: ...
    def __ne__(self, other: GrBackendFormat) -> bool: ...
    def asGLFormat(self) -> GrGLFormat: ...
    def asMockColorType(self) -> GrColorType: ...
    def asMockCompressionType(self) -> TextureCompressionType: ...
    def asVkFormat(self, format: VkFormat) -> bool: ...
    def backend(self) -> GrBackendApi: ...
    def channelMask(self) -> int: ...
    def getVkYcbcrConversionInfo(self) -> ...: ...
    def isValid(self) -> bool: ...
    def makeTexture2D(self) -> GrBackendFormat: ...
    def textureType(self) -> GrTextureType: ...

class GrBackendRenderTarget:
    @staticmethod
    def MakeGL(
        width: int,
        height: int,
        sampleCnt: int,
        stencilBits: int,
        glInfo: GrGLFramebufferInfo,
    ) -> GrBackendRenderTarget: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        sampleCnt: int,
        stencilBits: int,
        glInfo: GrGLFramebufferInfo,
    ) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, vkInfo: GrVkImageInfo) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        sampleCnt: int,
        vkInfo: GrVkImageInfo,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        sampleCnt: int,
        stencilBits: int,
        mockInfo: GrMockRenderTargetInfo,
    ) -> None: ...
    def backend(self) -> GrBackendApi: ...
    def dimensions(self) -> ISize: ...
    def getBackendFormat(self) -> GrBackendFormat:
        """
        Get the GrBackendFormat for this render target (or an invalid format if
        this is not valid).
        """
    def getGLFramebufferInfo(self, info: GrGLFramebufferInfo) -> bool:
        """
        If the backend API is GL, copies a snapshot of the GrGLFramebufferInfo
        struct into the passed in pointer and returns true. Otherwise returns
        false if the backend API is not GL.
        """
    def getMockRenderTargetInfo(self, info: GrMockRenderTargetInfo) -> bool:
        """
        If the backend API is Mock, copies a snapshot of the GrMockTextureInfo
        struct into the passed in pointer and returns true. Otherwise returns
        false if the backend API is not Mock.
        """
    def getVkImageInfo(self, info: GrVkImageInfo) -> bool:
        """
        If the backend API is Vulkan, copies a snapshot of the GrVkImageInfo
        struct into the passed in pointer and returns true. This snapshot will
        set the fImageLayout to the current layout state. Otherwise returns
        false if the backend API is not Vulkan.
        """
    def height(self) -> int: ...
    def isFramebufferOnly(self) -> bool: ...
    def isProtected(self) -> bool: ...
    def isValid(self) -> bool: ...
    def sampleCnt(self) -> int: ...
    def setVkImageLayout(self, layout: VkImageLayout) -> None:
        """
        Anytime the client changes the VkImageLayout of the VkImage captured by
        this GrBackendRenderTarget, they must call this function to notify Skia
        of the changed layout.
        """
    def stencilBits(self) -> int: ...
    def width(self) -> int: ...

class GrBackendSemaphore:
    @staticmethod
    def MakeVk(semaphore: capsule) -> GrBackendSemaphore: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def isInitialized(self) -> bool: ...
    def vkSemaphore(self) -> capsule: ...

class GrBackendTexture:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        mipMapped: GrMipmapped,
        glInfo: GrGLTextureInfo,
    ) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int, vkInfo: GrVkImageInfo) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        mipMapped: GrMipmapped,
        mockInfo: GrMockTextureInfo,
    ) -> None: ...
    @typing.overload
    def __init__(self, that: GrBackendTexture) -> None: ...
    def backend(self) -> GrBackendApi: ...
    def dimensions(self) -> ISize: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def getGLTextureInfo(self, info: GrGLTextureInfo) -> bool: ...
    def getMockTextureInfo(self, info: GrMockTextureInfo) -> bool: ...
    def getVkImageInfo(self, info: GrVkImageInfo) -> bool: ...
    def glTextureParametersModified(self) -> None: ...
    def hasMipmaps(self) -> bool: ...
    def height(self) -> int: ...
    def isProtected(self) -> bool: ...
    def isSameTexture(self, texture: GrBackendTexture) -> bool: ...
    def isValid(self) -> bool: ...
    def setMutableState(self, state: ...) -> None: ...
    def setVkImageLayout(self, layout: VkImageLayout) -> None: ...
    def width(self) -> int: ...

class GrColorType:
    """
    Members:

      kUnknown

      kAlpha_8

      kBGR_565

      kABGR_4444

      kRGBA_8888

      kRGBA_8888_SRGB

      kRGB_888x

      kRG_88

      kBGRA_8888

      kRGBA_1010102

      kGray_8

      kAlpha_F16

      kRGBA_F16

      kRGBA_F16_Clamped

      kRGBA_F32

      kAlpha_16

      kRG_1616

      kRG_F16

      kRGBA_16161616

      kAlpha_8xxx

      kAlpha_F32xxx

      kGray_8xxx

      kRGB_888

      kR_8

      kR_16

      kR_F16

      kGray_F16

      kLast
    """

    __members__: typing.ClassVar[
        dict[str, GrColorType]
    ]  # value = {'kUnknown': <GrColorType.kUnknown: 0>, 'kAlpha_8': <GrColorType.kAlpha_8: 1>, 'kBGR_565': <GrColorType.kBGR_565: 2>, 'kABGR_4444': <GrColorType.kABGR_4444: 4>, 'kRGBA_8888': <GrColorType.kRGBA_8888: 5>, 'kRGBA_8888_SRGB': <GrColorType.kRGBA_8888_SRGB: 6>, 'kRGB_888x': <GrColorType.kRGB_888x: 7>, 'kRG_88': <GrColorType.kRG_88: 8>, 'kBGRA_8888': <GrColorType.kBGRA_8888: 9>, 'kRGBA_1010102': <GrColorType.kRGBA_1010102: 10>, 'kGray_8': <GrColorType.kGray_8: 14>, 'kAlpha_F16': <GrColorType.kAlpha_F16: 16>, 'kRGBA_F16': <GrColorType.kRGBA_F16: 17>, 'kRGBA_F16_Clamped': <GrColorType.kRGBA_F16_Clamped: 19>, 'kRGBA_F32': <GrColorType.kRGBA_F32: 20>, 'kAlpha_16': <GrColorType.kAlpha_16: 21>, 'kRG_1616': <GrColorType.kRG_1616: 22>, 'kRG_F16': <GrColorType.kRG_F16: 23>, 'kRGBA_16161616': <GrColorType.kRGBA_16161616: 24>, 'kAlpha_8xxx': <GrColorType.kAlpha_8xxx: 25>, 'kAlpha_F32xxx': <GrColorType.kAlpha_F32xxx: 26>, 'kGray_8xxx': <GrColorType.kGray_8xxx: 27>, 'kRGB_888': <GrColorType.kRGB_888: 29>, 'kR_8': <GrColorType.kR_8: 30>, 'kR_16': <GrColorType.kR_16: 31>, 'kR_F16': <GrColorType.kR_F16: 32>, 'kGray_F16': <GrColorType.kGray_F16: 33>, 'kLast': <GrColorType.kLast: 35>}
    kABGR_4444: typing.ClassVar[GrColorType]  # value = <GrColorType.kABGR_4444: 4>
    kAlpha_16: typing.ClassVar[GrColorType]  # value = <GrColorType.kAlpha_16: 21>
    kAlpha_8: typing.ClassVar[GrColorType]  # value = <GrColorType.kAlpha_8: 1>
    kAlpha_8xxx: typing.ClassVar[GrColorType]  # value = <GrColorType.kAlpha_8xxx: 25>
    kAlpha_F16: typing.ClassVar[GrColorType]  # value = <GrColorType.kAlpha_F16: 16>
    kAlpha_F32xxx: typing.ClassVar[
        GrColorType
    ]  # value = <GrColorType.kAlpha_F32xxx: 26>
    kBGRA_8888: typing.ClassVar[GrColorType]  # value = <GrColorType.kBGRA_8888: 9>
    kBGR_565: typing.ClassVar[GrColorType]  # value = <GrColorType.kBGR_565: 2>
    kGray_8: typing.ClassVar[GrColorType]  # value = <GrColorType.kGray_8: 14>
    kGray_8xxx: typing.ClassVar[GrColorType]  # value = <GrColorType.kGray_8xxx: 27>
    kGray_F16: typing.ClassVar[GrColorType]  # value = <GrColorType.kGray_F16: 33>
    kLast: typing.ClassVar[GrColorType]  # value = <GrColorType.kLast: 35>
    kRGBA_1010102: typing.ClassVar[
        GrColorType
    ]  # value = <GrColorType.kRGBA_1010102: 10>
    kRGBA_16161616: typing.ClassVar[
        GrColorType
    ]  # value = <GrColorType.kRGBA_16161616: 24>
    kRGBA_8888: typing.ClassVar[GrColorType]  # value = <GrColorType.kRGBA_8888: 5>
    kRGBA_8888_SRGB: typing.ClassVar[
        GrColorType
    ]  # value = <GrColorType.kRGBA_8888_SRGB: 6>
    kRGBA_F16: typing.ClassVar[GrColorType]  # value = <GrColorType.kRGBA_F16: 17>
    kRGBA_F16_Clamped: typing.ClassVar[
        GrColorType
    ]  # value = <GrColorType.kRGBA_F16_Clamped: 19>
    kRGBA_F32: typing.ClassVar[GrColorType]  # value = <GrColorType.kRGBA_F32: 20>
    kRGB_888: typing.ClassVar[GrColorType]  # value = <GrColorType.kRGB_888: 29>
    kRGB_888x: typing.ClassVar[GrColorType]  # value = <GrColorType.kRGB_888x: 7>
    kRG_1616: typing.ClassVar[GrColorType]  # value = <GrColorType.kRG_1616: 22>
    kRG_88: typing.ClassVar[GrColorType]  # value = <GrColorType.kRG_88: 8>
    kRG_F16: typing.ClassVar[GrColorType]  # value = <GrColorType.kRG_F16: 23>
    kR_16: typing.ClassVar[GrColorType]  # value = <GrColorType.kR_16: 31>
    kR_8: typing.ClassVar[GrColorType]  # value = <GrColorType.kR_8: 30>
    kR_F16: typing.ClassVar[GrColorType]  # value = <GrColorType.kR_F16: 32>
    kUnknown: typing.ClassVar[GrColorType]  # value = <GrColorType.kUnknown: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrContextOptions:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrContext_Base(RefCnt):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def asDirectContext(self) -> GrDirectContext:
        """
        Safely downcast to a :py:class:`GrDirectContext`.
        """
    def backend(self) -> GrBackendApi:
        """
        The 3D API backing this context.
        """
    def compressedBackendFormat(
        self,
        arg0: TextureCompressionType,
    ) -> GrBackendFormat: ...
    def defaultBackendFormat(
        self,
        arg0: ColorType,
        arg1: GrRenderable,
    ) -> GrBackendFormat:
        """
        Retrieve the default :py:class:`GrBackendFormat` for a given
        :py:class:`ColorType` and renderability. It is guaranteed that this
        backend format will be the one used by the :py:class:`GrContext`
        :py:class:`ColorType` and SurfaceCharacterization-based
        :py:meth:`createBackendTexture` methods.

        The caller should check that the returned format is valid.
        """
    def threadSafeProxy(self) -> GrContextThreadSafeProxy: ...

class GrDirectContext(GrRecordingContext):
    @staticmethod
    def ComputeImageSize(
        image: Image,
        mipMapped: GrMipmapped,
        useNextPow2: bool = False,
    ) -> int: ...
    @staticmethod
    @typing.overload
    def MakeGL(interface: GrGLInterface, options: GrContextOptions) -> GrDirectContext:
        """
        Creates a :py:class:`GrDirectContext` for a backend context. If no
        GrGLInterface is provided then the result of GrGLMakeNativeInterface()
        is used if it succeeds.
        """
    @staticmethod
    @typing.overload
    def MakeGL(interface: GrGLInterface) -> GrDirectContext: ...
    @staticmethod
    @typing.overload
    def MakeGL(options: GrContextOptions) -> GrDirectContext: ...
    @staticmethod
    @typing.overload
    def MakeGL() -> GrDirectContext: ...
    @staticmethod
    @typing.overload
    def MakeMock(
        mockOptions: GrMockOptions,
        options: GrContextOptions,
    ) -> GrDirectContext: ...
    @staticmethod
    @typing.overload
    def MakeMock(mockOptions: GrMockOptions) -> GrDirectContext: ...
    @staticmethod
    @typing.overload
    def MakeVulkan(backendContext: ..., options: GrContextOptions) -> GrDirectContext:
        """
        The Vulkan context (VkQueue, VkDevice, VkInstance) must be kept alive
        until the returned GrDirectContext is destroyed. This also means that
        any objects created with this GrDirectContext (e.g. Surfaces, Images,
        etc.) must also be released as they may hold refs on the
        GrDirectContext. Once all these objects and the GrDirectContext are
        released, then it is safe to delete the vulkan objects.
        """
    @staticmethod
    @typing.overload
    def MakeVulkan(backendContext: ...) -> GrDirectContext: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def abandonContext(self) -> None:
        """
        Abandons all GPU resources and assumes the underlying backend 3D API
        context is no longer usable.

        Call this if you have lost the associated GPU context, and thus internal
        texture, buffer, etc. references/IDs are now invalid. Calling this
        ensures that the destructors of the :py:class:`GrContext` and any of its
        created resource objects will not make backend 3D API calls. Content
        rendered but not previously flushed may be lost. After this function is
        called all subsequent calls on the GrContext will fail or be no-ops.

        The typical use case for this function is that the underlying 3D context
        was lost and further API calls may crash.

        For Vulkan, even if the device becomes lost, the VkQueue, VkDevice, or
        VkInstance used to create the GrContext must be alive before calling
        abandonContext.
        """
    def abandoned(self) -> bool:
        """
        Returns true if the context was abandoned or if the if the backend
        specific context has gotten into an unrecoverarble, lost state (e.g.

        in Vulkan backend if we've gotten a VK_ERROR_DEVICE_LOST). If the
        backend context is lost, this call will also abandon the GrContext.
        """
    def checkAsyncWorkCompletion(self) -> None:
        """
        Checks whether any asynchronous work is complete and if so calls related
        callbacks.
        """
    def colorTypeSupportedAsImage(self, colorType: ColorType) -> bool:
        """
        Can a :py:class:`Image` be created with the given color type.
        """
    def colorTypeSupportedAsSurface(self, colorType: ColorType) -> bool:
        """
        Can a SkSurface be created with the given color type.

        To check whether MSAA is supported use
        :py:meth:`maxSurfaceSampleCountForColorType`.
        """
    def compressedBackendFormat(
        self,
        compressionType: TextureCompressionType,
    ) -> GrBackendFormat:
        """
        Retrieve the :py:class:`GrBackendFormat` for a given
        :py:class:`Image.CompressionType`.

        This is guaranteed to match the backend format used by the following
        :py:meth:`createCompressedsBackendTexture` methods that take a
        CompressionType. The caller should check that the returned format is
        valid.
        """
    @typing.overload
    def createBackendTexture(
        self,
        width: int,
        height: int,
        backendFormat: GrBackendFormat,
        mipMapped: GrMipmapped,
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
        label: str = "",
    ) -> GrBackendTexture:
        """
        If possible, create an uninitialized backend texture.

        The client should ensure that the returned backend texture is valid.
        For the Vulkan backend the layout of the created VkImage will be:
             VK_IMAGE_LAYOUT_UNDEFINED.
        """
    @typing.overload
    def createBackendTexture(
        self,
        width: int,
        height: int,
        colorType: ColorType,
        mipMapped: GrMipmapped,
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
        label: str = "",
    ) -> GrBackendTexture:
        """
        If possible, create an uninitialized backend texture.

        The client should ensure that the returned backend texture is valid. If
        successful, the created backend texture will be compatible with the
        provided :py:class:`ColorType`. For the Vulkan backend the layout of the
        created VkImage will be: VK_IMAGE_LAYOUT_UNDEFINED.
        """
    @typing.overload
    def createBackendTexture(
        self,
        width: int,
        height: int,
        backendFormat: GrBackendFormat,
        color: Color4f,
        mipMapped: GrMipmapped,
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture:
        """
        If possible, create a backend texture initialized to a particular color.

        The client should ensure that the returned backend texture is valid. The
        client can pass in a finishedProc to be notified when the data has been
        uploaded by the gpu and the texture can be deleted. The client is
        required to call GrDirectContext::submit to send the upload work to the gpu.
        The finishedProc will always get called even if we failed to create the
        GrBackendTexture.
        For the Vulkan backend the layout of the created VkImage will be:
            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    @typing.overload
    def createBackendTexture(
        self,
        width: int,
        height: int,
        colorType: ColorType,
        color: Color4f,
        mipMapped: GrMipmapped,
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture:
        """
        If possible, create a backend texture initialized to a particular color.

        The client should ensure that the returned backend texture is valid.
        If successful, the created backend texture will be compatible with the
        provided :py:class:`~skia.ColorType`. For the Vulkan backend the layout
        of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    @typing.overload
    def createBackendTexture(
        self,
        srcData: list[Pixmap],
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture:
        """
        If possible, create a backend texture initialized with the provided
        pixmap data. The client should ensure that the returned backend texture
        is valid. The client can pass in a finishedProc to be notified when the
        data has been uploaded by the gpu and the texture can be deleted. The
        client is required to call GrDirectContext::submit to send the upload work to
        the gpu. The finishedProc will always get called even if we failed to
        create the GrBackendTexture. If successful, the created backend texture
        will be compatible with the provided pixmap(s). Compatible, in this
        case, means that the backend format will be the result of calling
        defaultBackendFormat on the base pixmap's colortype. The src data can be
        deleted when this call returns.

        If numLevels is 1 a non-mipMapped texture will result. If a mipMapped
        texture is desired the data for all the mipmap levels must be
        provided. In the mipmapped case all the colortypes of the provided
        pixmaps must be the same. Additionally, all the miplevels must be
        sized correctly (please see SkMipmap::ComputeLevelSize and
        ComputeLevelCount). Note: the pixmap's alphatypes and colorspaces are
        ignored. For the Vulkan backend the layout of the created VkImage will
        be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    @typing.overload
    def createBackendTexture(
        self,
        pixmap: Pixmap,
        renderable: GrRenderable,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture: ...
    @typing.overload
    def createCompressedBackendTexture(
        self,
        width: int,
        height: int,
        backendFormat: GrBackendFormat,
        color: Color4f,
        mipMapped: GrMipmapped,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture:
        """
        If possible, create a compressed backend texture initialized to a
        particular color.

        The client should ensure that the returned backend texture is valid.
        For the Vulkan backend the layout of the created VkImage will be:
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    @typing.overload
    def createCompressedBackendTexture(
        self,
        width: int,
        height: int,
        type: TextureCompressionType,
        color: Color4f,
        mipMapped: GrMipmapped,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture: ...
    @typing.overload
    def createCompressedBackendTexture(
        self,
        width: int,
        height: int,
        backendFormat: GrBackendFormat,
        data: typing_extensions.Buffer,
        mipMapped: GrMipmapped,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture: ...
    @typing.overload
    def createCompressedBackendTexture(
        self,
        width: int,
        height: int,
        type: TextureCompressionType,
        data: typing_extensions.Buffer,
        mipMapped: GrMipmapped,
        isProtected: GrProtected = ...,
    ) -> GrBackendTexture: ...
    def defaultBackendFormat(
        self,
        colorType: ColorType,
        renderable: GrRenderable = ...,
    ) -> GrBackendFormat:
        """
        Retrieve the default :py:class:`GrBackendFormat` for a given
        :py:class:`ColorType` and renderability.

        It is guaranteed that this backend format will be the one used by the
        following :py:class:`ColorType` and SurfaceCharacterization-based
        :py:meth:`createBackendTexture` methods.

        The caller should check that the returned format is valid.
        """
    def deleteBackendTexture(self, texture: GrBackendTexture) -> None: ...
    @typing.overload
    def flush(self, info: GrFlushInfo) -> GrSemaphoresSubmitted:
        """
        Call to ensure all drawing to the context has been flushed to underlying
        3D API specific objects. A call to :py:meth:`GrContext.submit` is always
        required to ensure work is actually sent to the gpu. Some specific API
        details:

        :GL: Commands are actually sent to the driver, but glFlush is never
            called. Thus some sync objects from the flush will not be valid
            until a submission occurs.

        :Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs
            corresponding command buffer or encoder objects. However, these
            objects are not sent to the gpu until a submission occurs.

        If the return is GrSemaphoresSubmitted::kYes, only initialized
        GrBackendSemaphores will be submitted to the gpu during the next submit
        call (it is possible Skia failed to create a subset of the semaphores).
        The client should not wait on these semaphores until after submit has
        been called, but must keep them alive until then. If a submit flag was
        passed in with the flush these valid semaphores can we waited on
        immediately. If this call returns GrSemaphoresSubmitted::kNo, the GPU
        backend will not submit any semaphores to be signaled on the GPU. Thus
        the client should not have the GPU wait on any of the semaphores passed
        in with the GrFlushInfo. Regardless of whether semaphores were submitted
        to the GPU or not, the client is still responsible for deleting any
        initialized semaphores.

        Regardleess of semaphore submission the context will still be flushed.
        It should be emphasized that a return value of
        GrSemaphoresSubmitted::kNo does not mean the flush did not happen. It
        simply means there were no semaphores submitted to the GPU. A caller
        should only take this as a failure if they passed in semaphores to be
        submitted.
        """
    @typing.overload
    def flush(self) -> None: ...
    def flushAndSubmit(self, sync: GrSyncCpu = ...) -> None:
        """
        Call to ensure all drawing to the context has been flushed and submitted
        to the underlying 3D API. This is equivalent to calling :py:meth:`flush`
        with a default :py:class:`GrFlushInfo` followed by :py:meth:`submit`.
        """
    def freeGpuResources(self) -> None:
        """
        Frees GPU created by the context.

        Can be called to reduce GPU memory pressure.
        """
    def getResourceCacheLimit(self) -> int:
        """
        Return the current GPU resource cache limit in bytes.
        """
    def getResourceCachePurgeableBytes(self) -> int:
        """
        Gets the number of bytes in the cache consumed by purgeable (e.g.
        unlocked) resources.
        """
    def getResourceCacheUsage(
        self,
        resourceCount: int | None = None,
        maxResourceBytes: int | None = None,
    ) -> None:
        """
        Gets the current GPU resource cache usage.

        :param int resourceCount: If non-null, returns the number of resources
            that are held in the cache.
        :param int maxResourceBytes: If non-null, returns the total number of
            bytes of video memory held in the cache.
        """
    def maxRenderTargetSize(self) -> int:
        """
        Gets the maximum supported render target size.
        """
    def maxSurfaceSampleCountForColorType(self, colorType: ColorType) -> int:
        """
        Gets the maximum supported sample count for a color type.

        1 is returned if only non-MSAA rendering is supported for the color
        type. 0 is returned if rendering to this color type is not supported at
        all.
        """
    def maxTextureSize(self) -> int:
        """
        Gets the maximum supported texture size.
        """
    def oomed(self) -> bool:
        """
        Checks if the underlying 3D API reported an out-of-memory error.

        If this returns true it is reset and will return false until another
        out-of-memory error is reported by the 3D API. If the context is
        abandoned then this will report false.

        Currently this is implemented for:

        OpenGL [ES] - Note that client calls to glGetError() may swallow
        GL_OUT_OF_MEMORY errors and therefore hide the error from Skia. Also, it
        is not advised to use this in combination with enabling
        GrContextOptions::fSkipGLErrorChecks. That option may prevent GrContext
        from ever checking the GL context for OOM.

        Vulkan - Reports true if VK_ERROR_OUT_OF_HOST_MEMORY or
        VK_ERROR_OUT_OF_DEVICE_MEMORY has occurred.
        """
    def precompileShader(self, key: Data, data: Data) -> bool: ...
    def purgeResourcesNotUsedInMs(self, msNotUsed: datetime.timedelta) -> None: ...
    @typing.overload
    def purgeUnlockedResources(
        self,
        maxBytesToPurge: int,
        preferScratchResources: bool,
    ) -> None:
        """
        Purge unlocked resources from the cache until the the provided byte
        count has been reached or we have purged all unlocked resources.

        The default policy is to purge in LRU order, but can be overridden to
        prefer purging scratch resources (in LRU order) prior to purging other
        resource types.

        :maxBytesToPurge: the desired number of bytes to be purged.
        :preferScratchResources:  If true scratch resources will be purged prior
            to other resource types.
        """
    @typing.overload
    def purgeUnlockedResources(self, opts: GrPurgeResourceOptions) -> None:
        """
        This entry point is intended for instances where an app has been
        backgrounded or suspended.

        :opts: If kScratchResourcesOnly only unlocked scratch resources will be purged prior
            enforcing the budget requirements.
        """
    def releaseResourcesAndAbandonContext(self) -> None:
        """
        This is similar to :py:meth:`abandonContext` however the underlying 3D
        context is not yet lost and the :py:class:`GrContext` will cleanup all
        allocated resources before returning.

        After returning it will assume that the underlying context may no longer
        be valid.

        The typical use case for this function is that the client is going to
        destroy the 3D context but can't guarantee that :py:class:`GrContext`
        will be destroyed first (perhaps because it may be ref'ed elsewhere by
        either the client or Skia objects).

        For Vulkan, even if the device becomes lost, the VkQueue, VkDevice, or
        VkInstance used to create the GrContext must be alive before calling
        :py:meth:`releaseResourcesAndAbandonContext`.
        """
    def resetContext(self, state: int = 4294967295) -> None:
        """
        The :py:class:`GrContext` normally assumes that no outsider is setting
        state within the underlying 3D API's context/device/whatever.

        This call informs the context that the state was modified and it should
        resend. Shouldn't be called frequently for good performance. The flag
        bits, state, is dependent on which backend is used by the context,
        either GL or D3D (possible in future).
        """
    def resetGLTextureBindings(self) -> None:
        """
        If the backend is :py:attr:`~GrBackendApi.kOpenGL`, then all texture
        unit/target combinations for which the GrContext has modified the bound
        texture will have texture id 0 bound.

        This does not flush the :py:class:`GrContext`. Calling
        :py:meth:`resetContext` does not change the set that will be bound to
        texture id 0 on the next call to :py:meth:`resetGLTextureBindings`.
        After this is called all unit/target combinations are considered to have
        unmodified bindings until the :py:class:`GrContext` subsequently
        modifies them (meaning if this is called twice in a row with no
        intervening :py:class:`GrContext` usage then the second call is a
        no-op.)
        """
    def setBackendRenderTargetState(
        self,
        target: GrBackendRenderTarget,
        mutableState: ...,
        previousState: ... = None,
    ) -> bool: ...
    def setBackendTextureState(
        self,
        texture: GrBackendTexture,
        mutableState: ...,
        previousState: ... = None,
    ) -> bool:
        """
        Updates the state of the GrBackendTexture/RenderTarget to have the
        passed in GrBackendSurfaceMutableState.

        All objects that wrap the backend surface (i.e. :py:class:`Surface` and
        :py:class:`Image`) will also be aware of this state change. This call
        does not submit the state change to the gpu, but requires the client to
        call :py:meth:`GrContext.submit` to send it to the GPU. The work for
        this call is ordered linearly with all other calls that require
        :py:meth:`GrContext.submit` to be called (e.g
        :py:meth:`~updateBackendTexture` and :py:meth:`~flush`).

        See :py:class:`GrBackendSurfaceMutableState` to see what state can be
        set via this call.

        If the backend API is Vulkan, the caller can set the
        GrBackendSurfaceMutableState's VkImageLayout to
        VK_IMAGE_LAYOUT_UNDEFINED or queueFamilyIndex to VK_QUEUE_FAMILY_IGNORED
        to tell Skia to not change those respective states.

        If previousState is not null and this returns true, then Skia will have
        filled in previousState to have the values of the state before this
        call.
        """
    def setResourceCacheLimit(self, maxResourceBytes: int) -> None:
        """
        Specify the GPU resource cache limit.

        If the cache currently exceeds this limit, it will be purged (LRU) to
        keep the cache within the limit.

        :param maxResourceBytes: The maximum number of bytes of video memory
            that can be held in the cache.
        """
    def storeVkPipelineCacheData(self) -> None: ...
    def submit(self, sync: GrSyncCpu = ...) -> bool:
        """
        Submit outstanding work to the gpu from all previously un-submitted
        flushes. The return value of the submit will indicate whether or not the
        submission to the GPU was successful.

        If the call returns true, all previously passed in semaphores in flush
        calls will have been submitted to the GPU and they can safely be waited
        on. The caller should wait on those semaphores or perform some other
        global synchronization before deleting the semaphores.

        If it returns false, then those same semaphores will not have been
        submitted and we will not try to submit them again. The caller is free
        to delete the semaphores at any time.

        If the syncCpu flag is true this function will return once the gpu has
        finished with all submitted work.
        """
    def supportsDistanceFieldText(self) -> bool: ...
    @typing.overload
    def updateBackendTexture(
        self,
        backendTexture: GrBackendTexture,
        color: Color4f,
    ) -> bool:
        """
        If possible, updates a backend texture to be filled to a particular
        color.

        The client should check the return value to see if the update was
        successful. The client can pass in a finishedProc to be notified when
        the data has been uploaded by the gpu and the texture can be deleted.
        The client is required to call :py:meth:`GrContext.submit` to send the
        upload work to the gpu. The finishedProc will always get called even if
        we failed to update the :py:class:`GrBackendTexture`. For the Vulkan
        backend after a successful update the layout of the created VkImage will
        be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    @typing.overload
    def updateBackendTexture(
        self,
        backendTexture: GrBackendTexture,
        srcData: list[Pixmap],
    ) -> bool:
        """
        If possible, updates a backend texture to be filled to a particular
        color.

        The client should check the return value to see if the update was
        successful. The client can pass in a finishedProc to be notified when
        the data has been uploaded by the gpu and the texture can be deleted.
        The client is required to call :py:meth:`GrContext.submit` to send the
        upload work to the gpu. The finishedProc will always get called even if
        we failed to update the :py:class:`GrBackendTexture`. The backend
        texture must be compatible with the provided pixmap(s). Compatible, in
        this case, means that the backend format is compatible with the base
        pixmap's colortype. The src data can be deleted when this call returns.
        If the backend texture is mip mapped, the data for all the mipmap levels
        must be provided. In the mipmapped case all the colortypes of the
        provided pixmaps must be the same. Additionally, all the miplevels must
        be sized correctly (please see SkMipmap::ComputeLevelSize and
        ComputeLevelCount). Note: the pixmap's alphatypes and colorspaces are
        ignored. For the Vulkan backend after a successful update the layout of
        the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
        """
    def wait(
        self,
        semaphores: list[GrBackendSemaphore],
        deleteSemaphoresAfterWait: bool = True,
    ) -> bool:
        """
        Inserts a list of GPU semaphores that the current GPU-backed API must
        wait on before executing any more commands on the GPU.

        Skia will take ownership of the underlying semaphores and delete them
        once they have been signaled and waited on. If this call returns false,
        then the GPU back-end will not wait on any passed in semaphores, and the
        client will still own the semaphores.
        """

class GrFlushInfo:
    """

    Struct to supply options to flush calls.

    After issuing all commands, fNumSemaphore semaphores will be signaled by the
    gpu. The client passes in an array of fNumSemaphores GrBackendSemaphores. In
    general these :py:class:`GrBackendSemaphore`'s can be either initialized or
    not. If they are initialized, the backend uses the passed in semaphore. If
    it is not initialized, a new semaphore is created and the
    :py:class:`GrBackendSemaphore` object is initialized with that semaphore.

    The client will own and be responsible for deleting the underlying
    semaphores that are stored and returned in initialized
    :py:class:`GrBackendSemaphore` objects. The :py:class:`GrBackendSemaphore`
    objects themselves can be deleted as soon as this function returns.

    If a finishedProc is provided, the finishedProc will be called when all work
    submitted to the gpu from this flush call and all previous flush calls has
    finished on the GPU. If the flush call fails due to an error and nothing
    ends up getting sent to the GPU, the finished proc is called immediately.

    If a submittedProc is provided, the submittedProc will be called when all
    work from this flush call is submitted to the GPU. If the flush call fails
    due to an error and nothing will get sent to the GPU, the submitted proc is
    called immediately. It is possibly that when work is finally submitted, that
    the submission actual fails. In this case we will not reattempt to do the
    submission. Skia notifies the client of these via the success bool passed
    into the submittedProc. The submittedProc is useful to the client to know
    when semaphores that were sent with the flush have actually been submitted
    to the GPU so that they can be waited on (or deleted if the submit fails).

    Note about GL: In GL work gets sent to the driver immediately during the
    flush call, but we don't really know when the driver sends the work to the
    GPU. Therefore, we treat the submitted proc as we do in other backends. It
    will be called when the next GrDirectContext::submit is called after the flush (or
    possibly during the flush if there is no work to be done for the flush). The
    main use case for the submittedProc is to know when semaphores have been
    sent to the GPU and even in GL it is required to call GrDirectContext::submit to
    flush them. So a client should be able to treat all backend APIs the same in
    terms of how the submitted procs are treated.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    @property
    def fNumSemaphores(self) -> int: ...
    @property
    def semaphores(self) -> typing.Any: ...
    @semaphores.setter
    def semaphores(self, arg1: list[GrBackendSemaphore]) -> None: ...

class GrGLBackendState:
    """

        A GrContext's cache of backend context state can be partially invalidated.

        These enums are specific to the GL backend and we'd add a new set for an
        alternative backend.


    Members:

      kRenderTarget_GrGLBackendState

      kTextureBinding_GrGLBackendState

      kView_GrGLBackendState

      kBlend_GrGLBackendState

      kMSAAEnable_GrGLBackendState

      kVertex_GrGLBackendState

      kStencil_GrGLBackendState

      kPixelStore_GrGLBackendState

      kProgram_GrGLBackendState

      kFixedFunction_GrGLBackendState

      kMisc_GrGLBackendState

      kALL_GrGLBackendState
    """

    __members__: typing.ClassVar[
        dict[str, GrGLBackendState]
    ]  # value = {'kRenderTarget_GrGLBackendState': <GrGLBackendState.kRenderTarget_GrGLBackendState: 1>, 'kTextureBinding_GrGLBackendState': <GrGLBackendState.kTextureBinding_GrGLBackendState: 2>, 'kView_GrGLBackendState': <GrGLBackendState.kView_GrGLBackendState: 4>, 'kBlend_GrGLBackendState': <GrGLBackendState.kBlend_GrGLBackendState: 8>, 'kMSAAEnable_GrGLBackendState': <GrGLBackendState.kMSAAEnable_GrGLBackendState: 16>, 'kVertex_GrGLBackendState': <GrGLBackendState.kVertex_GrGLBackendState: 32>, 'kStencil_GrGLBackendState': <GrGLBackendState.kStencil_GrGLBackendState: 64>, 'kPixelStore_GrGLBackendState': <GrGLBackendState.kPixelStore_GrGLBackendState: 128>, 'kProgram_GrGLBackendState': <GrGLBackendState.kProgram_GrGLBackendState: 256>, 'kFixedFunction_GrGLBackendState': <GrGLBackendState.kFixedFunction_GrGLBackendState: 512>, 'kMisc_GrGLBackendState': <GrGLBackendState.kMisc_GrGLBackendState: 1024>, 'kALL_GrGLBackendState': <GrGLBackendState.kALL_GrGLBackendState: 65535>}
    kALL_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kALL_GrGLBackendState: 65535>
    kBlend_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kBlend_GrGLBackendState: 8>
    kFixedFunction_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kFixedFunction_GrGLBackendState: 512>
    kMSAAEnable_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kMSAAEnable_GrGLBackendState: 16>
    kMisc_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kMisc_GrGLBackendState: 1024>
    kPixelStore_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kPixelStore_GrGLBackendState: 128>
    kProgram_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kProgram_GrGLBackendState: 256>
    kRenderTarget_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kRenderTarget_GrGLBackendState: 1>
    kStencil_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kStencil_GrGLBackendState: 64>
    kTextureBinding_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kTextureBinding_GrGLBackendState: 2>
    kVertex_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kVertex_GrGLBackendState: 32>
    kView_GrGLBackendState: typing.ClassVar[
        GrGLBackendState
    ]  # value = <GrGLBackendState.kView_GrGLBackendState: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrGLFormat:
    """
    Members:

      kUnknown

      kRGBA8

      kR8

      kALPHA8

      kLUMINANCE8

      kBGRA8

      kRGB565

      kRGBA16F

      kR16F

      kRGB8

      kRG8

      kRGB10_A2

      kRGBA4

      kSRGB8_ALPHA8

      kCOMPRESSED_ETC1_RGB8

      kCOMPRESSED_RGB8_ETC2

      kCOMPRESSED_RGB8_BC1

      kCOMPRESSED_RGBA8_BC1

      kR16

      kRG16

      kRGBA16

      kRG16F

      kLUMINANCE16F

      kLast
    """

    __members__: typing.ClassVar[
        dict[str, GrGLFormat]
    ]  # value = {'kUnknown': <GrGLFormat.kUnknown: 0>, 'kRGBA8': <GrGLFormat.kRGBA8: 1>, 'kR8': <GrGLFormat.kR8: 2>, 'kALPHA8': <GrGLFormat.kALPHA8: 3>, 'kLUMINANCE8': <GrGLFormat.kLUMINANCE8: 4>, 'kBGRA8': <GrGLFormat.kBGRA8: 6>, 'kRGB565': <GrGLFormat.kRGB565: 7>, 'kRGBA16F': <GrGLFormat.kRGBA16F: 8>, 'kR16F': <GrGLFormat.kR16F: 9>, 'kRGB8': <GrGLFormat.kRGB8: 10>, 'kRG8': <GrGLFormat.kRG8: 12>, 'kRGB10_A2': <GrGLFormat.kRGB10_A2: 13>, 'kRGBA4': <GrGLFormat.kRGBA4: 14>, 'kSRGB8_ALPHA8': <GrGLFormat.kSRGB8_ALPHA8: 15>, 'kCOMPRESSED_ETC1_RGB8': <GrGLFormat.kCOMPRESSED_ETC1_RGB8: 16>, 'kCOMPRESSED_RGB8_ETC2': <GrGLFormat.kCOMPRESSED_RGB8_ETC2: 17>, 'kCOMPRESSED_RGB8_BC1': <GrGLFormat.kCOMPRESSED_RGB8_BC1: 18>, 'kCOMPRESSED_RGBA8_BC1': <GrGLFormat.kCOMPRESSED_RGBA8_BC1: 19>, 'kR16': <GrGLFormat.kR16: 20>, 'kRG16': <GrGLFormat.kRG16: 21>, 'kRGBA16': <GrGLFormat.kRGBA16: 22>, 'kRG16F': <GrGLFormat.kRG16F: 23>, 'kLUMINANCE16F': <GrGLFormat.kLUMINANCE16F: 24>, 'kLast': <GrGLFormat.kLast: 27>}
    kALPHA8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kALPHA8: 3>
    kBGRA8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kBGRA8: 6>
    kCOMPRESSED_ETC1_RGB8: typing.ClassVar[
        GrGLFormat
    ]  # value = <GrGLFormat.kCOMPRESSED_ETC1_RGB8: 16>
    kCOMPRESSED_RGB8_BC1: typing.ClassVar[
        GrGLFormat
    ]  # value = <GrGLFormat.kCOMPRESSED_RGB8_BC1: 18>
    kCOMPRESSED_RGB8_ETC2: typing.ClassVar[
        GrGLFormat
    ]  # value = <GrGLFormat.kCOMPRESSED_RGB8_ETC2: 17>
    kCOMPRESSED_RGBA8_BC1: typing.ClassVar[
        GrGLFormat
    ]  # value = <GrGLFormat.kCOMPRESSED_RGBA8_BC1: 19>
    kLUMINANCE16F: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kLUMINANCE16F: 24>
    kLUMINANCE8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kLUMINANCE8: 4>
    kLast: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kLast: 27>
    kR16: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kR16: 20>
    kR16F: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kR16F: 9>
    kR8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kR8: 2>
    kRG16: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRG16: 21>
    kRG16F: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRG16F: 23>
    kRG8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRG8: 12>
    kRGB10_A2: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGB10_A2: 13>
    kRGB565: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGB565: 7>
    kRGB8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGB8: 10>
    kRGBA16: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGBA16: 22>
    kRGBA16F: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGBA16F: 8>
    kRGBA4: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGBA4: 14>
    kRGBA8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kRGBA8: 1>
    kSRGB8_ALPHA8: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kSRGB8_ALPHA8: 15>
    kUnknown: typing.ClassVar[GrGLFormat]  # value = <GrGLFormat.kUnknown: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrGLFramebufferInfo:
    __hash__: typing.ClassVar[None] = None
    fFBOID: int
    fFormat: int
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: GrGLFramebufferInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, FBOID: int, format: int = 0) -> None: ...

class GrGLInterface(RefCnt):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrGLTextureInfo:
    __hash__: typing.ClassVar[None] = None
    fFormat: int
    fID: int
    fTarget: int
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: GrGLTextureInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, target: int, id: int, format: int = 0) -> None: ...

class GrImageContext(GrContext_Base):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class GrMipmapped:
    """

        Used to say whether a texture has mip levels allocated or not.


    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, GrMipmapped]
    ]  # value = {'kNo': <GrMipmapped.kNo: 0>, 'kYes': <GrMipmapped.kYes: 1>}
    kNo: typing.ClassVar[GrMipmapped]  # value = <GrMipmapped.kNo: 0>
    kYes: typing.ClassVar[GrMipmapped]  # value = <GrMipmapped.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrMockOptions:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrMockRenderTargetInfo:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: GrMockRenderTargetInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, colorType: GrColorType, id: int) -> None: ...
    def colorType(self) -> GrColorType: ...
    def getBackendFormat(self) -> GrBackendFormat: ...

class GrMockTextureInfo:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: GrMockTextureInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        colorType: GrColorType,
        compressionType: TextureCompressionType,
        id: int,
    ) -> None: ...
    def colorType(self) -> GrColorType: ...
    def compressionType(self) -> TextureCompressionType: ...
    def getBackendFormat(self) -> GrBackendFormat: ...
    def id(self) -> int: ...

class GrProtected:
    """
    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, GrProtected]
    ]  # value = {'kNo': <GrProtected.kNo: 0>, 'kYes': <GrProtected.kYes: 1>}
    kNo: typing.ClassVar[GrProtected]  # value = <GrProtected.kNo: 0>
    kYes: typing.ClassVar[GrProtected]  # value = <GrProtected.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrPurgeResourceOptions:
    """



    Members:

      kAllResources

      kScratchResourcesOnly
    """

    __members__: typing.ClassVar[
        dict[str, GrPurgeResourceOptions]
    ]  # value = {'kAllResources': <GrPurgeResourceOptions.kAllResources: 0>, 'kScratchResourcesOnly': <GrPurgeResourceOptions.kScratchResourcesOnly: 1>}
    kAllResources: typing.ClassVar[
        GrPurgeResourceOptions
    ]  # value = <GrPurgeResourceOptions.kAllResources: 0>
    kScratchResourcesOnly: typing.ClassVar[
        GrPurgeResourceOptions
    ]  # value = <GrPurgeResourceOptions.kScratchResourcesOnly: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrRecordingContext(GrImageContext):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def abandoned(self) -> bool:
        """
        Reports whether the :py:class:`GrDirectContext` associated with this
        :py:class:`GrRecordingContext` is abandoned.

        When called on a :py:class:`GrDirectContext` it may actively check
        whether the underlying 3D API device/context has been disconnected
        before reporting the status. If so, calling this method will transition
        the :py:class:`GrDirectContext` to the abandoned state.
        """
    def colorTypeSupportedAsImage(self, arg0: ColorType) -> bool:
        """
        Can a :py:class:`Image` be created with the given color type.
        """
    def colorTypeSupportedAsSurface(self, colorType: ColorType) -> bool:
        """
        Can a :py:class:`Surface` be created with the given color type. To check
        whether MSAA is supported use
        :py:meth:`~GrRecordingContext.maxSurfaceSampleCountForColorType`.
        """
    def defaultBackendFormat(
        self,
        colorType: ColorType,
        renderable: GrRenderable = ...,
    ) -> GrBackendFormat:
        """
        Retrieve the default :py:class:`GrBackendFormat` for a given
        :py:class:`ColorType` and renderability.

        It is guaranteed that this backend format will be the one used by the
        following :py:class:`ColorType` and SurfaceCharacterization-based
        :py:meth:`createBackendTexture` methods.

        The caller should check that the returned format is valid.
        """
    def maxRenderTargetSize(self) -> int:
        """
        Gets the maximum supported render target size.
        """
    def maxSurfaceSampleCountForColorType(self, arg0: ColorType) -> int:
        """
        Gets the maximum supported sample count for a color type.

        1 is returned if only non-MSAA rendering is supported for the color
        type. 0 is returned if rendering to this color type is not supported at
        all.
        """
    def maxTextureSize(self) -> int:
        """
        Gets the maximum supported texture size.
        """

class GrRenderable:
    """
    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, GrRenderable]
    ]  # value = {'kNo': <GrRenderable.kNo: 0>, 'kYes': <GrRenderable.kYes: 1>}
    kNo: typing.ClassVar[GrRenderable]  # value = <GrRenderable.kNo: 0>
    kYes: typing.ClassVar[GrRenderable]  # value = <GrRenderable.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrSemaphoresSubmitted:
    """
    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, GrSemaphoresSubmitted]
    ]  # value = {'kNo': <GrSemaphoresSubmitted.kNo: 0>, 'kYes': <GrSemaphoresSubmitted.kYes: 1>}
    kNo: typing.ClassVar[
        GrSemaphoresSubmitted
    ]  # value = <GrSemaphoresSubmitted.kNo: 0>
    kYes: typing.ClassVar[
        GrSemaphoresSubmitted
    ]  # value = <GrSemaphoresSubmitted.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrSurfaceOrigin:
    """

        GPU :py:class:`Image` and :py:class:`Surfaces` can be stored such that
        (0, 0) in texture space may correspond to either the top-left or bottom-left
        content pixel.


    Members:

      kTopLeft_GrSurfaceOrigin

      kBottomLeft_GrSurfaceOrigin
    """

    __members__: typing.ClassVar[
        dict[str, GrSurfaceOrigin]
    ]  # value = {'kTopLeft_GrSurfaceOrigin': <GrSurfaceOrigin.kTopLeft_GrSurfaceOrigin: 0>, 'kBottomLeft_GrSurfaceOrigin': <GrSurfaceOrigin.kBottomLeft_GrSurfaceOrigin: 1>}
    kBottomLeft_GrSurfaceOrigin: typing.ClassVar[
        GrSurfaceOrigin
    ]  # value = <GrSurfaceOrigin.kBottomLeft_GrSurfaceOrigin: 1>
    kTopLeft_GrSurfaceOrigin: typing.ClassVar[
        GrSurfaceOrigin
    ]  # value = <GrSurfaceOrigin.kTopLeft_GrSurfaceOrigin: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrSyncCpu:
    """



    Members:

      kNo

      kYes
    """

    __members__: typing.ClassVar[
        dict[str, GrSyncCpu]
    ]  # value = {'kNo': <GrSyncCpu.kNo: 0>, 'kYes': <GrSyncCpu.kYes: 1>}
    kNo: typing.ClassVar[GrSyncCpu]  # value = <GrSyncCpu.kNo: 0>
    kYes: typing.ClassVar[GrSyncCpu]  # value = <GrSyncCpu.kYes: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrTextureType:
    """
    Members:

      kNone

      k2D

      kRectangle

      kExternal
    """

    __members__: typing.ClassVar[
        dict[str, GrTextureType]
    ]  # value = {'kNone': <GrTextureType.kNone: 0>, 'k2D': <GrTextureType.k2D: 1>, 'kRectangle': <GrTextureType.kRectangle: 2>, 'kExternal': <GrTextureType.kExternal: 3>}
    k2D: typing.ClassVar[GrTextureType]  # value = <GrTextureType.k2D: 1>
    kExternal: typing.ClassVar[GrTextureType]  # value = <GrTextureType.kExternal: 3>
    kNone: typing.ClassVar[GrTextureType]  # value = <GrTextureType.kNone: 0>
    kRectangle: typing.ClassVar[GrTextureType]  # value = <GrTextureType.kRectangle: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GrVkAlloc:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrVkBackendContext:
    """

    The BackendContext contains all of the base Vulkan objects needed by the
    GrVkGpu. The assumption is that the client will set these up and pass them
    to the GrVkGpu constructor. The VkDevice created must support at least one
    graphics queue, which is passed in as well. The QueueFamilyIndex must match
    the family of the given queue. It is needed for CommandPool creation, and
    any GrBackendObjects handed to us (e.g., for wrapped textures) needs to be
    created in or transitioned to that family. The refs held by members of this
    struct must be released (either by deleting the struct or manually releasing
    the refs) before the underlying vulkan device and instance are destroyed.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrVkDrawableInfo:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class GrVkImageInfo:
    """

    When wrapping a GrBackendTexture or GrBackendRendenderTarget, the
    fCurrentQueueFamily should either be VK_QUEUE_FAMILY_IGNORED,
    VK_QUEUE_FAMILY_EXTERNAL, or VK_QUEUE_FAMILY_FOREIGN_EXT. If fSharingMode is
    VK_SHARING_MODE_EXCLUSIVE then fCurrentQueueFamily can also be the graphics
    queue index passed into Skia.

    """

    fAlloc: GrVkAlloc
    fCurrentQueueFamily: int
    fLevelCount: int
    fProtected: GrProtected
    fSharingMode: VkSharingMode
    fYcbcrConversionInfo: GrVkYcbcrConversionInfo
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GrVkYcbcrConversionInfo:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class GradientShader:
    class Flags:
        """
        Members:

          kInterpolateColorsInPremul_Flag
        """

        __members__: typing.ClassVar[
            dict[str, GradientShader.Flags]
        ]  # value = {'kInterpolateColorsInPremul_Flag': <Flags.kInterpolateColorsInPremul_Flag: 1>}
        kInterpolateColorsInPremul_Flag: typing.ClassVar[
            GradientShader.Flags
        ]  # value = <Flags.kInterpolateColorsInPremul_Flag: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kInterpolateColorsInPremul_Flag: typing.ClassVar[
        GradientShader.Flags
    ]  # value = <Flags.kInterpolateColorsInPremul_Flag: 1>
    @staticmethod
    def MakeLinear(
        points: list[Point],
        colors: list[int],
        positions: typing.Any = None,
        mode: TileMode = ...,
        flags: int = 0,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Returns a shader that generates a linear gradient between the two
        specified points.

        :param List[skia.Point] points: The start and end points for the
            gradient.
        :param List[int] colors: The array of colors, to be distributed
            between the two points
        :param List[float] positions: May be empty list. array of Scalars, or
            NULL, of the relative position of each corresponding color in the
            colors array. If this is NULL, the the colors are distributed evenly
            between the start and end point. If this is not null, the values
            must begin with 0, end with 1.0, and intermediate values must be
            strictly increasing.
        :param skia.TileMode mode: The tiling mode
        :param localMatrix: Local matrix
        """
    @staticmethod
    def MakeRadial(
        center: Point,
        radius: float,
        colors: list[int],
        positions: typing.Any = None,
        mode: TileMode = ...,
        flags: int = 0,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Returns a shader that generates a radial gradient given the center and
        radius.

        :param skia.Point center:  The center of the circle for this gradient
        :param float radius:  Must be positive. The radius of the circle for
            this gradient
        :param List[int] colors:  The array of colors, to be distributed between
            the center and edge of the circle
        :param List[float] positions: May be empty list. The array of Scalars,
            or NULL, of the relative position of each corresponding color in the
            colors array. If this is NULL, the the colors are distributed evenly
            between the center and edge of the circle. If this is not null, the
            values must begin with 0, end with 1.0, and intermediate values must
            be strictly increasing.
        :param skia.TileMode mode: The tiling mode
        :param localMatrix: Local matrix
        """
    @staticmethod
    def MakeSweep(
        cx: float,
        cy: float,
        colors: list[int],
        positions: typing.Any = None,
        mode: TileMode = ...,
        startAngle: float = 0,
        endAngle: float = 360,
        flags: int = 0,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Returns a shader that generates a conical gradient given two circles, or
        returns NULL if the inputs are invalid.

        The gradient interprets the two circles according to the following HTML
        spec.
        http://dev.w3.org/html5/2dcontext/#dom-context-2d-createradialgradient
        """
    @staticmethod
    def MakeTwoPointConical(
        start: Point,
        startRadius: float,
        end: Point,
        endRadius: float,
        colors: list[int],
        positions: typing.Any = None,
        mode: TileMode = ...,
        flags: int = 0,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Returns a shader that generates a conical gradient given two circles, or
        returns NULL if the inputs are invalid.

        The gradient interprets the two circles according to the following HTML
        spec.
        http://dev.w3.org/html5/2dcontext/#dom-context-2d-createradialgradient
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class HighContrastConfig:
    """

    Configuration struct for :py:class:`HighContrastFilter`.

    Provides transformations to improve contrast for users with low vision.

    """
    class InvertStyle:
        """
        Members:

          kNoInvert

          kInvertBrightness

          kInvertLightness

          kLast
        """

        __members__: typing.ClassVar[
            dict[str, HighContrastConfig.InvertStyle]
        ]  # value = {'kNoInvert': <InvertStyle.kNoInvert: 0>, 'kInvertBrightness': <InvertStyle.kInvertBrightness: 1>, 'kInvertLightness': <InvertStyle.kInvertLightness: 2>, 'kLast': <InvertStyle.kInvertLightness: 2>}
        kInvertBrightness: typing.ClassVar[
            HighContrastConfig.InvertStyle
        ]  # value = <InvertStyle.kInvertBrightness: 1>
        kInvertLightness: typing.ClassVar[
            HighContrastConfig.InvertStyle
        ]  # value = <InvertStyle.kInvertLightness: 2>
        kLast: typing.ClassVar[
            HighContrastConfig.InvertStyle
        ]  # value = <InvertStyle.kInvertLightness: 2>
        kNoInvert: typing.ClassVar[
            HighContrastConfig.InvertStyle
        ]  # value = <InvertStyle.kNoInvert: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kInvertBrightness: typing.ClassVar[
        HighContrastConfig.InvertStyle
    ]  # value = <InvertStyle.kInvertBrightness: 1>
    kInvertLightness: typing.ClassVar[
        HighContrastConfig.InvertStyle
    ]  # value = <InvertStyle.kInvertLightness: 2>
    kLast: typing.ClassVar[
        HighContrastConfig.InvertStyle
    ]  # value = <InvertStyle.kInvertLightness: 2>
    kNoInvert: typing.ClassVar[
        HighContrastConfig.InvertStyle
    ]  # value = <InvertStyle.kNoInvert: 0>
    fContrast: float
    fGrayscale: bool
    fInvertStyle: HighContrastConfig.InvertStyle
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        grayscale: bool,
        invertStyle: HighContrastConfig.InvertStyle,
        contrast: float,
    ) -> None: ...
    def isValid(self) -> bool: ...

class HighContrastFilter:
    """

    Color filter that provides transformations to improve contrast for users
    with low vision.

    Applies the following transformations in this order. Each of these can be
    configured using :py:class:`HighContrastConfig`.

     - Conversion to grayscale
     - Color inversion (either in RGB or HSL space)
     - Increasing the resulting contrast.

    Calling :py:meth:`HighContrastFilter.Make` will return nullptr if the config
    is not valid, e.g. if you try to call it with a contrast outside the range
    of -1.0 to 1.0.

    """
    @staticmethod
    def Make(config: HighContrastConfig) -> ColorFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class IPoint:
    """

    :py:class:`IPoint` holds two 32-bit integer coordinates.

    Example::

        point = skia.IPoint(0, 0)
        point = skia.IPoint((0, 0))  # Convert from tuple
        print(point.fX, point.fY)
        point + (1, 1)  # Add offset
        point - (0, 0)  # Subtract offset
        x, y = tuple(point)  # Convert to tuple

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Make(x: int, y: int) -> IPoint:
        """
        Sets fX to x, fY to y.

        :param x: integer x-axis value of constructed :py:class:`IPoint`
        :param y: integer y-axis value of constructed :py:class:`IPoint`
        :return: :py:class:`IPoint` (x, y)
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __add__(self, other: IPoint) -> IPoint:
        """
        Returns :py:class:`IPoint` resulting from :py:class:`IPoint` self offset
        by ivector other, computed as: (self.fX + other.fX, self.fY + other.fY).

        Can also be used to offset :py:class:`IPoint` other by ivector self,
        returning :py:class:`IPoint`. Can also be used to add ivector to
        ivector, returning ivector.

        :param other: :py:class:`IPoint` or ivector to add
        :return: :py:class:`IPoint` equal to self offset by other
        """
    def __eq__(self, other: IPoint) -> bool:
        """
        Returns true if a is equivalent to b.

        :param other: :py:class:`IPoint` to compare
        :return: true if self.fX == other.fX and self.fY == other.fY
        """
    def __iadd__(self, v: IPoint) -> IPoint:
        """
        Offsets :py:class:`IPoint` by ivector v.

        Sets :py:class:`IPoint` to ``(fX + v.fX, fY + v.fY)``.
        """
    @typing.overload
    def __init__(self, x: int, y: int) -> None:
        """
        Sets fX to x, fY to y.

        :x: integer x-axis value of constructed :py:class:`IPoint`
        :y: integer y-axis value of constructed :py:class:`IPoint`
        """
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __isub__(self, v: IPoint) -> IPoint:
        """
        Returns :py:class:`IPoint` changing the signs of fX and fY.
        """
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: IPoint) -> bool:
        """
        Returns true if a is not equivalent to b.

        :param other: :py:class:`IPoint` to compare
        :return: true if a.fX != b.fX or a.fY != b.fY
        """
    def __neg__(self) -> IPoint:
        """
        Returns :py:class:`IPoint` changing the signs of fX and fY.
        """
    def __sub__(self, other: IPoint) -> IPoint:
        """
        Returns ivector from other to self; computed as (self.fX - other.fX,
        self.fY - other.fY).

        Can also be used to subtract ivector from ivector, returning ivector.

        :param other: ivector to subtract
        :return: ivector from other to self
        """
    def equals(self, x: int, y: int) -> bool:
        """
        Returns true if :py:class:`IPoint` is equivalent to :py:class:`IPoint`
        constructed from (x, y).

        :param x: value compared with fX
        :param y: value compared with fY
        """
    def isZero(self) -> bool:
        """
        Returns true if fX and fY are both zero.
        """
    def set(self, x: int, y: int) -> None:
        """
        Sets fX to x and fY to y.
        """
    def x(self) -> int:
        """
        Returns x-axis value of :py:class:`IPoint`.
        """
    def y(self) -> int:
        """
        Returns y-axis value of :py:class:`IPoint`.
        """
    @property
    def fX(self) -> int:
        """
        x-axis value
        """
    @fX.setter
    def fX(self, arg0: int) -> None: ...
    @property
    def fY(self) -> int:
        """
        y-axis value
        """
    @fY.setter
    def fY(self, arg0: int) -> None: ...

class IRect:
    """

    :py:class:`IRect` holds four 32-bit integer coordinates describing the upper
    and lower bounds of a rectangle.

    :py:class:`IRect` may be created from outer bounds or from position, width,
    and height. :py:class:`IRect` describes an area; if its right is less than
    or equal to its left, or if its bottom is less than or equal to its top, it
    is considered empty.

    Example::

        irect = skia.IRect(0, 0, 180, 120)
        irect = skia.IRect((0, 0, 180, 120))  # Convert from tuple
        print(irect.width(), irect.height())
        left, top, right, bottom = tuple(irect)  # Convert to tuple


    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Intersects(a: IRect, b: IRect) -> bool:
        """
        Returns true if a intersects b.

        Returns false if either a or b is empty, or do not intersect.

        :param a: :py:class:`IRect` to intersect
        :param b: :py:class:`IRect` to intersect
        :return: true if a and b have area in common
        """
    @staticmethod
    def MakeEmpty() -> IRect:
        """
        Returns constructed :py:class:`IRect` set to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.

        :return: bounds (0, 0, 0, 0)
        """
    @staticmethod
    def MakeLTRB(l: int, t: int, r: int, b: int) -> IRect:
        """
        Returns constructed :py:class:`IRect` set to (l, t, r, b).

        Does not sort input; :py:class:`IRect` may result in fLeft greater than
        fRight, or fTop greater than fBottom.

        :param l: integer stored in fLeft
        :param t: integer stored in fTop
        :param r: integer stored in fRight
        :param b: integer stored in fBottom
        :return: bounds (l, t, r, b)
        """
    @staticmethod
    def MakeSize(size: ISize) -> IRect:
        """
        Returns constructed :py:class:`IRect` set to (0, 0, size.width(),
        size.height()).

        Does not validate input; size.width() or size.height() may be negative.

        :param size: values for :py:class:`IRect` width and height
        :return: bounds (0, 0, size.width(), size.height())
        """
    @staticmethod
    def MakeWH(w: int, h: int) -> IRect:
        """
        Returns constructed :py:class:`IRect` set to (0, 0, w, h).

        Does not validate input; w or h may be negative.

        :param w: width of constructed :py:class:`IRect`
        :param h: height of constructed :py:class:`IRect`
        :return: bounds (0, 0, w, h)
        """
    @staticmethod
    def MakeXYWH(x: int, y: int, w: int, h: int) -> IRect:
        """
        Returns constructed :py:class:`IRect` set to: (x, y, x + w, y + h).

        Does not validate input; w or h may be negative.

        :param x: stored in fLeft
        :param y: stored in fTop
        :param w: added to x and stored in fRight
        :param h: added to y and stored in fBottom
        :return: bounds at (x, y) with width w and height h
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __contains__(self, arg0: IPoint) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: IRect) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: Rect) -> bool: ...
    def __eq__(self, other: IRect) -> bool:
        """
        Returns true if all members in self: fLeft, fTop, fRight, and fBottom;
        are identical to corresponding members in other.

        :param other: :py:class:`IRect` to compare
        :return: true if members are equal
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Creates :py:class:`IRect` set to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.

        :return: bounds (0, 0, 0, 0)
        """
    @typing.overload
    def __init__(self, w: int, h: int) -> None:
        """
        Returns constructed :py:class:`IRect` set to (0, 0, w, h).

        Does not validate input; w or h may be negative.

        :w: width of constructed :py:class:`IRect`
        :h: height of constructed :py:class:`IRect`
        :return: bounds (0, 0, w, h)
        """
    @typing.overload
    def __init__(self, l: int, t: int, r: int, b: int) -> None:
        """
        Creates :py:class:`IRect` set to: (x, y, x + w, y + h).

        Does not validate input; w or h may be negative.

        :l: integer stored in fLeft
        :t: integer stored in fTop
        :r: integer stored in fRight
        :b: integer stored in fBottom
        :return: bounds (l, t, r, b)
        """
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: IRect) -> bool:
        """
        Returns true if any member in self: fLeft, fTop, fRight, and fBottom; is
        not identical to the corresponding member in other.

        :param other: :py:class:`IRect` to compare
        :return: true if members are not equal
        """
    def adjust(self, dL: int, dT: int, dR: int, dB: int) -> None:
        """
        Adjusts :py:class:`IRect` by adding dL to fLeft, dT to fTop, dR to
        fRight, and dB to fBottom.

        If dL is positive, narrows :py:class:`IRect` on the left. If negative,
        widens it on the left. If dT is positive, shrinks :py:class:`IRect` on
        the top. If negative, lengthens it on the top. If dR is positive,
        narrows :py:class:`IRect` on the right. If negative, widens it on the
        right. If dB is positive, shrinks :py:class:`IRect` on the bottom. If
        negative, lengthens it on the bottom.

        The resulting :py:class:`IRect` is not checked for validity. Thus, if
        the resulting :py:class:`IRect` left is greater than right, the
        :py:class:`IRect` will be considered empty. Call :py:meth:`sort` after
        this call if that is not the desired behavior.

        :param dL:  offset added to fLeft
        :param dT:  offset added to fTop
        :param dR:  offset added to fRight
        :param dB:  offset added to fBottom
        """
    def bottom(self) -> int:
        """
        Returns bottom edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`isEmpty` to see if :py:class:`IRect` may be invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        Returns
        fBottom
        """
    @typing.overload
    def contains(self, x: int, y: int) -> bool:
        """
        Returns true if: fLeft <= x < fRight && fTop <= y < fBottom.

        Returns false if :py:class:`IRect` is empty.

        Considers input to describe constructed :py:class:`IRect`: (x, y, x + 1,
        y + 1) and returns true if constructed area is completely enclosed by
        :py:class:`IRect` area.

        :x:  test :py:class:`IPoint` x-coordinate
        :y:  test :py:class:`IPoint` y-coordinate
        :return: true if (x, y) is inside :py:class:`IRect`
        """
    @typing.overload
    def contains(self, r: IRect) -> bool:
        """
        Returns true if :py:class:`IRect` contains r.

        Returns false if :py:class:`IRect` is empty or r is empty.

        :py:class:`IRect` contains r when :py:class:`IRect` area completely
        includes r area.

        :r: :py:class:`IRect` contained
        :return: true if all sides of :py:class:`IRect` are outside r
        """
    @typing.overload
    def contains(self, r: Rect) -> bool:
        """
        Returns true if :py:class:`IRect` contains r.

        Returns false if :py:class:`IRect` is empty or r is empty.

        :py:class:`IRect` contains r when :py:class:`IRect` area completely
        includes r area.

        :r: :py:class:`Rect` contained
        :return: true if all sides of :py:class:`IRect` are outside r
        """
    def containsNoEmptyCheck(self, r: IRect) -> bool:
        """
        Returns true if :py:class:`IRect` contains construction.

        Asserts if :py:class:`IRect` is empty or construction is empty, and if
        SK_DEBUG is defined.

        Return is undefined if :py:class:`IRect` is empty or construction is
        empty.

        :param r: :py:class:`IRect` contained
        :return: true if all sides of :py:class:`IRect` are outside r
        """
    def height(self) -> int:
        """
        Returns span on the y-axis.

        This does not check if :py:class:`IRect` is sorted, or if result fits in
        32-bit signed integer; result may be negative.

        :return: fBottom minus fTop
        """
    def height64(self) -> int:
        """
        Returns span on the y-axis.

        This does not check if :py:class:`IRect` is sorted, so the result may be
        negative. This is safer than calling :py:meth:`height` since
        :py:meth:`height` might overflow in its calculation.

        :return: fBottom minus fTop cast to int64_t
        """
    def inset(self, dx: int, dy: int) -> None:
        """
        Insets :py:class:`IRect` by (dx,dy).

        If dx is positive, makes :py:class:`IRect` narrower. If dx is negative,
        makes :py:class:`IRect` wider. If dy is positive, makes
        :py:class:`IRect` shorter. If dy is negative, makes :py:class:`IRect`
        taller.

        :param dx:  offset added to fLeft and subtracted from fRight
        :param dy:  offset added to fTop and subtracted from fBottom
        """
    @typing.overload
    def intersect(self, r: IRect) -> bool:
        """
        Returns true if :py:class:`IRect` intersects r, and sets
        :py:class:`IRect` to intersection.

        Returns false if :py:class:`IRect` does not intersect r, and leaves
        :py:class:`IRect` unchanged.

        Returns false if either r or :py:class:`IRect` is empty, leaving
        :py:class:`IRect` unchanged.

        :r: limit of result
        :return: true if r and :py:class:`IRect` have area in common
        """
    @typing.overload
    def intersect(self, a: IRect, b: IRect) -> bool:
        """
        Returns true if a intersects b, and sets :py:class:`IRect` to
        intersection.

        Returns false if a does not intersect b, and leaves :py:class:`IRect`
        unchanged.

        Returns false if either a or b is empty, leaving :py:class:`IRect`
        unchanged.

        :a: :py:class:`IRect` to intersect
        :b: :py:class:`IRect` to intersect
        :return: true if a and b have area in common
        """
    def isEmpty(self) -> bool:
        """
        Returns true if :py:meth:`width` or :py:meth:`height` are zero or
        negative.

        :return: true if :py:meth:`width` or :py:meth:`height` are zero or
            negative
        """
    def isEmpty64(self) -> bool:
        """
        Returns true if fLeft is equal to or greater than fRight, or if fTop is
        equal to or greater than fBottom.

        Call :py:meth:`sort` to reverse rectangles with negative
        :py:meth:`width64` or :py:meth:`height64`.

        :return: true if :py:meth:`width64` or :py:meth:`height64` are zero or
            negative
        """
    def join(self, r: IRect) -> None:
        """
        Sets :py:class:`IRect` to the union of itself and r.

        Has no effect if r is empty. Otherwise, if :py:class:`IRect` is empty,
        sets :py:class:`IRect` to r.

        :param r: expansion :py:class:`IRect`
        """
    def left(self) -> int:
        """
        Returns left edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`sort` to reverse fLeft and fRight if needed.

        :return: fLeft
        """
    def makeInset(self, dx: int, dy: int) -> IRect:
        """
        Returns :py:class:`IRect`, inset by (dx, dy).

        If dx is negative, :py:class:`IRect` returned is wider. If dx is
        positive, :py:class:`IRect` returned is narrower. If dy is negative,
        :py:class:`IRect` returned is taller. If dy is positive,
        :py:class:`IRect` returned is shorter.

        :param dx:  offset added to fLeft and subtracted from fRight
        :param dy:  offset added to fTop and subtracted from fBottom
        :return: :py:class:`IRect` inset symmetrically left and right, top and
            bottom
        """
    @typing.overload
    def makeOffset(self, dx: int, dy: int) -> IRect:
        """
        Returns :py:class:`IRect` offset by (dx, dy).

        If dx is negative, :py:class:`IRect` returned is moved to the left. If
        dx is positive, :py:class:`IRect` returned is moved to the right. If dy
        is negative, :py:class:`IRect` returned is moved upward. If dy is
        positive, :py:class:`IRect` returned is moved downward.

        :dx:  offset added to fLeft and fRight
        :dy:  offset added to fTop and fBottom
        :return: :py:class:`IRect` offset by dx and dy, with original width and
            height
        """
    @typing.overload
    def makeOffset(self, offset: IPoint) -> IRect:
        """
        Returns :py:class:`IRect` offset by (offset.x(), offset.y()).

        If offset.x() is negative, :py:class:`IRect` returned is moved to the
        left. If offset.x() is positive, :py:class:`IRect` returned is moved to
        the right. If offset.y() is negative, :py:class:`IRect` returned is
        moved upward. If offset.y() is positive, :py:class:`IRect` returned is
        moved downward.

        :offset:  translation vector
        :return: :py:class:`IRect` translated by offset, with original width and
            height
        """
    def makeOutset(self, dx: int, dy: int) -> IRect:
        """
        Returns :py:class:`IRect`, outset by (dx, dy).

        If dx is negative, :py:class:`IRect` returned is narrower. If dx is
        positive, :py:class:`IRect` returned is wider. If dy is negative,
        :py:class:`IRect` returned is shorter. If dy is positive,
        :py:class:`IRect` returned is taller.

        :param dx: offset subtracted to fLeft and added from fRight
        :param dy: offset subtracted to fTop and added from fBottom
        :return: :py:class:`IRect` outset symmetrically left and right, top and
            bottom
        """
    def makeSorted(self) -> IRect:
        """
        Returns :py:class:`IRect` with fLeft and fRight swapped if fLeft is
        greater than fRight; and with fTop and fBottom swapped if fTop is
        greater than fBottom.

        Result may be empty; and :py:meth:`width` and :py:meth:`height` will be
        zero or positive.

        :return: sorted :py:class:`IRect`
        """
    @typing.overload
    def offset(self, dx: int, dy: int) -> None:
        """
        Offsets :py:class:`IRect` by adding dx to fLeft, fRight; and by adding
        dy to fTop, fBottom.

        If dx is negative, moves :py:class:`IRect` returned to the left. If dx
        is positive, moves :py:class:`IRect` returned to the right. If dy is
        negative, moves :py:class:`IRect` returned upward. If dy is positive,
        moves :py:class:`IRect` returned downward.

        :dx:  offset added to fLeft and fRight
        :dy:  offset added to fTop and fBottom
        """
    @typing.overload
    def offset(self, delta: IPoint) -> None:
        """
        Offsets :py:class:`IRect` by adding delta.fX to fLeft, fRight; and by
        adding delta.fY to fTop, fBottom.

        If delta.fX is negative, moves :py:class:`IRect` returned to the left.
        If delta.fX is positive, moves :py:class:`IRect` returned to the right.
        If delta.fY is negative, moves :py:class:`IRect` returned upward. If
        delta.fY is positive, moves :py:class:`IRect` returned downward.

        :delta:  offset added to :py:class:`IRect`
        """
    def offsetTo(self, newX: int, newY: int) -> None:
        """
        Offsets :py:class:`IRect` so that fLeft equals newX, and fTop equals
        newY.

        width and height are unchanged.

        :param newX:  stored in fLeft, preserving :py:meth:`width`
        :param newY:  stored in fTop, preserving :py:meth:`height`
        """
    def outset(self, dx: int, dy: int) -> None:
        """
        Outsets :py:class:`IRect` by (dx, dy).

        If dx is positive, makes :py:class:`IRect` wider. If dx is negative,
        makes :py:class:`IRect` narrower. If dy is positive, makes
        :py:class:`IRect` taller. If dy is negative, makes :py:class:`IRect`
        shorter.

        :param dx:  subtracted to fLeft and added from fRight
        :param dy:  subtracted to fTop and added from fBottom
        """
    def right(self) -> int:
        """
        Returns right edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`sort` to reverse fLeft and fRight if needed.

        :return: fRight
        """
    def setEmpty(self) -> None:
        """
        Sets :py:class:`IRect` to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.
        """
    def setLTRB(self, left: int, top: int, right: int, bottom: int) -> None:
        """
        Sets :py:class:`IRect` to (left, top, right, bottom).

        left and right are not sorted; left is not necessarily less than right.
        top and bottom are not sorted; top is not necessarily less than bottom.

        :param left:   stored in fLeft
        :param top:    stored in fTop
        :param right:  stored in fRight
        :param bottom: stored in fBottom
        """
    def setWH(self, width: int, height: int) -> None: ...
    def setXYWH(self, x: int, y: int, width: int, height: int) -> None:
        """
        Sets :py:class:`IRect` to: (x, y, x + width, y + height).

        Does not validate input; width or height may be negative.

        :param x:  stored in fLeft
        :param y:  stored in fTop
        :param width:   added to x and stored in fRight
        :param height:  added to y and stored in fBottom
        """
    def size(self) -> ISize:
        """
        Returns spans on the x-axis and y-axis.
        """
    def sort(self) -> None:
        """
        Swaps fLeft and fRight if fLeft is greater than fRight; and swaps fTop
        and fBottom if fTop is greater than fBottom.

        Result may be empty, and :py:meth:`width` and :py:meth:`height` will be
        zero or positive.
        """
    def top(self) -> int:
        """
        Returns top edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`isEmpty` to see if :py:class:`IRect` may be invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        :return: fTop
        """
    def topLeft(self) -> IPoint: ...
    def width(self) -> int:
        """
        Returns span on the x-axis.

        This does not check if :py:class:`IRect` is sorted, or if result fits in
        32-bit signed integer; result may be negative.

        :return: fRight minus fLeft
        """
    def width64(self) -> int:
        """
        Returns span on the x-axis.

        This does not check if :py:class:`IRect` is sorted, so the result may be
        negative. This is safer than calling :py:meth:`width` since
        :py:meth:`width` might overflow in its calculation.

        :return: fRight minus fLeft cast to int64_t
        """
    def x(self) -> int:
        """
        Returns left edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`isEmpty` to see if :py:class:`IRect` is valid, and
        :py:meth:`sort` to reverse fLeft and fRight if needed.

        :return: fLeft
        """
    def y(self) -> int:
        """
        Returns top edge of :py:class:`IRect`, if sorted.

        Call :py:meth:`isEmpty` to see if :py:class:`IRect` is invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        :return: fTop
        """
    @property
    def fBottom(self) -> int:
        """
        larger y-axis bounds
        """
    @fBottom.setter
    def fBottom(self, arg0: int) -> None: ...
    @property
    def fLeft(self) -> int:
        """
        smaller x-axis bounds
        """
    @fLeft.setter
    def fLeft(self, arg0: int) -> None: ...
    @property
    def fRight(self) -> int:
        """
        larger x-axis bounds
        """
    @fRight.setter
    def fRight(self, arg0: int) -> None: ...
    @property
    def fTop(self) -> int:
        """
        smaller y-axis bounds
        """
    @fTop.setter
    def fTop(self, arg0: int) -> None: ...

class ISize:
    __hash__: typing.ClassVar[None] = None
    fHeight: int
    fWidth: int
    @staticmethod
    def Make(width: int, height: int) -> ISize: ...
    @staticmethod
    def MakeEmpty() -> ISize: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: ISize) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int) -> None: ...
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: ISize) -> bool: ...
    def area(self) -> int: ...
    def equals(self, width: int, height: int) -> bool: ...
    def height(self) -> int: ...
    def isEmpty(self) -> bool:
        """
        Returns true if either width or height are <= 0.
        """
    def isZero(self) -> bool:
        """
        Returns true iff fWidth == 0 && fHeight == 0.
        """
    def set(self, width: int, height: int) -> None: ...
    def setEmpty(self) -> None:
        """
        Set the width and height to 0.
        """
    def width(self) -> int: ...

class Image(RefCnt):
    """

    :py:class:`Image` describes a two dimensional array of pixels to draw.

    The pixels may be decoded in a raster bitmap, encoded in a
    :py:class:`Picture` or compressed data stream, or located in GPU memory as a
    GPU texture.

    :py:class:`Image` cannot be modified after it is created. :py:class:`Image`
    may allocate additional storage as needed; for instance, an encoded
    :py:class:`Image` may decode when drawn.

    :py:class:`Image` width and height are greater than zero. Creating an
    :py:class:`Image` with zero width or height returns :py:class:`Image` equal
    to nullptr.

    :py:class:`Image` may be created from :py:class:`Bitmap`,
    :py:class:`Pixmap`, :py:class:`Surface`, :py:class:`Picture`, encoded
    streams, GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded
    streams supported include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP.
    Supported encoding details vary with platform.

    ``skia-python`` supports a few high-level methods in addition to C++ API::

        image = skia.Image.open("/path/to/image.png")
        image = image.resize(120, 120)
        image = image.convert(alphaType=skia.kUnpremul_AlphaType)
        image.save("/path/to/output.jpg", skia.kJPEG)

    NumPy arrays can be directly imported or exported::

        image = skia.Image.fromarray(array)
        array = image.toarray()

    General pixel buffers can be exchanged in the following approach::

        image = skia.Image.frombytes(pixels, (100, 100))
        pixels = image.tobytes()


    """
    class BitDepth:
        """
        Members:

          kU8

          kF16
        """

        __members__: typing.ClassVar[
            dict[str, Image.BitDepth]
        ]  # value = {'kU8': <BitDepth.kU8: 0>, 'kF16': <BitDepth.kF16: 1>}
        kF16: typing.ClassVar[Image.BitDepth]  # value = <BitDepth.kF16: 1>
        kU8: typing.ClassVar[Image.BitDepth]  # value = <BitDepth.kU8: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class CachingHint:
        """
        Members:

          kAllow_CachingHint

          kDisallow_CachingHint
        """

        __members__: typing.ClassVar[
            dict[str, Image.CachingHint]
        ]  # value = {'kAllow_CachingHint': <CachingHint.kAllow_CachingHint: 0>, 'kDisallow_CachingHint': <CachingHint.kDisallow_CachingHint: 1>}
        kAllow_CachingHint: typing.ClassVar[
            Image.CachingHint
        ]  # value = <CachingHint.kAllow_CachingHint: 0>
        kDisallow_CachingHint: typing.ClassVar[
            Image.CachingHint
        ]  # value = <CachingHint.kDisallow_CachingHint: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class CompressionType:
        """
        Members:

          kNone

          kETC2_RGB8_UNORM

          kBC1_RGB8_UNORM

          kBC1_RGBA8_UNORM

          kLast
        """

        __members__: typing.ClassVar[
            dict[str, Image.CompressionType]
        ]  # value = {'kNone': <CompressionType.kNone: 0>, 'kETC2_RGB8_UNORM': <CompressionType.kETC2_RGB8_UNORM: 1>, 'kBC1_RGB8_UNORM': <CompressionType.kBC1_RGB8_UNORM: 2>, 'kBC1_RGBA8_UNORM': <CompressionType.kBC1_RGBA8_UNORM: 3>, 'kLast': <CompressionType.kBC1_RGBA8_UNORM: 3>}
        kBC1_RGB8_UNORM: typing.ClassVar[
            Image.CompressionType
        ]  # value = <CompressionType.kBC1_RGB8_UNORM: 2>
        kBC1_RGBA8_UNORM: typing.ClassVar[
            Image.CompressionType
        ]  # value = <CompressionType.kBC1_RGBA8_UNORM: 3>
        kETC2_RGB8_UNORM: typing.ClassVar[
            Image.CompressionType
        ]  # value = <CompressionType.kETC2_RGB8_UNORM: 1>
        kLast: typing.ClassVar[
            Image.CompressionType
        ]  # value = <CompressionType.kBC1_RGBA8_UNORM: 3>
        kNone: typing.ClassVar[
            Image.CompressionType
        ]  # value = <CompressionType.kNone: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class LegacyBitmapMode:
        """
        Members:

          kRO_LegacyBitmapMode :
                returned bitmap is read-only and immutable

        """

        __members__: typing.ClassVar[
            dict[str, Image.LegacyBitmapMode]
        ]  # value = {'kRO_LegacyBitmapMode': <LegacyBitmapMode.kRO_LegacyBitmapMode: 0>}
        kRO_LegacyBitmapMode: typing.ClassVar[
            Image.LegacyBitmapMode
        ]  # value = <LegacyBitmapMode.kRO_LegacyBitmapMode: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kAllow_CachingHint: typing.ClassVar[
        Image.CachingHint
    ]  # value = <CachingHint.kAllow_CachingHint: 0>
    kBC1_RGB8_UNORM: typing.ClassVar[
        Image.CompressionType
    ]  # value = <CompressionType.kBC1_RGB8_UNORM: 2>
    kBC1_RGBA8_UNORM: typing.ClassVar[
        Image.CompressionType
    ]  # value = <CompressionType.kBC1_RGBA8_UNORM: 3>
    kDisallow_CachingHint: typing.ClassVar[
        Image.CachingHint
    ]  # value = <CachingHint.kDisallow_CachingHint: 1>
    kETC2_RGB8_UNORM: typing.ClassVar[
        Image.CompressionType
    ]  # value = <CompressionType.kETC2_RGB8_UNORM: 1>
    kF16: typing.ClassVar[Image.BitDepth]  # value = <BitDepth.kF16: 1>
    kLast: typing.ClassVar[
        Image.CompressionType
    ]  # value = <CompressionType.kBC1_RGBA8_UNORM: 3>
    kNone: typing.ClassVar[Image.CompressionType]  # value = <CompressionType.kNone: 0>
    kRO_LegacyBitmapMode: typing.ClassVar[
        Image.LegacyBitmapMode
    ]  # value = <LegacyBitmapMode.kRO_LegacyBitmapMode: 0>
    kU8: typing.ClassVar[Image.BitDepth]  # value = <BitDepth.kU8: 0>
    @staticmethod
    def MakeBackendTextureFromImage(
        context: GrDirectContext,
        image: Image,
        backendTexture: GrBackendTexture,
    ) -> bool:
        """
        Creates a :py:class:`GrBackendTexture` from the provided
        :py:class:`Image`.

        Returns true and stores result in backendTexture if texture is created;
        otherwise, returns false and leaves backendTexture unmodified.

        If :py:class:`Image` is both texture backed and singly referenced, image
        is returned in backendTexture without conversion or making a copy.
        :py:class:`Image` is singly referenced if it was transferred solely
        using std::move().

        If :py:class:`Image` is not texture backed, returns texture with
        :py:class:`Image` contents.

        :param skia.GrContext context: GPU context
        :param skia.Image image:   :py:class:`Image` used for texture
        :param skia.GrBackendTexture backendTexture:  storage for back-end
            texture
        :return: true if back-end texture was created
        """
    @staticmethod
    def MakeCrossContextFromPixmap(
        context: GrDirectContext,
        pixmap: Pixmap,
        buildMips: bool,
        limitToMaxTextureSize: bool = False,
    ) -> Image:
        """
        Creates :py:class:`Image` from pixmap.

        :py:class:`Image` is uploaded to GPU back-end using context.

        Created :py:class:`Image` is available to other GPU contexts, and is
        available across thread boundaries. All contexts must be in the same GPU
        share group, or otherwise share resources.

        When :py:class:`Image` is no longer referenced, context releases texture
        memory asynchronously.

        :py:class:`GrBackendTexture` created from pixmap is uploaded to match
        :py:class:`Surface` created with dstColorSpace. :py:class:`ColorSpace`
        of :py:class:`Image` is determined by pixmap.colorSpace().

        :py:class:`Image` is returned referring to GPU back-end if context is
        not nullptr, format of data is recognized and supported, and if context
        supports moving resources between contexts. Otherwise, pixmap pixel data
        is copied and :py:class:`Image` as returned in raster format if
        possible; nullptr may be returned. Recognized GPU formats vary by
        platform and GPU back-end.

        :param skia.GrDirectContext context: GPU context
        :param skia.Pixmap pixmap: :py:class:`ImageInfo`, pixel address, and row
            bytes
        :param bool buildMips: create :py:class:`Image` as mip map if true
        :param bool limitToMaxTextureSize: downscale image to GPU maximum
            texture size, if necessary
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromAdoptedTexture(
        context: GrRecordingContext,
        backendTexture: GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: ColorType,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` from backendTexture associated with context.

        backendTexture and returned :py:class:`Image` are managed internally,
        and are released when no longer needed.

        :py:class:`Image` is returned if format of backendTexture is recognized
        and supported. Recognized formats vary by GPU back-end.

        :param skia.GrContext context: GPU context
        :param skia.GrBackendTexture backendTexture: texture residing on GPU
        :param skia.ColorSpace colorSpace: range of colors; may be nullptr
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromBitmap(bitmap: Bitmap) -> Image:
        """
        Creates :py:class:`Image` from bitmap, sharing or copying bitmap pixels.

        If the bitmap is marked immutable, and its pixel memory is shareable, it
        may be shared instead of copied.

        :py:class:`Image` is returned if bitmap is valid. Valid
        :py:class:`Bitmap` parameters include: dimensions are greater than zero;
        each dimension fits in 29 bits; :py:class:`ColorType` and
        :py:class:`AlphaType` are valid, and :py:class:`ColorType` is not
        :py:attr:`kUnknown_ColorType`; row bytes are large enough to hold one
        row of pixels; pixel address is not nullptr.

        :param skia.Bitmap bitmap: :py:class:`ImageInfo`, row bytes, and pixels
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromCompressedTexture(
        context: GrRecordingContext,
        texture: GrBackendTexture,
        origin: GrSurfaceOrigin,
        alphaType: AlphaType,
        colorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates an :py:class:`Image` from a GPU backend texture.

        An :py:class:`Image` is returned if the format of backendTexture is
        recognized and supported. Recognized formats vary by GPU back-end.

        :param skia.GrRecordingContext context: the GPU context
        :param skia.GrBackendTexture backendTexture: a texture already allocated
            by the GPU
        :param skia.AlphaType alphaType: This characterizes the nature of the
            alpha values in the backend texture. For opaque compressed formats
            (e.g., ETC1) this should usually be set to
            :py:attr:`~AlphaType.kOpaque_AlphaType`.
        :param skia.ColorSpace colorSpace: This describes the color space of
            this image's contents, as seen after sampling. In general, if the
            format of the backend texture is SRGB, some linear colorSpace should
            be supplied (e.g., :py:meth:`ColorSpace.MakeSRGBLinear` ). If the
            format of the backend texture is linear, then the colorSpace should
            include a description of the transfer function as well (e.g.,
            :py:meth:`ColorSpace.MakeSRGB` ).
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromEncoded(encoded: Data, alphaType: AlphaType | None = None) -> Image:
        """
        Return an image backed by the encoded data, but attempt to defer
        decoding until the image is actually used/drawn.

        This deferral allows the system to cache the result, either on the CPU
        or on the GPU, depending on where the image is drawn. If memory is low,
        the cache may be purged, causing the next draw of the image to have to
        re-decode.

        If the encoded format is not supported, nullptr is returned.

        :param encoded: the encoded data
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromPicture(
        picture: Picture,
        dimensions: ISize,
        matrix: Matrix | None = None,
        paint: Paint | None = None,
        bitDepth: Image.BitDepth = ...,
        colorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` from picture.

        Returned :py:class:`Image` width and height are set by dimensions.
        :py:class:`Image` draws picture with matrix and paint, set to bitDepth
        and colorSpace.

        If matrix is nullptr, draws with identity :py:class:`Matrix`. If paint
        is nullptr, draws with default :py:class:`Paint`. colorSpace may be
        nullptr.

        :param skia.Picture picture: stream of drawing commands
        :param skia.ISize dimensions:  width and height
        :param skia.Matrix matrix: :py:class:`Matrix` to rotate, scale,
            translate, and so on; may be nullptr
        :param skia.Paint paint: :py:class:`Paint` to apply transparency,
            filtering, and so on; may be nullptr
        :param skia.Image.BitDepth bitDepth:    8-bit integer or 16-bit float:
            per component
        :param skia.ColorSpace colorSpace:  range of colors; may be nullptr
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromRaster(pixmap: Pixmap) -> Image:
        """
        Creates :py:class:`Image` from pixmap, sharing :py:class:`Pixmap`
        pixels.

        :py:class:`Image` is returned if pixmap is valid. Valid
        :py:class:`Pixmap` parameters include: dimensions are greater than zero;
        each dimension fits in 29 bits; :py:class:`ColorType` and
        :py:class:`AlphaType` are valid, and :py:class:`ColorType` is not
        :py:attr:`kUnknown_ColorType`; row bytes are large enough to hold one
        row of pixels; pixel address is not nullptr.

        :param skia.Pixmap pixmap: :py:class:`ImageInfo`, pixel address, and row
            bytes
        :return: :py:class:`Image` sharing pixmap
        """
    @staticmethod
    def MakeFromTexture(
        context: GrRecordingContext,
        texture: GrBackendTexture,
        origin: GrSurfaceOrigin,
        colorType: ColorType,
        alphaType: AlphaType,
        colorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` from GPU texture associated with context.

        Caller is responsible for managing the lifetime of GPU texture.

        :py:class:`Image` is returned if format of backendTexture is recognized
        and supported. Recognized formats vary by GPU back-end.

        :param skia.GrRecordingContext context: GPU context
        :param skia.GrBackendTexture backendTexture: texture residing on GPU
        :param skia.ColorSpace colorSpace: range of colors; may be nullptr
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeFromYUVAPixmaps(
        context: GrRecordingContext,
        pixmaps: YUVAPixmaps,
        buildMips: GrMipmapped = ...,
        limitToMaxTextureSize: bool = False,
        imageColorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` from :py:class:`YUVAPixmaps`.

        The image will remain planar with each plane converted to a texture
        using the passed :py:class:`GrRecordingContext`.

        :py:class:`YUVAPixmaps` has a :py:class:`YUVAInfo` which specifies the
        transformation from YUV to RGB. The :py:class:`ColorSpace` of the
        resulting RGB values is specified by imageColorSpace. This will be the
        :py:class:`ColorSpace` reported by the image and when drawn the RGB
        values will be converted from this space into the destination space (if
        the destination is tagged).

        Currently, this is only supported using the GPU backend and will fail if
        context is nullptr.

        :py:class:`YUVAPixmaps` does not need to remain valid after this
        returns.

        :param context:               GPU context
        :param pixmaps:               The planes as pixmaps with supported
                                      :py:class:`YUVAInfo` that specifies
                                      conversion to RGB.
        :param buildMips:             create internal YUVA textures as mip map
                                      if kYes. This is silently ignored if the
                                      context does not support mip maps.
        :param limitToMaxTextureSize: downscale image to GPU maximum texture
                                      size, if necessary
        :param imageColorSpace:       range of colors of the resulting image;
                                      may be nullptr
        :return:                      created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeRasterCopy(pixmap: Pixmap) -> Image:
        """
        Creates :py:class:`Image` from :py:class:`Pixmap` and copy of pixels.

        Since pixels are copied, :py:class:`Pixmap` pixels may be modified or
        deleted without affecting :py:class:`Image`.

        :py:class:`Image` is returned if :py:class:`Pixmap` is valid. Valid
        :py:class:`Pixmap` parameters include: dimensions are greater than zero;
        each dimension fits in 29 bits; :py:class:`ColorType` and
        :py:class:`AlphaType` are valid, and :py:class:`ColorType` is not
        :py:attr:`~ColorType.kUnknown_ColorType`; row bytes are large enough to
        hold one row of pixels; pixel address is not nullptr.

        :param skia.Pixmap pixmap: :py:class:`ImageInfo`, pixel address, and row
            bytes
        :return: copy of :py:class:`Pixmap` pixels, or nullptr
        """
    @staticmethod
    def MakeRasterData(
        info: ImageInfo,
        pixels: typing_extensions.Buffer,
        rowBytes: int,
    ) -> Image:
        """
        Creates :py:class:`Image` from :py:class:`ImageInfo`, sharing pixels.

        :py:class:`Image` is returned if :py:class:`ImageInfo` is valid. Valid
        :py:class:`ImageInfo` parameters include: dimensions are greater than
        zero; each dimension fits in 29 bits; :py:class:`ColorType` and
        :py:class:`AlphaType` are valid, and :py:class:`ColorType` is not
        :py:attr:`~ColorType.kUnknown_ColorType`; rowBytes are large enough to
        hold one row of pixels; pixels is not nullptr, and contains enough data
        for :py:class:`Image`.

        :param skia.ImageInfo info: contains width, height,
            :py:class:`AlphaType`, :py:class:`ColorType`, :py:class:`ColorSpace`
        :param Union[bytes,bytearray,memoryview] pixels: pixel storage
        :param int rowBytes: size of pixel row or larger
        :return: :py:class:`Image` sharing pixels, or nullptr
        """
    @staticmethod
    def MakeRasterFromCompressed(
        data: Data,
        width: int,
        height: int,
        type: Image.CompressionType,
    ) -> Image:
        """
        Creates a CPU-backed :py:class:`Image` from compressed data.

        This method will decompress the compressed data and create an image
        wrapping it. Any mipmap levels present in the compressed data are
        discarded.

        :param skia.Data data: compressed data to store in SkImage
        :param int width: width of full SkImage
        :param int height: height of full SkImage
        :param skia.Image.CompressionType type: type of compression used
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def MakeTextureFromCompressed(
        context: GrDirectContext,
        data: Data,
        width: int,
        height: int,
        type: Image.CompressionType,
        mipMapped: GrMipmapped = ...,
        isProtected: GrProtected = ...,
    ) -> Image:
        """
        Creates a GPU-backed :py:class:`Image` from compressed data.

        This method will return an :py:class:`Image` representing the compressed
        data. If the GPU doesn't support the specified compression method, the
        data will be decompressed and then wrapped in a GPU-backed image.

        Note: one can query the supported compression formats via
        :py:meth:`GrContext.compressedBackendFormat`.

        :param skia.GrDirectContext context: GPU context
        :param skia.Data data: compressed data to store in :py:class:`Image`
        :param int width: width of full :py:class:`Image`
        :param int height: height of full :py:class:`Image`
        :param skia.CompressionType type: type of compression used
        :param skia.skgpu::Mipmapped mipMapped: does 'data' contain data for all the
            mipmap levels?
        :param skia.GrProtected isProtected: do the contents of 'data' require
            DRM protection (on Vulkan)?
        :return: created :py:class:`Image`, or nullptr
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @staticmethod
    def fromarray(
        array: numpy.ndarray,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
        copy: bool = True,
    ) -> Image:
        """
        Creates a new :py:class:`Image` from numpy array.

        :param numpy.ndarray array: numpy ndarray of shape=(height, width,
            channels) and appropriate dtype. Must have non-zero width and
            height, and the valid number of channels for the specified color
            type.
        :param skia.ColorType colorType: color type of the array
        :param skia.AlphaType alphaType: alpha type of the array
        :param skia.ColorSpace colorSpace: range of colors; may be nullptr
        :param bool copy: Whether to copy pixels.
        """
    @staticmethod
    def frombytes(
        array: typing_extensions.Buffer,
        dimensions: ISize,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
        copy: bool = True,
    ) -> Image:
        """
        Creates a new :py:class:`Image` from bytes.

        :param pixels: raw bytes of pixels
        :param skia.ISize dimensions: (width, height) tuple
        :param skia.ColorType colorType: color type of the array
        :param skia.AlphaType alphaType: alpha type of the array
        :param skia.ColorSpace colorSpace: range of colors; may be nullptr
        :param bool copy: Whether to copy pixels. When false is specified,
            :py:class:`Image` shares the pixel buffer without copy.
        """
    @staticmethod
    def open(fp: typing.Any) -> Image:
        """
        Creates :py:attr:`Image` from file path or file-like object.

        Shortcut for the following::

            if hasattr(fp, "read") and hasattr(fp, "seek"):
                fp.seek(0)
                data = skia.Data.MakeWithCopy(fp.read())
            else:
                data = skia.Data.MakeFromFileName(fp)
            image = skia.Image.MakeFromEncoded(data)

        :param fp: file path or file-like object that has `seek` and `read`
            method. file must be opened in binary mode.
        """
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def _repr_png_(self) -> bytes: ...
    def alphaType(self) -> AlphaType:
        """
        Returns :py:class:`AlphaType`.

        :py:class:`AlphaType` returned was a parameter to an :py:class:`Image`
        constructor, or was parsed from encoded data.

        :return: :py:class:`AlphaType` in :py:class:`Image`
        """
    def asLegacyBitmap(
        self,
        bitmap: Bitmap,
        legacyBitmapMode: Image.LegacyBitmapMode = ...,
    ) -> bool:
        """
        Deprecated.

        Creates raster :py:class:`Bitmap` with same pixels as :py:class:`Image`.
        If legacyBitmapMode is :py:attr:`~Image.kRO_LegacyBitmapMode`, returned
        bitmap is read-only and immutable. Returns true if :py:class:`Bitmap` is
        stored in bitmap. Returns false and resets bitmap if :py:class:`Bitmap`
        write did not succeed.

        :param bitmap: storage for legacy :py:class:`Bitmap`
        :param legacyBitmapMode: bitmap is read-only and immutable
        :return: true if :py:class:`Bitmap` was created
        """
    def bitmap(
        self,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> Bitmap:
        """
        Creates :py:class:`Bitmap` from :py:class:`Image`.

        Pixels are always allocated and copied.

        :param colorType: color type of :py:class:`Bitmap`. If
            :py:attr:`~skia.kUnknown_ColorType`, uses the same colorType as
            :py:class:`Image`.
        :param alphaType: alpha type of :py:class:`Bitmap`. If
            :py:attr:`~skia.kUnknown_AlphaType`, uses the same alphaType as
            :py:class:`Image`.
        :param colorSpace: color space of :py:class:`Bitmap`.
        :return: :py:class:`Bitmap`
        """
    def bounds(self) -> IRect:
        """
        Returns :py:class:`IRect` (0, 0, :py:meth:`width`, :py:meth:`height`).

        :return: integral rectangle from origin to :py:meth:`width` and
            :py:meth:`height`
        """
    def colorSpace(self) -> ColorSpace:
        """
        Returns :py:class:`ColorSpace`, the range of colors, associated with
        :py:class:`Image`.

        The reference count of :py:class:`ColorSpace` is unchanged. The returned
        :py:class:`ColorSpace` is immutable.

        :py:class:`ColorSpace` returned was passed to an :py:class:`Image`
        constructor, or was parsed from encoded data. :py:class:`ColorSpace`
        returned may be ignored when :py:class:`Image` is drawn, depending on
        the capabilities of the :py:class:`Surface` receiving the drawing.

        :return: :py:class:`ColorSpace` in :py:class:`Image`, or nullptr
        """
    def colorType(self) -> ColorType:
        """
        Returns :py:class:`ColorType` if known; otherwise, returns
        :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: :py:class:`ColorType` of :py:class:`Image`
        """
    def convert(
        self,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` in target :py:class:`ColorType`,
        :py:class:`AlphatType`, and :py:class:`ColorSpace`. Raises if
        :py:class:`Image` could not be created.

        Pixels are converted only if pixel conversion is possible. If
        :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; colorType must
        be the same. If :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, colorSpace must
        be the same. If :py:class:`Image` :py:class:`AlphaType` is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, alphaType must be the same.
        If :py:class:`Image` :py:class:`ColorSpace` is nullptr,
        colorSpace must be the same. Raises if pixel conversion is
        not possible.

        :param colorType: target color type. If
            :py:attr:`~skia.kUnknown_ColorType` is given, uses the same
            colorType as :py:class:`Image`.
        :param alphaType: target alpha type. If
            :py:attr:`~skia.kUnknown_AlphaType` is given, uses the same
            alphaType as :py:class:`Image`.
        :param colorSpace: target color space.
        :return: :py:class:`Image`
        """
    def dimensions(self) -> ISize:
        """
        Returns :py:class:`ISize` (:py:meth:`width`, :py:meth:`height`).

        :return: integral size of :py:meth:`width` and :py:meth:`height`
        """
    @typing.overload
    def encodeToData(
        self,
        encodedImageFormat: EncodedImageFormat,
        quality: int,
    ) -> Data:
        """
        Encodes :py:class:`Image` pixels, returning result as :py:class:`Data`.

        Returns nullptr if encoding fails, or if encodedImageFormat is not
        supported.

        :py:class:`Image` encoding in a format requires both building with one
        or more of: SK_ENCODE_JPEG, SK_ENCODE_PNG, SK_ENCODE_WEBP; and platform
        support for the encoded format.

        If SK_BUILD_FOR_MAC or SK_BUILD_FOR_IOS is defined, encodedImageFormat
        can additionally be one of: :py:attr:`~EncodedImageFormat.kICO`,
        :py:attr:`~EncodedImageFormat.kBMP`,
        :py:attr:`~EncodedImageFormat.kGIF`.

        quality is a platform and format specific metric trading off size and
        encoding error. When used, quality equaling 100 encodes with the least
        error. quality may be ignored by the encoder.

        :param skia.EncodedImageFormat encodedImageFormat:
            one of: :py:attr:`~EncodedImageFormat.kJPEG`,
            :py:attr:`~EncodedImageFormat.kPNG`,
            :py:attr:`~EncodedImageFormat.kWEBP`
        :param int quality: encoder specific metric with 100 equaling best
        :return: encoded :py:class:`Image`, or nullptr
        """
    @typing.overload
    def encodeToData(self) -> Data:
        """
        Encodes :py:class:`Image` pixels, returning result as :py:class:`Data`.

        Returns existing encoded data if present; otherwise, :py:class:`Image`
        is encoded with :py:attr:`~EncodedImageFormat.kPNG`. Skia must be built
        with SK_ENCODE_PNG to encode :py:class:`Image`.

        Returns nullptr if existing encoded data is missing or invalid, and
        encoding fails.

        :return: encoded :py:class:`Image`, or nullptr
        """
    @typing.overload
    def flush(self, arg0: GrDirectContext, arg1: GrFlushInfo) -> GrSemaphoresSubmitted:
        """
        Flushes any pending uses of texture-backed images in the GPU backend. If
        the image is not texture-backed (including promise texture images) or if
        the GrDirectContext does not have the same context ID as the context
        backing the image then this is a no-op.

        If the image was not used in any non-culled draws in the current queue
        of work for the passed GrDirectContext then this is a no-op unless the
        GrFlushInfo contains semaphores or a finish proc. Those are respected
        even when the image has not been used.

        :param context:  the context on which to flush pending usages of the
            image.
        :param info:     flush options
        """
    @typing.overload
    def flush(self, context: GrDirectContext) -> None: ...
    def flushAndSubmit(self, context: GrDirectContext) -> None:
        """
        Version of :py:meth:`flush` that uses a default GrFlushInfo.

        Also submits the flushed work to the GPU.
        """
    def getBackendTexture(
        self,
        flushPendingGrContextIO: bool,
        origin: GrSurfaceOrigin | None = None,
    ) -> bool:
        """
        Retrieves the back-end texture. If :py:class:`Image` has no back-end
        texture, an invalid object is returned. Call
        :py:meth:`GrBackendTexture.isValid` to determine if the result is valid.

        If flushPendingGrContextIO is true, completes deferred I/O operations.

        If origin in not nullptr, copies location of content drawn into
        :py:class:`Image`.

        :param flushPendingGrContextIO: flag to flush outstanding requests
        :return: back-end API texture handle; invalid on failure
        """
    def hasMipmaps(self) -> bool:
        """
        Returns true if the image has mipmap levels.
        """
    def height(self) -> int:
        """
        Returns pixel row count.

        :return: pixel height in :py:class:`Image`
        """
    def imageInfo(self) -> ImageInfo:
        """
        Returns a :py:class:`ImageInfo` describing the width, height, color
        type, alpha type, and color space of the :py:class:`Image`.

        :return: image info of :py:class:`Image`.
        """
    def isAlphaOnly(self) -> bool:
        """
        Returns true if :py:class:`Image` pixels represent transparency only.

        If true, each pixel is packed in 8 bits as defined by
        :py:attr:`~ColorType.kAlpha_8_ColorType`.

        :return: true if pixels represent a transparency mask
        """
    def isLazyGenerated(self) -> bool:
        """
        Returns true if :py:class:`Image` is backed by an image-generator or
        other service that creates and caches its pixels or texture on-demand.

        :return: true if :py:class:`Image` is created as needed
        """
    def isOpaque(self) -> bool:
        """
        Returns true if pixels ignore their alpha value and are treated as fully
        opaque.

        :return: true if :py:class:`AlphaType` is
            :py:attr:`~AlphaType.kOpaque_AlphaType`
        """
    def isTextureBacked(self) -> bool:
        """
        Returns true the contents of :py:class:`Image` was created on or
        uploaded to GPU memory, and is available as a GPU texture.

        :return: true if :py:class:`Image` is a GPU texture
        """
    def isValid(self, context: GrRecordingContext | None = None) -> bool:
        """
        Returns true if :py:class:`Image` can be drawn on either raster surface
        or GPU surface.

        If context is nullptr, tests if :py:class:`Image` draws on raster
        surface; otherwise, tests if :py:class:`Image` draws on GPU surface
        associated with context.

        :py:class:`Image` backed by GPU texture may become invalid if associated
        GrRecordingContext is invalid. lazy image may be invalid and may not draw
        to raster surface or GPU surface or both.

        :param skia.GrRecordingContext context: GPU context
        :return: true if :py:class:`Image` can be drawn
        """
    def makeColorSpace(
        self,
        target: ColorSpace,
        direct: GrDirectContext | None = None,
    ) -> Image:
        """
        Creates :py:class:`Image` in target :py:class:`ColorSpace`.

        Returns nullptr if :py:class:`Image` could not be created.

        Returns original :py:class:`Image` if it is in target
        :py:class:`ColorSpace`. Otherwise, converts pixels from
        :py:class:`Image` :py:class:`ColorSpace` to target
        :py:class:`ColorSpace`. If :py:class:`Image` colorSpace() returns
        nullptr, :py:class:`Image` :py:class:`ColorSpace` is assumed to be sRGB.

        :param skia.ColorSpace target: :py:class:`ColorSpace` describing color
            range of returned :py:class:`Image`
        :return: created :py:class:`Image` in target :py:class:`ColorSpace`
        """
    def makeColorTypeAndColorSpace(
        self,
        targetColorType: ColorType,
        targetColorSpace: ColorSpace | None = None,
        direct: GrDirectContext | None = None,
    ) -> Image:
        """
        Experimental.

        Creates :py:class:`Image` in target :py:class:`ColorType` and
        :py:class:`ColorSpace`. Returns nullptr if :py:class:`Image` could not
        be created.

        Returns original :py:class:`Image` if it is in target
        :py:class:`ColorType` and :py:class:`ColorSpace`.

        :param skia.ColorType targetColorType: :py:class:`ColorType` of returned
            :py:class:`Image`
        :param skia.ColorSpace targetColorSpace: :py:class:`ColorSpace` of
            returned :py:class:`Image`
        :return: created :py:class:`Image` in target :py:class:`ColorType` and
            :py:class:`ColorSpace`
        """
    def makeNonTextureImage(self, context: GrDirectContext | None = None) -> Image:
        """
        Returns raster image or lazy image.

        Copies :py:class:`Image` backed by GPU texture into CPU memory if
        needed. Returns original :py:class:`Image` if decoded in raster bitmap,
        or if encoded in a stream.

        Returns nullptr if backed by GPU texture and copy fails.

        :return: raster image, lazy image, or nullptr
        """
    def makeRasterImage(self, cachingHint: Image.CachingHint = ...) -> Image:
        """
        Returns raster image.

        Copies :py:class:`Image` backed by GPU texture into CPU memory, or
        decodes :py:class:`Image` from lazy image. Returns original
        :py:class:`Image` if decoded in raster bitmap.

        Returns nullptr if copy, decode, or pixel read fails.

        If cachingHint is :py:attr:`Image.CachingHint.kAllow_CachingHint`,
        pixels may be retained locally. If cachingHint is
        :py:attr:`Image.CachingHint.kDisallow_CachingHint`, pixels are not added
        to the local cache.

        :param skia.Image.CachingHint cachingHint: Caching hint
        :return: raster image, or nullptr
        """
    @typing.overload
    def makeRawShader(
        self,
        tmx: TileMode = ...,
        tmy: TileMode = ...,
        samplingOptions: SamplingOptions = ...,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Creates :py:class:`Shader` from :py:class:`Image`.

        makeRawShader functions like makeShader, but for images that contain non-color data.
        This includes images encoding things like normals, material properties (eg, roughness),
        heightmaps, or any other purely mathematical data that happens to be stored in an image.
        These types of images are useful with some programmable shaders (see: SkRuntimeEffect).

        :py:class:`Shader` dimensions are taken from :py:class:`Image`.
        :py:class:`Shader` uses :py:class:`TileMode` rules to fill drawn area
        outside :py:class:`Image`. localMatrix permits transforming
        :py:class:`Image` before :py:class:`Canvas` matrix is applied.

        :param skia.TileMode tmx: tiling in the x direction
        :param skia.TileMode tmy: tiling in the y direction
        :param skia.Matrix localMatrix: :py:class:`Image` transformation, or
            nullptr
        :return: :py:class:`Shader` containing :py:class:`Image`
        """
    @typing.overload
    def makeRawShader(
        self,
        samplingOptions: SamplingOptions = ...,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Creates :py:class:`Shader` from :py:class:`Image`.

        makeRawShader functions like makeShader, but for images that contain non-color data.
        This includes images encoding things like normals, material properties (eg, roughness),
        heightmaps, or any other purely mathematical data that happens to be stored in an image.
        These types of images are useful with some programmable shaders (see: SkRuntimeEffect).

        :py:class:`Shader` dimensions are taken from :py:class:`Image`.
        localMatrix permits transforming
        :py:class:`Image` before :py:class:`Canvas` matrix is applied.

        :param skia.Matrix localMatrix: :py:class:`Image` transformation, or
            nullptr
        :return: :py:class:`Shader` containing :py:class:`Image`
        """
    @typing.overload
    def makeShader(
        self,
        tmx: TileMode = ...,
        tmy: TileMode = ...,
        samplingOptions: SamplingOptions = ...,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Creates :py:class:`Shader` from :py:class:`Image`.

        :py:class:`Shader` dimensions are taken from :py:class:`Image`.
        :py:class:`Shader` uses :py:class:`TileMode` rules to fill drawn area
        outside :py:class:`Image`. localMatrix permits transforming
        :py:class:`Image` before :py:class:`Canvas` matrix is applied.

        :param skia.TileMode tmx: tiling in the x direction
        :param skia.TileMode tmy: tiling in the y direction
        :param skia.Matrix localMatrix: :py:class:`Image` transformation, or
            nullptr
        :return: :py:class:`Shader` containing :py:class:`Image`
        """
    @typing.overload
    def makeShader(
        self,
        samplingOptions: SamplingOptions = ...,
        localMatrix: Matrix | None = None,
    ) -> Shader:
        """
        Creates :py:class:`Shader` from :py:class:`Image`.

        :py:class:`Shader` dimensions are taken from :py:class:`Image`.
        localMatrix permits transforming
        :py:class:`Image` before :py:class:`Canvas` matrix is applied.

        :param skia.Matrix localMatrix: :py:class:`Image` transformation, or
            nullptr
        :return: :py:class:`Shader` containing :py:class:`Image`
        """
    def makeSubset(self, subset: IRect, direct: GrDirectContext | None = None) -> Image:
        """
        Returns subset of :py:class:`Image`.

        subset must be fully contained by :py:class:`Image`
        :py:meth:`dimensions`. The implementation may share pixels, or may copy
        them.

        Returns nullptr if subset is empty, or subset is not contained by
        bounds, or pixels in :py:class:`Image` could not be read or copied.

        :param skia.IRect subset: bounds of returned :py:class:`Image`
        :return: partial or full :py:class:`Image`, or nullptr
        """
    def makeTextureImage(
        self,
        context: GrDirectContext,
        mipMapped: GrMipmapped = ...,
        budgeted: Budgeted = ...,
    ) -> Image:
        """
        Returns :py:class:`Image` backed by GPU texture associated with context.

        Returned :py:class:`Image` is compatible with :py:class:`Surface`
        created with dstColorSpace. The returned :py:class:`Image` respects
        mipMapped setting; if mipMapped equals :py:attr:`skgpu::Mipmapped.kYes`, the
        backing texture allocates mip map levels.

        The mipMapped parameter is effectively treated as kNo if MIP maps are
        not supported by the GPU.

        Returns original :py:class:`Image` if the image is already
        texture-backed, the context matches, and mipMapped is compatible with
        the backing GPU texture. :py:class:`Budgeted` is ignored in this case.

        Returns nullptr if context is nullptr, or if :py:class:`Image` was
        created with another GrDirectContext.

        :param GrDirectContext context: the GrDirectContext in play, if it
            exists
        :param skgpu::Mipmapped mipMapped: whether created :py:class:`Image` texture
            must allocate mip map levels
        :param skia.Budgeted budgeted: whether to count a newly created texture
            for the returned image counts against the GrDirectContext's budget.
        :return: created :py:class:`Image`, or nullptr
        """
    def makeWithFilter(
        self,
        context: GrRecordingContext,
        filter: ImageFilter,
        subset: IRect,
        clipBounds: IRect,
        outSubset: IRect,
        offset: IPoint,
    ) -> Image:
        """
        Creates filtered :py:class:`Image`.

        filter processes original :py:class:`Image`, potentially changing color,
        position, and size. subset is the bounds of original :py:class:`Image`
        processed by filter. clipBounds is the expected bounds of the filtered
        :py:class:`Image`. outSubset is required storage for the actual bounds
        of the filtered :py:class:`Image`. offset is required storage for
        translation of returned :py:class:`Image`.

        Returns nullptr if :py:class:`Image` could not be created. If nullptr is
        returned, outSubset and offset are undefined.

        Useful for animation of :py:class:`ImageFilter` that varies size from
        frame to frame. Returned :py:class:`Image` is created larger than
        required by filter so that GPU texture can be reused with different
        sized effects. outSubset describes the valid bounds of GPU texture
        returned. offset translates the returned :py:class:`Image` to keep
        subsequent animation frames aligned with respect to each other.

        :param skia.GrRecordingContext context: the GrRecordingContext in play -
            if it exists
        :param skia.ImageFilter filter: how :py:class:`Image` is sampled when
            transformed
        :param skia.IRect subset:  bounds of :py:class:`Image` processed by
            filter
        :param skia.IRect clipBounds:  expected bounds of filtered
            :py:class:`Image`
        :param skia.IRect outSubset:   output for returned :py:class:`Image`
            bounds
        :param skia.IPoint offset:  output for returned :py:class:`Image`
            translation
        :return: filtered :py:class:`Image`, or nullptr
        """
    def peekPixels(self, pixmap: Pixmap) -> bool:
        """
        Copies :py:class:`Image` pixel address, row bytes, and
        :py:class:`ImageInfo` to pixmap, if address is available, and returns
        true.

        If pixel address is not available, return false and leave pixmap
        unchanged.

        :param skia.Pixmap pixmap: storage for pixel state if pixels are
            readable; otherwise, ignored
        :return: true if :py:class:`Image` has direct access to pixels
        """
    @typing.overload
    def readPixels(
        self,
        context: GrDirectContext,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int,
        srcX: int = 0,
        srcY: int = 0,
        cachingHint: Image.CachingHint = ...,
    ) -> bool:
        """
        Copies a :py:class:`Rect` of pixels from :py:class:`Image` to dst. Copy
        starts at (srcX, srcY), and does not exceed :py:class:`Image` (width(),
        height()).

        dstInfo specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, and :py:class:`ColorSpace` of destination.
        dstRowBytes specifics the gap from one destination row to the next.
        Returns true if pixels are copied. Returns false if:

        - dstInfo.addr() equals nullptr
        - dstRowBytes is less than ``dstInfo.minRowBytes()``
        - :py:class:`PixelRef` is nullptr

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~kGray_8_ColorType`, or :py:attr:`~kAlpha_8_ColorType`;
        dst.colorType() must match. If :py:class:`Image` :py:class:`ColorType`
        is :py:attr:`~kGray_8_ColorType`, dst.colorSpace() must match. If
        :py:class:`Image` :py:class:`AlphaType` is
        :py:attr:`~kOpaque_AlphaType`, dst.alphaType() must match. If
        :py:class:`Image` :py:class:`ColorSpace` is nullptr, dst.colorSpace()
        must match. Returns false if pixel conversion is not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if width() or height() is zero or negative. Returns false
        if abs(srcX) >= Image width(), or if abs(srcY) >= Image height().

        If cachingHint is kAllow_CachingHint, pixels may be retained locally.
        If cachingHint is kDisallow_CachingHint, pixels are not added to the
        local cache.

        :param context:      the GrDirectContext in play, if it exists
        :param dstInfo:      destination width, height, pixels,
                             :py:class:`ColorType`, :py:class:`AlphaType`,
                             :py:class:`ColorSpace`
        :param dstPixels:    destination pixel storage
        :param dstRowBytes:  destination row length
        :param srcX:         column index whose absolute value is less than
                             width()
        :param srcY:         row index whose absolute value is less than
                             height()
        :param cachingHint:  whether the pixels should be cached locally
        :return:             true if pixels are copied to dstPixels
        """
    @typing.overload
    def readPixels(
        self,
        context: GrDirectContext,
        dst: Pixmap,
        srcX: int,
        srcY: int,
        cachingHint: Image.CachingHint = ...,
    ) -> bool:
        """
        Copies a :py:class:`Rect` of pixels from :py:class:`Image` to dst. Copy
        starts at (srcX, srcY), and does not exceed :py:class:`Image` (width(),
        height()).

        dst specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, :py:class:`ColorSpace`, pixel storage, and row
        bytes of destination. dst.rowBytes() specifics the gap from one
        destination row to the next. Returns true if pixels are copied. Returns
        false if:

        - dst pixel storage equals nullptr
        - dst.rowBytes is less than :py:meth:`ImageInfo.minRowBytes`
        - :py:class:`PixelRef` is nullptr

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~kGray_8_ColorType`, or :py:attr:`~kAlpha_8_ColorType`;
        dst.colorType() must match. If :py:class:`Image` :py:class:`ColorType`
        is :py:attr:`~kGray_8_ColorType`, dst.colorSpace() must match. If
        :py:class:`Image` :py:class:`AlphaType` is
        :py:attr:`~kOpaque_AlphaType`, dst.alphaType() must match. If
        :py:class:`Image` :py:class:`ColorSpace` is nullptr, dst.colorSpace()
        must match. Returns false if pixel conversion is not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if width() or height() is zero or negative. Returns false
        if abs(srcX) >= Image width(), or if abs(srcY) >= Image height().

        If cachingHint is kAllow_CachingHint, pixels may be retained locally.
        If cachingHint is kDisallow_CachingHint, pixels are not added to the
        local cache.

        :param context:      the GrDirectContext in play, if it exists
        :param dst:          destination :py:class:`Pixmap`:
                             :py:class:`ImageInfo`, pixels, row bytes
        :param srcX:         column index whose absolute value is less than
                             width()
        :param srcY:         row index whose absolute value is less than
                             height()
        :param cachingHint:  whether the pixels should be cached locally
        :return:             true if pixels are copied to dst
        """
    @typing.overload
    def readPixels(
        self,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int,
        srcX: int = 0,
        srcY: int = 0,
        cachingHint: Image.CachingHint = ...,
    ) -> bool:
        """
        Deprecated. Use the variants that accept a GrDirectContext.
        """
    @typing.overload
    def readPixels(
        self,
        dst: Pixmap,
        srcX: int,
        srcY: int,
        cachingHint: Image.CachingHint = ...,
    ) -> bool:
        """
        Deprecated. Use the variants that accept a `GrDirectContext`.
        """
    def refColorSpace(self) -> ColorSpace:
        """
        Returns a smart pointer to :py:class:`ColorSpace`, the range of colors,
        associated with :py:class:`Image`.

        The smart pointer tracks the number of objects sharing this
        :py:class:`ColorSpace` reference so the memory is released when the
        owners destruct.

        The returned :py:class:`ColorSpace` is immutable.

        :py:class:`ColorSpace` returned was passed to an :py:class:`Image`
        constructor, or was parsed from encoded data. :py:class:`ColorSpace`
        returned may be ignored when :py:class:`Image` is drawn, depending on
        the capabilities of the :py:class:`Surface` receiving the drawing.

        :return: :py:class:`ColorSpace` in :py:class:`Image`, or nullptr,
            wrapped in a smart pointer
        """
    def refEncodedData(self) -> Data:
        """
        Returns encoded :py:class:`Image` pixels as :py:class:`Data`, if
        :py:class:`Image` was created from supported encoded stream format.

        Platform support for formats vary and may require building with one or
        more of: SK_ENCODE_JPEG, SK_ENCODE_PNG, SK_ENCODE_WEBP.

        Returns nullptr if :py:class:`Image` contents are not encoded.

        :return: encoded :py:class:`Image`, or nullptr
        """
    def reinterpretColorSpace(self, newColorSpace: ColorSpace | None = None) -> Image:
        """
        Creates a new :py:class:`Image` identical to this one, but with a
        different :py:class:`ColorSpace`.

        This does not convert the underlying pixel data, so the resulting image
        will draw differently.
        """
    def resize(
        self,
        width: int,
        height: int,
        options: SamplingOptions = ...,
        cachingHint: Image.CachingHint = ...,
    ) -> Image:
        """
        Creates :py:class:`Image` by scaling pixels to fit width and height.
        Raises if :py:class:`Image` could not be scaled.

        Scales the image, with filterQuality, to match width and height.
        filterQuality :py:attr:`~FilterQuality.None_FilterQuality` is fastest,
        typically implemented with nearest neighbor filter.
        :py:attr:`~FilterQuality.kLow_FilterQuality` is typically implemented
        with bilerp filter. :py:attr:`~FilterQuality.kMedium_FilterQuality` is
        typically implemented with bilerp filter, and mip-map filter when size
        is reduced. :py:attr:`~FilterQuality.kHigh_FilterQuality` is slowest,
        typically implemented with bicubic filter.

        If cachingHint is :py:attr:`~Image.CachingHint.kAllow_CachingHint`,
        pixels may be retained locally. If cachingHint is
        :py:attr:`~Image.CachingHint.kDisallow_CachingHint`, pixels are not
        added to the local cache.

        :param int width: target width
        :param int height: target height
        :param skia.SamplingOptions options: sampling options
        :param skia.Image.CachingHint cachingHint: Caching hint
        :return: :py:class:`Image`
        """
    def save(
        self,
        fp: typing.Any,
        encodedImageFormat: EncodedImageFormat = ...,
        quality: int = 100,
    ) -> None:
        """
        Saves :py:attr:`Image` to file path or file-like object.

        Shortcut for the following::

            data = image.encodeToData(encodedImageFormat, quality)
            if hasattr(fp, "write"):
                fp.write(data)
            else:
                with open(fp, "wb") as f:
                    f.write(data)

        :param fp: file path or file-like object that has `write` method. file
            must be opened in writable binary mode.
        :param skia.EncodedImageFormat encodedImageFormat:
            one of: :py:attr:`~EncodedImageFormat.kJPEG`,
            :py:attr:`~EncodedImageFormat.kPNG`,
            :py:attr:`~EncodedImageFormat.kWEBP`
        :param int quality: encoder specific metric with 100 equaling best
        """
    def scalePixels(
        self,
        dst: Pixmap,
        samplingOptions: SamplingOptions = ...,
        cachingHint: Image.CachingHint = ...,
    ) -> bool:
        """
        Copies :py:class:`Image` to dst, scaling pixels to fit ``dst.width()``
        and ``dst.height()``, and converting pixels to match ``dst.colorType()``
        and ``dst.alphaType()``.

        Returns true if pixels are copied. Returns false if ``dst.addr()`` is
        nullptr, or ``dst.rowBytes()`` is less than dst
        :py:meth:`ImageInfo.minRowBytes`.

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; ``dst.colorType()`` must
        match. If :py:class:`Image` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, ``dst.colorSpace()`` must
        match. If :py:class:`Image` :py:class:`AlphaType` is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, ``dst.alphaType()`` must match.
        If :py:class:`Image` :py:class:`ColorSpace` is nullptr,
        ``dst.colorSpace()`` must match. Returns false if pixel conversion is
        not possible.

        Scales the image, with filterQuality, to match ``dst.width()`` and
        ``dst.height()``. filterQuality
        :py:attr:`~FilterQuality.None_FilterQuality` is fastest, typically
        implemented with nearest neighbor filter.
        :py:attr:`~FilterQuality.kLow_FilterQuality` is typically implemented
        with bilerp filter. :py:attr:`~FilterQuality.kMedium_FilterQuality` is
        typically implemented with bilerp filter, and mip-map filter when size
        is reduced. :py:attr:`~FilterQuality.kHigh_FilterQuality` is slowest,
        typically implemented with bicubic filter.

        If cachingHint is :py:attr:`~Image.CachingHint.kAllow_CachingHint`,
        pixels may be retained locally. If cachingHint is
        :py:attr:`~Image.CachingHint.kDisallow_CachingHint`, pixels are not
        added to the local cache.

        :param skia.Pixmap dst: destination :py:class:`Pixmap`:
            :py:class:`ImageInfo`, pixels, row bytes
        :param skia.FilterQuality filterQuality: Filter quality
        :param skia.Image.CachingHint cachingHint: Caching hint
        :return: true if pixels are scaled to fit dst
        """
    def toarray(
        self,
        srcX: int = 0,
        srcY: int = 0,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> numpy.ndarray:
        """
        Exports a ``numpy.ndarray``.

        :param srcX: offset into readable pixels on x-axis; may be negative
        :param srcY: offset into readable pixels on y-axis; may be negative
        :param colorType: target :py:class:`ColorType`
        :param alphaType: target :py:class:`AlphaType`
        :param colorSpace: target :py:class:`ColorSpace`
        :return: numpy.ndarray
        """
    def tobytes(self) -> typing.Any:
        """
        Creates python `bytes` object from internal pixels.

        When the image is raster, the returned bytes share the internal buffer.
        Otherwise, pixels are copied to a newly allocated python `bytes`.
        """
    def uniqueID(self) -> int:
        """
        Returns value unique to image.

        :py:class:`Image` contents cannot change after :py:class:`Image` is
        created. Any operation to create a new :py:class:`Image` will receive
        generate a new unique number.

        :return: unique identifier
        """
    def width(self) -> int:
        """
        Returns pixel count in each row.

        :return: pixel width in :py:class:`Image`
        """
    def withDefaultMipmaps(self) -> Image:
        """
        Returns an image with the same "base" pixels as the this image, but with
        mipmap levels automatically generated and attached.
        """
    @property
    def __array_interface__(self) -> dict: ...

class ImageFilter(Flattanable):
    """

    Base class for image filters.

    If one is installed in the paint, then all drawing occurs as usual, but it
    is as if the drawing happened into an offscreen (before the xfermode is
    applied). This offscreen bitmap will then be handed to the imagefilter, who
    in turn creates a new bitmap which is what will finally be drawn to the
    device (using the original xfermode).

    The local space of image filters matches the local space of the drawn
    geometry. For instance if there is rotation on the canvas, the blur will be
    computed along those rotated axes and not in the device space. In order to
    achieve this result, the actual drawing of the geometry may happen in an
    unrotated coordinate system so that the filtered image can be computed more
    easily, and then it will be post transformed to match what would have been
    produced if the geometry were drawn with the total canvas matrix to begin
    with.

    See :py:class:`ImageFilters` for available filters.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~skia.ArithmeticImageFilter
        ~skia.BlurImageFilter
        ~skia.ColorFilterImageFilter
        ~skia.DilateImageFilter
        ~skia.DisplacementMapEffect
        ~skia.DropShadowImageFilter
        ~skia.ErodeImageFilter
        ~skia.ImageFilters
        ~skia.LightingImageFilter
        ~skia.MagnifierImageFilter
        ~skia.OffsetImageFilter
        ~skia.PaintImageFilter
        ~skia.TileImageFilter
        ~skia.XfermodeImageFilter

    """
    class CropRect:
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, rect: Rect) -> None: ...

    class MapDirection:
        """
        Members:

          kForward_MapDirection

          kReverse_MapDirection
        """

        __members__: typing.ClassVar[
            dict[str, ImageFilter.MapDirection]
        ]  # value = {'kForward_MapDirection': <MapDirection.kForward_MapDirection: 0>, 'kReverse_MapDirection': <MapDirection.kReverse_MapDirection: 1>}
        kForward_MapDirection: typing.ClassVar[
            ImageFilter.MapDirection
        ]  # value = <MapDirection.kForward_MapDirection: 0>
        kReverse_MapDirection: typing.ClassVar[
            ImageFilter.MapDirection
        ]  # value = <MapDirection.kReverse_MapDirection: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kForward_MapDirection: typing.ClassVar[
        ImageFilter.MapDirection
    ]  # value = <MapDirection.kForward_MapDirection: 0>
    kReverse_MapDirection: typing.ClassVar[
        ImageFilter.MapDirection
    ]  # value = <MapDirection.kReverse_MapDirection: 1>
    @staticmethod
    def Deserialize(data: typing_extensions.Buffer) -> ImageFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def asAColorFilter(self) -> typing.Any:
        """
        Returns colorfilter if this imagefilter can be completely replaced by
        the returned colorfilter. Otherwise None.

        i.e. the two effects will affect drawing in the same way.
        """
    def asColorFilter(self) -> typing.Any: ...
    def canComputeFastBounds(self) -> bool: ...
    def computeFastBounds(self, bounds: Rect) -> Rect: ...
    def countInputs(self) -> int:
        """
        Returns the number of inputs this filter will accept (some inputs can be
        NULL).
        """
    def filterBounds(
        self,
        src: IRect,
        ctm: Matrix,
        direction: ImageFilter.MapDirection,
        inputRect: IRect | None = None,
    ) -> IRect:
        """
        Map a device-space rect recursively forward or backward through the
        filter DAG.

        :py:attr:`kForward_MapDirection` is used to determine which pixels of
        the destination canvas a source image rect would touch after filtering.
        :py:attr:`kReverse_MapDirection` is used to determine which rect of the
        source image would be required to fill the given rect (typically, clip
        bounds). Used for clipping and temp-buffer allocations, so the result
        need not be exact, but should never be smaller than the real answer. The
        default implementation recursively unions all input bounds, or returns
        the source rect if no inputs.

        In kReverse mode, 'inputRect' is the device-space bounds of the input
        pixels. In kForward mode it should always be null. If 'inputRect' is
        null in kReverse mode the resulting answer may be incorrect.
        """
    def getInput(self, i: int) -> ImageFilter:
        """
        Returns the input filter at a given index, or NULL if no input is
        connected.

        The indices used are filter-specific.
        """
    def isColorFilterNode(self) -> typing.Any:
        """
        Returns :py:class:`ColorFilter` if it can. Otherwise returns None.
        """
    def makeWithLocalMatrix(self, matrix: Matrix) -> ImageFilter:
        """
        If this filter can be represented by another filter + a localMatrix,
        return that filter, else return null.
        """

class ImageFilters:
    @staticmethod
    def Arithmetic(
        k1: float,
        k2: float,
        k3: float,
        k4: float,
        enforcePMColor: bool,
        background: ImageFilter,
        foreground: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that implements a custom blend mode.

        Each output pixel is the result of combining the corresponding
        background and foreground pixels using the 4 coefficients::

            k1 * foreground * background + k2 * foreground + \\
            k3 * background + k4

        :param float k1: The first coefficients used to combine the foreground
            and background.
        :param float k2: The second coefficients used to combine the foreground
            and background.
        :param float k3: The third coefficients used to combine the foreground
            and background.
        :param float k4: The fourth coefficients used to combine the foreground
            and background.
        :param bool enforcePMColor:  If true, the RGB channels will be clamped
            to the calculated alpha.
        :param skia.ImageFilter background:  The background content, using the
            source bitmap when this is null.
        :param skia.ImageFilter foreground:  The foreground content, using the
            source bitmap when this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the inputs and
            output.
        """
    @staticmethod
    def Blur(
        sigmaX: float,
        sigmaY: float,
        tileMode: TileMode = ...,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that blurs its input by the separate X and Y sigmas.

        The provided tile mode is used when the blur kernel goes outside the
        input image.

        :param float sigmaX: The Gaussian sigma value for blurring along the X
            axis.
        :param float sigmaY: The Gaussian sigma value for blurring along the Y
            axis.
        :param skia.TileMode tileMode: The tile mode applied at edges.
            TODO (michaelludwig) - kMirror is not supported yet
        :param skia.ImageFilter input: The input filter that is blurred, uses
            source bitmap if this is null.
        :param skia.Rect cropRect:    Optional rectangle that crops the input
            and output.
        """
    @staticmethod
    def ColorFilter(
        cf: ColorFilter,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that applies the color filter to the input filter
        results.

        :param skia.ColorFilter cf: The color filter that transforms the input
            image.
        :param skia.ImageFilter input:  The input filter, or uses the source
            bitmap if this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def Compose(outer: ImageFilter, inner: ImageFilter) -> ImageFilter:
        """
        Create a filter that composes 'inner' with 'outer', such that the
        results of 'inner' are treated as the source bitmap passed to 'outer',
        i.e. result = outer(inner(source)).

        :param skia.ImageFilter outer: The outer filter that evaluates the
            results of inner.
        :param skia.ImageFilter inner: The inner filter that produces the input
            to outer.
        """
    @staticmethod
    def Dilate(
        radiusX: float,
        radiusY: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that dilates each input pixel's channel values to the
        max value within the given radii along the x and y axes.

        :param float radiusX: The distance to dilate along the x axis to either
            side of each pixel.
        :param float radiusY: The distance to dilate along the y axis to either
            side of each pixel.
        :param skia.ImageFilter input: The image filter that is dilated, using
            source bitmap if this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def DisplacementMap(
        xChannelSelector: ColorChannel,
        yChannelSelector: ColorChannel,
        scale: float,
        displacement: ImageFilter,
        color: ImageFilter,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that moves each pixel in its color input based on an
        (x,y) vector encoded in its displacement input filter.

        Two color components of the displacement image are mapped into a vector
        as scale * (color[xChannel], color[yChannel]), where the channel
        selectors are one of R, G, B, or A.

        :param skia.ColorChannel xChannelSelector: RGBA channel that encodes the
            x displacement per pixel.
        :param skia.ColorChannel yChannelSelector: RGBA channel that encodes the
            y displacement per pixel.
        :param float scale: Scale applied to displacement extracted from image.
        :param skia.ImageFilter displacement: The filter defining the
            displacement image, or null to use source.
        :param skia.ImageFilter color: The filter providing the color pixels to
            be displaced.
        :param skia.Rect cropRect:  Optional rectangle that crops the color
            input and output.
        """
    @staticmethod
    def DistantLitDiffuse(
        direction: Point3,
        lightColor: int,
        surfaceScale: float,
        kd: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the diffuse illumination from a distant
        light source, interpreting the alpha channel of the input as the height
        profile of the surface (to approximate normal vectors).

        :param skia.Point3 direction: The direction to the distance light.
        :param int lightColor: The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float kd: Diffuse reflectance coefficient.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def DistantLitSpecular(
        direction: Point3,
        lightColor: int,
        surfaceScale: float,
        ks: float,
        shininess: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the specular illumination from a distant
        light source, interpreting the alpha channel of the input as the height
        profile of the surface (to approximate normal vectors).

        :param skia.Point3 direction: The direction to the distance light.
        :param int lightColor: The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float ks: Specular reflectance coefficient.
        :param float shininess: The specular exponent determining how shiny the
            surface is.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def DropShadow(
        dx: float,
        dy: float,
        sigmaX: float,
        sigmaY: float,
        color: int,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that draws a drop shadow under the input content.

        This filter produces an image that includes the inputs' content.

        :param float dx: The X offset of the shadow.
        :param float dy: The Y offset of the shadow.
        :param float sigmaX: The blur radius for the shadow, along the X axis.
        :param float sigmaY: The blur radius for the shadow, along the Y axis.
        :param int color: The color of the drop shadow.
        :param skia.ImageFilter input: The input filter, or will use the source
            bitmap if this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def DropShadowOnly(
        dx: float,
        dy: float,
        sigmaX: float,
        sigmaY: float,
        color: int,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that renders a drop shadow, in exactly the same manner
        as :py:meth:`~ImageFilters.DropShadow`, except that the resulting image
        does not include the input content.

        This allows the shadow and input to be composed by a filter DAG in a
        more flexible manner.

        :param float dx: The X offset of the shadow.
        :param float dy: The Y offset of the shadow.
        :param float sigmaX: The blur radius for the shadow, along the X axis.
        :param float sigmaY: The blur radius for the shadow, along the Y axis.
        :param int color: The color of the drop shadow.
        :param skia.ImageFilter input: The input filter, or will use the source
            bitmap if this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def Erode(
        radiusX: float,
        radiusY: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that erodes each input pixel's channel values to the
        minimum channel value within the given radii along the x and y axes.

        :param float radiusX: The distance to erode along the x axis to either
            side of each pixel.
        :param float radiusY: The distance to erode along the y axis to either
            side of each pixel.
        :param skia.ImageFilter input: The image filter that is eroded, using
            source bitmap if this is null.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    @typing.overload
    def Image(
        image: Image,
        srcRect: Rect,
        dstRect: Rect,
        options: SamplingOptions = ...,
    ) -> ImageFilter:
        """
        Create a filter that draws the 'srcRect' portion of image into 'dstRect'
        using the given filter quality.

        Similar to :py:meth:`Canvas.drawImageRect`. Returns null if 'image' is
        null.

        :image: The image that is output by the filter, subset by 'srcRect'.
        :srcRect: The source pixels sampled into 'dstRect'
        :dstRect: The local rectangle to draw the image into.
        :filterQuality: The filter quality that is used when sampling the image.
        """
    @staticmethod
    @typing.overload
    def Image(image: Image, options: SamplingOptions = ...) -> ImageFilter:
        """
        Create a filter that produces the image contents.

        :image: The image that is output by the filter.
        """
    @staticmethod
    def Magnifier(
        srcRect: Rect,
        zoomAmount: float,
        inset: float,
        sampling: SamplingOptions,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that mimics a zoom/magnifying lens effect.

        :param skia.Rect srcRect: Source rect.
        :param float inset: Inset.
        :param skia.ImageFilter input: The input filter that is magnified, if
            null the source bitmap is used.
        :param skia.Rect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def MatrixConvolution(
        kernelSize: ISize,
        kernel: list[float],
        gain: float,
        bias: float,
        kernelOffset: IPoint,
        tileMode: TileMode,
        convolveAlpha: bool,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that applies an NxM image processing kernel to the input
        image.

        This can be used to produce effects such as sharpening, blurring, edge
        detection, etc.

        :param skia.ISize kernelSize: The kernel size in pixels, in each
            dimension (N by M).
        :param List[float] kernel: The image processing kernel. Must contain
            N * M elements, in row order.
        :param float gain:   A scale factor applied to each pixel after
            convolution. This can be used to normalize the kernel, if it does
            not already sum to 1.
        :param float bias: A bias factor added to each pixel after convolution.
        :param skia.IPoint kernelOffset: An offset applied to each pixel
            coordinate before convolution. This can be used to center the kernel
            over the image (e.g., a 3x3 kernel should have an offset of {1, 1}).
        :param skia.TileMode tileMode: How accesses outside the image are
            treated. TODO (michaelludwig) - kMirror is not supported yet
        :param bool convolveAlpha:  If true, all channels are convolved. If
            false, only the RGB channels are convolved, and alpha is copied from
            the source image.
        :param skia.ImageFilter input:  The input image filter, if null the
            source bitmap is used instead.
        :param skia.Rect cropRect:   Optional rectangle to which the output
            processing will be limited.
        """
    @staticmethod
    def MatrixTransform(
        matrix: Matrix,
        sampling: SamplingOptions,
        input: ImageFilter | None = None,
    ) -> ImageFilter:
        """
        Create a filter that transforms the input image by 'matrix'.

        This matrix transforms the local space, which means it effectively
        happens prior to any transformation coming from the SkCanvas initiating
        the filtering.

        :param skia.Matrix matrix: The matrix to apply to the original content.
        :param skia.SamplingOptions sampling: How the image will be sampled when it is transformed
        :param skia.ImageFilter input: The image filter to transform, or null to
            use the source image.
        """
    @staticmethod
    def Merge(filters: list, cropRect: IRect | None = None) -> ImageFilter:
        """
        Create a filter that merges the 'count' filters together by drawing
        their results in order with src-over blending.

        :param List[skia.ImageFilter] filters: The input filter array to merge,
            which must have 'count' elements. Any null filter pointers will use
            the source bitmap instead.
        :param skia.Rect cropRect: Optional rectangle that crops all input
            filters and the output.
        """
    @staticmethod
    def Offset(
        dx: float,
        dy: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that offsets the input filter by the given vector.

        :param float dx: The x offset in local space that the image is shifted.
        :param float dy: The y offset in local space that the image is shifted.
        :param skia.ImageFilter input: The input that will be moved, if null the
            source bitmap is used instead.
        :param skia.Rect cropRect: Optional rectangle to crop the input and
            output.
        """
    @staticmethod
    def Picture(pic: Picture, targetRect: Rect | None = None) -> ImageFilter:
        """
        Create a filter that produces the SkPicture as its output, drawn into
        targetRect.

        Note that the targetRect is not the same as the SkIRect cropRect that
        many filters accept. Returns null if 'pic' is null.

        :param skia.Picture pic: The picture that is drawn for the filter
            output.
        :param skia.Rect targetRect: The drawing region for the picture.
        """
    @staticmethod
    def PointLitDiffuse(
        location: Point3,
        lightColor: int,
        surfaceScale: float,
        kd: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the diffuse illumination from a point
        light source, using alpha channel of the input as the height profile of
        the surface (to approximate normal vectors).

        :param skia.Point3 location: The location of the point light.
        :param int lightColor:  The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float kd: Diffuse reflectance coefficient.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.IRect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def PointLitSpecular(
        location: Point3,
        lightColor: int,
        surfaceScale: float,
        ks: float,
        shininess: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the specular illumination from a point
        light source, using alpha channel of the input as the height profile of
        the surface (to approximate normal vectors).

        :param skia.Point3 location: The location of the point light.
        :param int lightColor:  The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float ks: Specular reflectance coefficient.
        :param float shininess: The specular exponent determining how shiny the
            surface is.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.IRect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def SpotLitDiffuse(
        location: Point3,
        target: Point3,
        falloffExponent: float,
        cutoffAngle: float,
        lightColor: int,
        surfaceScale: float,
        kd: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the diffuse illumination from a spot
        light source, using alpha channel of the input as the height profile of
        the surface (to approximate normal vectors).

        The spot light is restricted to be within 'cutoffAngle' of the vector
        between the location and target.

        :param skia.Point3 location: The location of the spot light.
        :param skia.Point3 target: The location that the spot light is point
            towards
        :param float falloffExponent: Exponential falloff parameter for
            illumination outside of cutoffAngle
        :param float cutoffAngle: Maximum angle from lighting direction that
            receives full light
        :param int lightColor:  The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float kd:  Diffuse reflectance coefficient.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.IRect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def SpotLitSpecular(
        location: Point3,
        target: Point3,
        falloffExponent: float,
        cutoffAngle: float,
        lightColor: int,
        surfaceScale: float,
        ks: float,
        shininess: float,
        input: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        Create a filter that calculates the diffuse illumination from a spot
        light source, using alpha channel of the input as the height profile of
        the surface (to approximate normal vectors).

        The spot light is restricted to be within 'cutoffAngle' of the vector
        between the location and target.

        :param skia.Point3 location: The location of the spot light.
        :param skia.Point3 target: The location that the spot light is point
            towards
        :param float falloffExponent: Exponential falloff parameter for
            illumination outside of cutoffAngle
        :param float cutoffAngle: Maximum angle from lighting direction that
            receives full light
        :param int lightColor:  The color of the diffuse light source.
        :param float surfaceScale: Scale factor to transform from alpha values
            to physical height.
        :param float ks: Specular reflectance coefficient.
        :param float shininess: The specular exponent determining how shiny the
            surface is.
        :param skia.ImageFilter input: The input filter that defines surface
            normals (as alpha), or uses the source bitmap when null.
        :param skia.IRect cropRect: Optional rectangle that crops the input and
            output.
        """
    @staticmethod
    def Tile(src: Rect, dst: Rect, input: ImageFilter | None = None) -> ImageFilter:
        """
        Create a tile image filter.

        :param skia.Rect src: Defines the pixels to tile
        :param skia.Rect dst: Defines the pixel region that the tiles will be
            drawn to
        :param skia.ImageFilter input: The input that will be tiled, if null the
            source bitmap is used instead.
        """
    @staticmethod
    def Xfermode(
        mode: BlendMode,
        background: ImageFilter | None = None,
        foreground: ImageFilter | None = None,
        cropRect: IRect | None = None,
    ) -> ImageFilter:
        """
        This filter takes an :py:class:`BlendMode` and uses it to composite the
        two filters together.

        :param skia.ImageFilter background: The Dst pixels used in blending, if
            null the source bitmap is used.
        :param skia.ImageFilter foreground: The Src pixels used in blending, if
            null the source bitmap is used. Optional rectangle to crop input and
            output.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class ImageInfo:
    """

    Describes pixel dimensions and encoding.

    :py:class:`Bitmap`, :py:class:`Image`, :py:class:`Pixmap`, and
    :py:class:`Surface` can be created from :py:class:`ImageInfo`.
    :py:class:`ImageInfo` can be retrieved from :py:class:`Bitmap` and
    :py:class:`Pixmap`, but not from :py:class:`Image` and :py:class:`Surface`.
    For example, :py:class:`Image` and :py:class:`Surface` implementations may
    defer pixel depth, so may not completely specify :py:class:`ImageInfo`.

    :py:class:`ImageInfo` contains dimensions, the pixel integral width and
    height. It encodes how pixel bits describe alpha, transparency; color
    components red, blue, and green; and :py:class:`ColorSpace`, the range and
    linearity of colors.

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def ByteSizeOverflowed(byteSize: int) -> bool:
        """
        Returns true if byteSize equals SIZE_MAX.

        :py:meth:`computeByteSize` and :py:meth:`computeMinByteSize` return
        SIZE_MAX if size_t can not hold buffer size.

        :param int byteSize: result of :py:meth:`computeByteSize` or
            :py:meth:`computeMinByteSize`
        :return: true if :py:meth:`computeByteSize` or
            :py:meth:`computeMinByteSize` result exceeds size_t
        """
    @staticmethod
    @typing.overload
    def Make(
        width: int,
        height: int,
        ct: ColorType,
        at: AlphaType,
        cs: ColorSpace | None = None,
    ) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:class:`ColorType` ct, :py:class:`AlphaType` at, and optionally
        :py:class:`ColorSpace` cs.

        If :py:class:`ColorSpace` cs is nullptr and :py:class:`ImageInfo` is
        part of drawing source: :py:class:`ColorSpace` defaults to sRGB, mapping
        into :py:class:`Surface` :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :width:   pixel column count; must be zero or greater
        :height:  pixel row count; must be zero or greater
        :cs:  range of colors; may be nullptr
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def Make(
        dimensions: ISize,
        ct: ColorType,
        at: AlphaType,
        cs: ColorSpace | None = None,
    ) -> ImageInfo: ...
    @staticmethod
    @typing.overload
    def Make(dimensions: ISize, colorInfo: ColorInfo) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions and
        :py:class:`ColorInfo` colorInfo,.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :param skia.ISize dimensions: pixel column and row count; must be zeros
            or greater
        :param skia.ColorInfo colorInfo: :py:class:`ColorInfo` the pixel
            encoding consisting of :py:class:`ColorType`, :py:class:`AlphaType`,
            and :py:class:`ColorSpace` (which may be nullptr)
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def MakeA8(width: int, height: int) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kAlpha_8_ColorType`,
        :py:attr:`~skia.AlphaType.kPremul_AlphaType`, with
        :py:class:`ColorSpace` set to nullptr.

        :width:  pixel column count; must be zero or greater
        :height: pixel row count; must be zero or greater
        """
    @staticmethod
    @typing.overload
    def MakeA8(dimensions: ISize) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions,
        :py:attr:`~skia.ColorType.kAlpha_8_ColorType`,
        :py:attr:`~skia.AlphaType.kPremul_AlphaType`, with
        :py:class:`ColorSpace` set to nullptr.

        :dimensions: pixel row and column count; must be zero or greater
        """
    @staticmethod
    def MakeN32(
        width: int,
        height: int,
        at: AlphaType,
        cs: ColorSpace | None = None,
    ) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kN32_ColorType`, :py:class:`AlphaType` at, and
        optionally :py:class:`ColorSpace` cs.

        :py:attr:`~skia.ColorType.kN32_ColorType` will equal either
        :py:attr:`~skia.ColorType.kBGRA_8888_ColorType` or
        :py:attr:`~skia.ColorType.kRGBA_8888_ColorType`, whichever is optimal.

        If :py:class:`ColorSpace` cs is nullptr and :py:class:`ImageInfo` is
        part of drawing source: :py:class:`ColorSpace` defaults to sRGB, mapping
        into :py:class:`Surface` :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :param int width:  pixel column count; must be zero or greater
        :param int height: pixel row count; must be zero or greater
        :param skia.ColorSpace cs: range of colors; may be nullptr
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def MakeN32Premul(
        width: int,
        height: int,
        cs: ColorSpace | None = None,
    ) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kN32_ColorType`,
        :py:attr:`~skia.AlphaType.kPremul_AlphaType`, with optional
        :py:class:`ColorSpace`.

        If :py:class:`ColorSpace` cs is nullptr and :py:class:`ImageInfo` is
        part of drawing source: :py:class:`ColorSpace` defaults to sRGB, mapping
        into :py:class:`Surface` :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :width:  pixel column count; must be zero or greater
        :height: pixel row count; must be zero or greater
        :cs: range of colors; may be nullptr
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def MakeN32Premul(dimensions: ISize, cs: ColorSpace | None = None) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kN32_ColorType`,
        :py:attr:`~skia.AlphaType.kPremul_AlphaType`, with optional
        :py:class:`ColorSpace`.

        If :py:class:`ColorSpace` cs is nullptr and :py:class:`ImageInfo` is
        part of drawing source: :py:class:`ColorSpace` defaults to sRGB, mapping
        into :py:class:`Surface` :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :dimensions: width and height, each must be zero or greater
        :cs: range of colors; may be nullptr
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    def MakeS32(width: int, height: int, at: AlphaType) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kN32_ColorType`, :py:class:`AlphaType` at,
        with sRGB :py:class:`ColorSpace`.

        Parameters are not validated to see if their values are legal, or that
        the combination is supported.

        :param int width:  pixel column count; must be zero or greater
        :param int height: pixel row count; must be zero or greater
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def MakeUnknown(width: int, height: int) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height,
        :py:attr:`~skia.ColorType.kUnknown_ColorType`,
        :py:attr:`~skia.AlphaType.kUnknown_AlphaType`, with
        :py:class:`ColorSpace` set to nullptr.

        Returned :py:class:`ImageInfo` as part of source does not draw, and as
        part of destination can not be drawn to.

        :width:  pixel column count; must be zero or greater
        :height: pixel row count; must be zero or greater
        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    @typing.overload
    def MakeUnknown() -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` from integral dimensions width and height
        set to zero, :py:attr:`~skia.ColorType.kUnknown_ColorType`,
        :py:attr:`~skia.AlphaType.kUnknown_AlphaType`, with
        :py:class:`ColorSpace` set to nullptr.

        Returned :py:class:`ImageInfo` as part of source does not draw, and as
        part of destination can not be drawn to.

        :return: created :py:class:`ImageInfo`
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: ImageInfo) -> bool:
        """
        Compares :py:class:`ImageInfo` with other, and returns true if width,
        height, :py:class:`ColorType`, :py:class:`AlphaType`, and
        :py:class:`ColorSpace` are equivalent.

        :param other: :py:class:`ImageInfo` to compare
        :return: true if :py:class:`ImageInfo` equals other
        """
    def __init__(self) -> None:
        """
        Creates an empty :py:class:`ImageInfo` with
        :py:attr:`~skia.ColorType.kUnknown_ColorType`,
        :py:attr:`~skia.AlphaType.kUnknown_AlphaType`, a width and height of
        zero, and no :py:class:`ColorSpace`.
        """
    def __ne__(self, arg0: ImageInfo) -> bool:
        """
        Compares :py:class:`ImageInfo` with other, and returns true if width,
        height, :py:class:`ColorType`, :py:class:`AlphaType`, and
        :py:class:`ColorSpace` are not equivalent.

        :param other: :py:class:`ImageInfo` to compare
        :return: true if :py:class:`ImageInfo` is not equal to other
        """
    def alphaType(self) -> AlphaType: ...
    def bounds(self) -> IRect:
        """
        Returns :py:class:`IRect` (0, 0, :py:meth:`width`, :py:meth:`height`).

        :return: integral rectangle from origin to :py:meth:`width` and
            :py:meth:`height`
        """
    def bytesPerPixel(self) -> int:
        """
        Returns number of bytes per pixel required by :py:class:`ColorType`.

        Returns zero if :py:meth:`colorType` is
        :py:attr:`~skia.ColorType.kUnknown_ColorType`.

        :return: bytes in pixel
        """
    def colorInfo(self) -> ColorInfo:
        """
        Returns the dimensionless :py:class:`ColorInfo` that represents the same
        color type, alpha type, and color space as this :py:class:`ImageInfo`.
        """
    def colorSpace(self) -> ColorSpace:
        """
        Returns :py:class:`ColorSpace`, the range of colors.

        The reference count of :py:class:`ColorSpace` is unchanged. The returned
        :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace`, or nullptr
        """
    def colorType(self) -> ColorType: ...
    def computeByteSize(self, rowBytes: int) -> int:
        """
        Returns storage required by pixel array, given :py:class:`ImageInfo`
        dimensions, :py:class:`ColorType`, and rowBytes.

        rowBytes is assumed to be at least as large as :py:meth:`minRowBytes`.

        Returns zero if height is zero. Returns SIZE_MAX if answer exceeds the
        range of size_t.

        :param int rowBytes: size of pixel row or larger
        :return: memory required by pixel buffer
        """
    def computeMinByteSize(self) -> int:
        """
        Returns storage required by pixel array, given :py:class:`ImageInfo`
        dimensions, and :py:class:`ColorType`.

        Uses :py:meth:`minRowBytes` to compute bytes for pixel row.

        Returns zero if height is zero. Returns SIZE_MAX if answer exceeds the
        range of size_t.

        :return: least memory required by pixel buffer
        """
    def computeOffset(self, x: int, y: int, rowBytes: int) -> int:
        """
        Returns byte offset of pixel from pixel base address.

        Asserts in debug build if x or y is outside of bounds. Does not assert
        if rowBytes is smaller than :py:meth:`minRowBytes`, even though result
        may be incorrect.

        :param int x: column index, zero or greater, and less than
            :py:meth:`width`
        :param int y: row index, zero or greater, and less than
            :py:meth:`height`
        :param int rowBytes: size of pixel row or larger
        :return: offset within pixel array
        """
    def dimensions(self) -> ISize:
        """
        Returns :py:class:`ISize` (:py:meth:`width`, :py:meth:`height`).

        :return: integral size of :py:meth:`width` and :py:meth:`height`
        """
    def gammaCloseToSRGB(self) -> bool:
        """
        Returns true if associated :py:class:`ColorSpace` is not nullptr, and
        :py:class:`ColorSpace` gamma is approximately the same as sRGB.

        :return: true if :py:class:`ColorSpace` gamma is approximately the same
            as sRGB
        """
    def height(self) -> int:
        """
        Returns pixel row count.

        :return: pixel height
        """
    def isEmpty(self) -> bool:
        """
        Returns if :py:class:`ImageInfo` describes an empty area of pixels by
        checking if either width or height is zero or smaller.

        :return: true if either dimension is zero or smaller
        """
    def isOpaque(self) -> bool:
        """
        Returns true if :py:class:`AlphaType` is set to hint that all pixels are
        opaque; their alpha value is implicitly or explicitly 1.0.

        If true, and all pixels are not opaque, Skia may draw incorrectly.

        Does not check if :py:class:`ColorType` allows alpha, or if any pixel
        value has transparency.

        :return: true if :py:class:`AlphaType` is
            :py:attr:`~skia.AlphaType.kOpaque_AlphaType`
        """
    def makeAlphaType(self, newAlphaType: AlphaType) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` with same :py:class:`ColorType`,
        :py:class:`ColorSpace`, width, and height, with :py:class:`AlphaType`
        set to newAlphaType.

        Created :py:class:`ImageInfo` contains newAlphaType even if it is
        incompatible with :py:class:`ColorType`, in which case
        :py:class:`AlphaType` in :py:class:`ImageInfo` is ignored.

        :param skia.AlphaType newAlphaType: new alpha type
        :return: created :py:class:`ImageInfo`
        """
    def makeColorSpace(self, cs: ColorSpace) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` with same :py:class:`AlphaType`,
        :py:class:`ColorType`, width, and height, with :py:class:`ColorSpace`
        set to cs.

        :param skia.ColorSpace cs: range of colors; may be nullptr
        :return: created :py:class:`ImageInfo`
        """
    def makeColorType(self, newColorType: ColorType) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` with same :py:class:`AlphaType`,
        :py:class:`ColorSpace`, width, and height, with :py:class:`ColorType`
        set to newColorType.

        :param skia.ColorType newColorType: new color type
        :return: created :py:class:`ImageInfo`
        """
    def makeDimensions(self, newSize: ISize) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` with the same :py:class:`ColorType`,
        :py:class:`ColorSpace`, and :py:class:`AlphaType`, with dimensions set
        to newDimensions.

        :param skia.ISize newSize: pixel column and row count; must be zero or
            greater
        :return: created :py:class:`ImageInfo`
        """
    def makeWH(self, newWidth: int, newHeight: int) -> ImageInfo:
        """
        Creates :py:class:`ImageInfo` with the same :py:class:`ColorType`,
        :py:class:`ColorSpace`, and :py:class:`AlphaType`, with dimensions set
        to width and height.

        :param int newWidth:  pixel column count; must be zero or greater
        :param int newHeight: pixel row count; must be zero or greater
        :return: created :py:class:`ImageInfo`
        """
    def minRowBytes(self) -> int:
        """
        Returns minimum bytes per row, computed from pixel :py:meth:`width` and
        :py:class:`ColorType`, which specifies :py:meth:`bytesPerPixel`.

        :py:class:`Bitmap` maximum value for row bytes must fit in 31 bits.

        :return: :py:meth:`width` times :py:meth:`bytesPerPixel` as signed
            32-bit integer
        """
    def minRowBytes64(self) -> int:
        """
        Returns minimum bytes per row, computed from pixel :py:meth:`width` and
        :py:class:`ColorType`, which specifies :py:meth:`bytesPerPixel`.

        :py:class:`Bitmap` maximum value for row bytes must fit in 31 bits.

        :return: :py:meth:`width` times :py:meth:`bytesPerPixel` as unsigned
            64-bit integer
        """
    def refColorSpace(self) -> ColorSpace:
        """
        Returns smart pointer to :py:class:`ColorSpace`, the range of colors.

        The smart pointer tracks the number of objects sharing this
        :py:class:`ColorSpace` reference so the memory is released when the
        owners destruct.

        The returned :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace` wrapped in a smart pointer
        """
    def reset(self) -> None:
        """
        Creates an empty :py:class:`ImageInfo` with
        :py:attr:`~skia.ColorType.kUnknown_ColorType`,
        :py:attr:`~skia.AlphaType.kUnknown_AlphaType`, a width and height of
        zero, and no :py:class:`ColorSpace`.
        """
    def shiftPerPixel(self) -> int:
        """
        Returns bit shift converting row bytes to row pixels.

        Returns zero for :py:attr:`skia.ColorType.kUnknown_ColorType`.

        :return: one of: 0, 1, 2, 3; left shift to convert pixels to bytes
        """
    def validRowBytes(self, rowBytes: int) -> bool:
        """
        Returns true if rowBytes is valid for this :py:class:`ImageInfo`.

        :param int rowBytes: size of pixel row including padding
        :return: true if rowBytes is large enough to contain pixel row and is
            properly aligned
        """
    def width(self) -> int:
        """
        Returns pixel count in each row.

        :return: pixel width
        """

class Line2DPathEffect:
    @staticmethod
    def Make(width: float, matrix: Matrix) -> PathEffect: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class LumaColorFilter:
    """

    :py:class:`LumaColorFilter` multiplies the luma of its input into the alpha
    channel, and sets the red, green, and blue channels to zero.

    :py:class:`LumaColorFilter` (r,g,b,a) = {0,0,0, a * luma(r,g,b)}

    This is similar to a luminanceToAlpha feColorMatrix, but note how this
    filter folds in the previous alpha, something an feColorMatrix cannot do.

    feColorMatrix(luminanceToAlpha; r,g,b,a) = {0,0,0, luma(r,g,b)}

    (Despite its name, an feColorMatrix using luminanceToAlpha does actually
    compute luma, a dot-product of gamma-encoded color channels, not luminance,
    a dot-product of linear color channels. So at least
    :py:class:`LumaColorFilter` and feColorMatrix+luminanceToAlpha agree there.)

    """
    @staticmethod
    def Make() -> ColorFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class M44:
    """

    4x4 matrix used by :py:class:`Canvas` and other parts of Skia.

    Skia assumes a right-handed coordinate system: +X goes to the right +Y goes
    down +Z goes into the screen (away from the viewer)

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class MaskFilter(Flattanable):
    """

    :py:class:`MaskFilter` is the base class for object that perform
    transformations on the mask before drawing it.

    An example subclass is Blur.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~skia.ShaderMaskFilter
        ~skia.TableMaskFilter

    """
    @staticmethod
    def Deserialize(data: typing_extensions.Buffer) -> MaskFilter: ...
    @staticmethod
    def MakeBlur(style: BlurStyle, sigma: float, respectCTM: bool = True) -> MaskFilter:
        """
        Create a blur maskfilter.

        :param skia.BlurStyle style: The :py:class:`BlurStyle` to use
        :param float sigma: Standard deviation of the Gaussian blur to apply.
            Must be > 0.
        :param bool respectCTM: if true the blur's sigma is modified by the CTM.
        :return: The new blur maskfilter
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Matrix:
    """

    :py:class:`Matrix` holds a 3x3 matrix for transforming coordinates.

    This allows mapping :py:class:`Point` and vectors with translation, scaling,
    skewing, rotation, and perspective.

    :py:class:`Matrix` elements are in row major order. :py:class:`Matrix` does
    not have a constructor, so it must be explicitly initialized.
    :py:meth:`setIdentity` initializes :py:class:`Matrix` so it has no effect.
    :py:meth:`setTranslate`, :py:meth:`setScale`, :py:meth:`setSkew`,
    :py:meth:`setRotate`, :py:meth:`set9` and :py:meth:`setAll` initializes all
    :py:class:`Matrix` elements with the corresponding mapping.

    :py:class:`Matrix` includes a hidden variable that classifies the type of
    matrix to improve performance. :py:class:`Matrix` is not thread safe unless
    getType() is called first.

    """
    class ScaleToFit:
        """
        Members:

          kFill_ScaleToFit : scales in x and y to fill destination SkRect

          kStart_ScaleToFit : scales and aligns to left and top

          kCenter_ScaleToFit : scales and aligns to center

          kEnd_ScaleToFit : scales and aligns to right and bottom
        """

        __members__: typing.ClassVar[
            dict[str, Matrix.ScaleToFit]
        ]  # value = {'kFill_ScaleToFit': <ScaleToFit.kFill_ScaleToFit: 0>, 'kStart_ScaleToFit': <ScaleToFit.kStart_ScaleToFit: 1>, 'kCenter_ScaleToFit': <ScaleToFit.kCenter_ScaleToFit: 2>, 'kEnd_ScaleToFit': <ScaleToFit.kEnd_ScaleToFit: 3>}
        kCenter_ScaleToFit: typing.ClassVar[
            Matrix.ScaleToFit
        ]  # value = <ScaleToFit.kCenter_ScaleToFit: 2>
        kEnd_ScaleToFit: typing.ClassVar[
            Matrix.ScaleToFit
        ]  # value = <ScaleToFit.kEnd_ScaleToFit: 3>
        kFill_ScaleToFit: typing.ClassVar[
            Matrix.ScaleToFit
        ]  # value = <ScaleToFit.kFill_ScaleToFit: 0>
        kStart_ScaleToFit: typing.ClassVar[
            Matrix.ScaleToFit
        ]  # value = <ScaleToFit.kStart_ScaleToFit: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class TypeMask:
        """
        Members:

          kIdentity_Mask : identity SkMatrix; all bits clear

          kTranslate_Mask : translation SkMatrix

          kScale_Mask : scale SkMatrix

          kAffine_Mask : skew or rotate SkMatrix

          kPerspective_Mask : perspective SkMatrix
        """

        __members__: typing.ClassVar[
            dict[str, Matrix.TypeMask]
        ]  # value = {'kIdentity_Mask': <TypeMask.kIdentity_Mask: 0>, 'kTranslate_Mask': <TypeMask.kTranslate_Mask: 1>, 'kScale_Mask': <TypeMask.kScale_Mask: 2>, 'kAffine_Mask': <TypeMask.kAffine_Mask: 4>, 'kPerspective_Mask': <TypeMask.kPerspective_Mask: 8>}
        kAffine_Mask: typing.ClassVar[
            Matrix.TypeMask
        ]  # value = <TypeMask.kAffine_Mask: 4>
        kIdentity_Mask: typing.ClassVar[
            Matrix.TypeMask
        ]  # value = <TypeMask.kIdentity_Mask: 0>
        kPerspective_Mask: typing.ClassVar[
            Matrix.TypeMask
        ]  # value = <TypeMask.kPerspective_Mask: 8>
        kScale_Mask: typing.ClassVar[
            Matrix.TypeMask
        ]  # value = <TypeMask.kScale_Mask: 2>
        kTranslate_Mask: typing.ClassVar[
            Matrix.TypeMask
        ]  # value = <TypeMask.kTranslate_Mask: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kAScaleX: typing.ClassVar[int] = 0
    kAScaleY: typing.ClassVar[int] = 3
    kASkewX: typing.ClassVar[int] = 2
    kASkewY: typing.ClassVar[int] = 1
    kATransX: typing.ClassVar[int] = 4
    kATransY: typing.ClassVar[int] = 5
    kAffine_Mask: typing.ClassVar[Matrix.TypeMask]  # value = <TypeMask.kAffine_Mask: 4>
    kCenter_ScaleToFit: typing.ClassVar[
        Matrix.ScaleToFit
    ]  # value = <ScaleToFit.kCenter_ScaleToFit: 2>
    kEnd_ScaleToFit: typing.ClassVar[
        Matrix.ScaleToFit
    ]  # value = <ScaleToFit.kEnd_ScaleToFit: 3>
    kFill_ScaleToFit: typing.ClassVar[
        Matrix.ScaleToFit
    ]  # value = <ScaleToFit.kFill_ScaleToFit: 0>
    kIdentity_Mask: typing.ClassVar[
        Matrix.TypeMask
    ]  # value = <TypeMask.kIdentity_Mask: 0>
    kMPersp0: typing.ClassVar[int] = 6
    kMPersp1: typing.ClassVar[int] = 7
    kMPersp2: typing.ClassVar[int] = 8
    kMScaleX: typing.ClassVar[int] = 0
    kMScaleY: typing.ClassVar[int] = 4
    kMSkewX: typing.ClassVar[int] = 1
    kMSkewY: typing.ClassVar[int] = 3
    kMTransX: typing.ClassVar[int] = 2
    kMTransY: typing.ClassVar[int] = 5
    kPerspective_Mask: typing.ClassVar[
        Matrix.TypeMask
    ]  # value = <TypeMask.kPerspective_Mask: 8>
    kScale_Mask: typing.ClassVar[Matrix.TypeMask]  # value = <TypeMask.kScale_Mask: 2>
    kStart_ScaleToFit: typing.ClassVar[
        Matrix.ScaleToFit
    ]  # value = <ScaleToFit.kStart_ScaleToFit: 1>
    kTranslate_Mask: typing.ClassVar[
        Matrix.TypeMask
    ]  # value = <TypeMask.kTranslate_Mask: 1>
    @staticmethod
    def Concat(a: Matrix, b: Matrix) -> Matrix:
        """
        Returns :py:class:`Matrix` a multiplied by :py:class:`Matrix` b.

        Given::

                | A B C |      | J K L |
            a = | D E F |, b = | M N O |
                | G H I |      | P Q R |

        sets :py:class:`Matrix` to::

                    | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
            a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                    | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |

        :param skia.Matrix a: :py:class:`Matrix` on left side of multiply
            expression
        :param skia.Matrix b: :py:class:`Matrix` on right side of multiply
            expression
        :return: :py:class:`Matrix` computed from a times b
        """
    @staticmethod
    def I() -> Matrix:
        """
        Returns reference to const identity :py:class:`Matrix`.

        Returned :py:class:`Matrix` is set to:

            | 1 0 0 |
            | 0 1 0 |
            | 0 0 1 |

        :return: const identity :py:class:`Matrix`
        """
    @staticmethod
    def InvalidMatrix() -> Matrix:
        """
        Returns reference to a const :py:class:`Matrix` with invalid values.

        Returned :py:class:`Matrix` is set to:

            | SK_ScalarMax SK_ScalarMax SK_ScalarMax |
            | SK_ScalarMax SK_ScalarMax SK_ScalarMax |
            | SK_ScalarMax SK_ScalarMax SK_ScalarMax |

        :return: const invalid :py:class:`Matrix`
        """
    @staticmethod
    def MakeAll(
        scaleX: float,
        skewX: float,
        transX: float,
        skewY: float,
        scaleY: float,
        transY: float,
        pers0: float,
        pers1: float,
        pers2: float,
    ) -> Matrix:
        """
        Sets :py:class:`Matrix` to::

            | scaleX skewX transX |
            | skewY scaleY transY |
            | pers0  pers1  pers2 |

        :param float scaleX:  horizontal scale factor
        :param float skewX:   horizontal skew factor
        :param float transX:  horizontal translation
        :param float skewY:   vertical skew factor
        :param float scaleY:  vertical scale factor
        :param float transY:  vertical translation
        :param float pers0:   input x-axis perspective factor
        :param float pers1:   input y-axis perspective factor
        :param float pers2:   perspective scale factor
        :return: :py:class:`Matrix` constructed from parameters
        """
    @staticmethod
    def MakeRectToRect(src: Rect, dst: Rect, stf: Matrix.ScaleToFit) -> Matrix:
        """
        Returns :py:class:`Matrix` set to scale and translate src
        :py:class:`Rect` to dst :py:class:`Rect`.

        stf selects whether mapping completely fills dst or preserves the aspect
        ratio, and how to align src within dst. Returns the identity
        :py:class:`Matrix` if src is empty. If dst is empty, returns
        :py:class:`Matrix` set to::

            | 0 0 0 |
            | 0 0 0 |
            | 0 0 1 |

        :param skia.Rect src: :py:class:`Rect` to map from
        :param skia.Rect dst: :py:class:`Rect` to map to
        :param skia.Matrix.ScaleToFit stf: fill option
        :return: :py:class:`Matrix` mapping src to dst
        """
    @staticmethod
    @typing.overload
    def RotateDeg(deg: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate by ``|deg|`` about a pivot point at
        (0, 0).

        :param deg: rotation angle in degrees (positive rotates clockwise)
        :return: :py:class:`Matrix` with rotation
        """
    @staticmethod
    @typing.overload
    def RotateDeg(deg: float, pt: Point) -> Matrix: ...
    @staticmethod
    def RotateRad(rad: float) -> Matrix: ...
    @staticmethod
    def Scale(sx: float, sy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to scale by (sx, sy).

        Returned matrix is:

            | sx 0 0 |
            | 0 sy 0 |
            | 0  0 1 |

        :param float sx: horizontal scale factor
        :param float sy: vertical scale factor
        :return: :py:class:`Matrix` with scale
        """
    @staticmethod
    def SetAffineIdentity() -> list[float]:
        """
        Fills affine with identity values in column major order.

        Sets affine to:

            | 1 0 0 |
            | 0 1 0 |

        Affine 3 by 2 matrices in column major order are used by OpenGL and XPS.

        :return: List of float
        """
    @staticmethod
    @typing.overload
    def Translate(dx: float, dy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to translate by (dx, dy).

        Returned matrix is:

            | 1 0 dx |
            | 0 1 dy |
            | 0 0  1 |

        :dx: horizontal translation
        :dy: vertical translation
        :return: :py:class:`Matrix` with translation
        """
    @staticmethod
    @typing.overload
    def Translate(t: Point) -> Matrix: ...
    @staticmethod
    @typing.overload
    def Translate(t: IPoint) -> Matrix: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __getitem__(self, index: int) -> float:
        """
        Returns one matrix value.

        Asserts if index is out of range and SK_DEBUG is defined.

        :param int index: one of: kMScaleX, kMSkewX, kMTransX, kMSkewY,
            kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2
        :return: value corresponding to index
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Creates an identity :py:class:`Matrix`::

            | 1 0 0 |
            | 0 1 0 |
            | 0 0 1 |
        """
    @typing.overload
    def __init__(
        self,
        array: numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]],
    ) -> None:
        """
        Creates a :py:class:`Matrix` from 3x3 float32 NumPy array.
        """
    def __setitem__(self, index: int, value: float) -> None:
        """
        Returns writable :py:class:`Matrix` value.

        Asserts if index is out of range and SK_DEBUG is defined. Clears
        internal cache anticipating that caller will change :py:class:`Matrix`
        value.

        Next call to read :py:class:`Matrix` state may recompute cache;
        subsequent writes to :py:class:`Matrix` value must be followed by
        :py:meth:`dirtyMatrixTypeCache`.

        :param int index: one of: kMScaleX, kMSkewX, kMTransX, kMSkewY,
            kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2
        :param value: value to set
        """
    def asAffine(self) -> typing.Any:
        """
        Fills affine in column major order.

        Sets affine to::

            | scale-x skew-x translate-x | | skew-y scale-y translate-y |

        If :py:class:`Matrix` contains perspective, returns None.

        :return: list of float if :py:class:`Matrix` does not contain
            perspective, else None
        """
    def decomposeScale(self, scale: Size, remaining: Matrix) -> bool:
        """
        Decomposes :py:class:`Matrix` into scale components and whatever
        remains.

        Returns false if :py:class:`Matrix` could not be decomposed.

        Sets scale to portion of :py:class:`Matrix` that scale axes. Sets
        remaining to :py:class:`Matrix` with scaling factored out. remaining may
        be passed as nullptr to determine if :py:class:`Matrix` can be
        decomposed without computing remainder.

        Returns true if scale components are found. scale and remaining are
        unchanged if :py:class:`Matrix` contains perspective; scale factors are
        not finite, or are nearly zero.

        On success: Matrix = Remaining * scale.

        :param skia.Size scale: axes scaling factors; may be nullptr
        :param skia.Matrix remaining: :py:class:`Matrix` without scaling; may be
            nullptr
        :return: true if scale can be computed
        """
    def dirtyMatrixTypeCache(self) -> None:
        """
        Sets internal cache to unknown state.

        Use to force update after repeated modifications to :py:class:`Matrix`
        element reference returned by operator[](int index).
        """
    def dump(self) -> None:
        """
        Writes text representation of :py:class:`Matrix` to standard output.

        Floating point values are written with limited precision; it may not be
        possible to reconstruct original :py:class:`Matrix` from output.
        """
    def get(self, index: int) -> float:
        """
        Returns one matrix value.

        Asserts if index is out of range and SK_DEBUG is defined.

        :param int index: one of: kMScaleX, kMSkewX, kMTransX, kMSkewY,
            kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2
        :return: value corresponding to index
        """
    def get9(self) -> list[float]:
        """
        Returns nine scalar values contained by :py:class:`Matrix` into list,
        in member value ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY,
        kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2.
        """
    def getMaxScale(self) -> float:
        """
        Returns the maximum scaling factor of :py:class:`Matrix` by decomposing
        the scaling and skewing elements.

        Returns -1 if scale factor overflows or :py:class:`Matrix` contains
        perspective.

        :return: maximum scale factor
        """
    def getMinMaxScales(self) -> tuple:
        """
        Returns the minimum scaling factor and the maximum scaling factor.

        Scaling factors are computed by decomposing the :py:class:`Matrix`
        scaling and skewing elements.

        Returns (min, max) if scale factors are found; otherwise, returns
        (-1, -1).

        :return: tuple of min and max factors
        """
    def getMinScale(self) -> float:
        """
        Returns the minimum scaling factor of :py:class:`Matrix` by decomposing
        the scaling and skewing elements.

        Returns -1 if scale factor overflows or :py:class:`Matrix` contains
        perspective.

        :return: minimum scale factor
        """
    def getPerspX(self) -> float:
        """
        Returns factor scaling input x-axis relative to input y-axis.

        :return: input x-axis perspective factor
        """
    def getPerspY(self) -> float:
        """
        Returns factor scaling input y-axis relative to input x-axis.

        :return: input y-axis perspective factor
        """
    def getScaleX(self) -> float:
        """
        Returns scale factor multiplied by x-axis input, contributing to x-axis
        output.

        With :py:meth:`mapPoints`, scales :py:class:`Point` along the x-axis.

        :return: horizontal scale factor
        """
    def getScaleY(self) -> float:
        """
        Returns scale factor multiplied by y-axis input, contributing to y-axis
        output.

        With :py:meth:`mapPoints`, scales :py:class:`Point` along the y-axis.

        :return: vertical scale factor
        """
    def getSkewX(self) -> float:
        """
        Returns scale factor multiplied by y-axis input, contributing to x-axis
        output.

        With :py:meth:`mapPoints`, skews :py:class:`Point` along the x-axis.
        Skewing both axes can rotate :py:class:`Point`.

        :return: horizontal scale factor
        """
    def getSkewY(self) -> float:
        """
        Returns scale factor multiplied by x-axis input, contributing to y-axis
        output.

        With :py:meth:`mapPoints`, skews :py:class:`Point` along the y-axis.
        Skewing both axes can rotate :py:class:`Point`.

        :return: vertical skew factor
        """
    def getTranslateX(self) -> float:
        """
        Returns translation contributing to x-axis output.

        With :py:meth:`mapPoints`, moves :py:class:`Point` along the x-axis.

        :return: horizontal translation factor
        """
    def getTranslateY(self) -> float:
        """
        Returns translation contributing to y-axis output.

        With :py:meth:`mapPoints`, moves :py:class:`Point` along the y-axis.

        :return: vertical translation factor
        """
    def getType(self) -> Matrix.TypeMask:
        """
        Returns a bit field describing the transformations the matrix may
        perform.

        The bit field is computed conservatively, so it may include false
        positives. For example, when kPerspective_Mask is set, all other bits
        are set.

        :return: kIdentity_Mask, or combinations of: kTranslate_Mask,
            kScale_Mask, kAffine_Mask, kPerspective_Mask
        """
    def hasPerspective(self) -> bool:
        """
        Returns true if the matrix contains perspective elements.

        :py:class:`Matrix` form is::

            |    |
            |    |
            | perspective-x perspective-y perspective-scale |

        where perspective-x or perspective-y is non-zero, or perspective-scale
        is not one. All other elements may have any value.

        :return: true if :py:class:`Matrix` is in most general form
        """
    def invert(self, inverse: Matrix) -> bool:
        """
        Sets inverse to reciprocal matrix, returning true if :py:class:`Matrix`
        can be inverted.

        Geometrically, if :py:class:`Matrix` maps from source to destination,
        inverse :py:class:`Matrix` maps from destination to source. If
        :py:class:`Matrix` can not be inverted, inverse is unchanged.

        :param skia.Matrix inverse: storage for inverted :py:class:`Matrix`; may
            be nullptr
        :return: true if :py:class:`Matrix` can be inverted
        """
    def isFinite(self) -> bool:
        """
        Returns true if all elements of the matrix are finite.

        Returns false if any element is infinity, or NaN.

        :return: true if matrix has only finite elements
        """
    def isIdentity(self) -> bool:
        """
        Returns true if :py:class:`Matrix` is identity.

        Identity matrix is::

            | 1 0 0 |
            | 0 1 0 |
            | 0 0 1 |

        :return: true if :py:class:`Matrix` has no effect
        """
    def isScaleTranslate(self) -> bool:
        """
        Returns true if :py:class:`Matrix` at most scales and translates.

        :py:class:`Matrix` may be identity, contain only scale elements, only
        translate elements, or both. :py:class:`Matrix` form is::

            | scale-x    0    translate-x |
            |    0    scale-y translate-y |
            |    0       0         1      |

        :return: true if :py:class:`Matrix` is identity; or scales, translates,
            or both
        """
    def isSimilarity(self, tol: float = ...) -> bool:
        """
        Returns true if :py:class:`Matrix` contains only translation, rotation,
        reflection, and uniform scale.

        Returns false if :py:class:`Matrix` contains different scales, skewing,
        perspective, or degenerate forms that collapse to a line or point.

        Describes that the :py:class:`Matrix` makes rendering with and without
        the matrix are visually alike; a transformed circle remains a circle.
        Mathematically, this is referred to as similarity of a Euclidean space,
        or a similarity transformation.

        Preserves right angles, keeping the arms of the angle equal lengths.

        :param float tol: to be deprecated
        :return: true if :py:class:`Matrix` only rotates, uniformly scales,
            translates
        """
    def isTranslate(self) -> bool:
        """
        Returns true if :py:class:`Matrix` is identity, or translates.

        :py:class:`Matrix` form is::

            | 1 0 translate-x | | 0 1 translate-y | | 0 0 1 |

        :return: true if :py:class:`Matrix` is identity, or translates
        """
    @typing.overload
    def mapHomogeneousPoints(self, pts: list[Point3]) -> typing.Any:
        """
        Takes src :py:class:`Point3` array and returns mapped :py:class:`Point3`
        array.

        :py:class:`Point3` array is mapped by multiplying each
        :py:class:`Point3` by :py:class:`Matrix`. Given::

                     | A B C |        | x |
            Matrix = | D E F |, src = | y |
                     | G H I |        | z |

        each resulting dst :py:class:`Point` is computed as::

                           |A B C| |x|
            Matrix * src = |D E F| |y| = |Ax+By+Cz Dx+Ey+Fz Gx+Hy+Iz|
                           |G H I| |z|

        :pts: :py:class:`Point3` array to transform
        """
    @typing.overload
    def mapHomogeneousPoints(self, pts: list[Point]) -> typing.Any:
        """
        Returns homogeneous points, starting with 2D src points (with implied w
        = 1).

        :pts: :py:class:`Point` array to transform
        """
    def mapPoints(self, pts: list[Point]) -> list[Point]:
        """
        Takes src :py:class:`Point` array and returns mapped :py:class:`Point`
        array.

        :py:class:`Point` are mapped by multiplying each :py:class:`Point` by
        :py:class:`Matrix`. Given::

                     | A B C |       | x |
            Matrix = | D E F |, pt = | y |
                     | G H I |       | 1 |

        where::

            for (i = 0; i < count; ++i) {
                x = src[i].fX
                y = src[i].fY
            }

        each dst :py:class:`Point` is computed as::

                          |A B C| |x|                               Ax+By+C   Dx+Ey+F
            Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
                          |G H I| |1|                               Gx+Hy+I   Gx+Hy+I

        :param List[skia.Point] src: list of :py:class:`Point` to transform
        """
    def mapRadius(self, radius: float) -> float:
        """
        Returns geometric mean radius of ellipse formed by constructing circle
        of size radius, and mapping constructed circle with :py:class:`Matrix`.

        The result squared is equal to the major axis length times the minor
        axis length. Result is not meaningful if :py:class:`Matrix` contains
        perspective elements.

        :param radius: circle size to map
        :return: average mapped radius
        """
    def mapRect(self, src: Rect, pc: ApplyPerspectiveClip = ...) -> Rect:
        """
        Returns bounds of src corners mapped by :py:class:`Matrix`.

        :param skia.Rect src: rectangle to map
        :param skia.ApplyPerspectiveClip pc: whether to apply perspective
            clipping
        :return: mapped bounds
        """
    def mapRectScaleTranslate(self, src: Rect) -> Rect:
        """
        Returns bounds of src corners mapped by :py:class:`Matrix`.

        If matrix contains elements other than scale or translate: asserts if
        SK_DEBUG is defined; otherwise, results are undefined.

        :param skia.Rect src: :py:class:`Rect` to map
        """
    def mapRectToQuad(self, rect: Rect) -> list[Point]:
        """
        Maps four corners of rect to dst.

        :py:class:`Point` are mapped by multiplying each rect corner by
        :py:class:`Matrix`. rect corner is processed in this order: (rect.fLeft,
        rect.fTop), (rect.fRight, rect.fTop), (rect.fRight, rect.fBottom),
        (rect.fLeft, rect.fBottom).

        rect may be empty: rect.fLeft may be greater than or equal to
        rect.fRight; rect.fTop may be greater than or equal to rect.fBottom.

        Given::

                     | A B C |        | x |
            Matrix = | D E F |,  pt = | y |
                     | G H I |        | 1 |

        where pt is initialized from each of (rect.fLeft, rect.fTop),
        (rect.fRight, rect.fTop), (rect.fRight, rect.fBottom), (rect.fLeft,
        rect.fBottom), each dst :py:class:`Point` is computed as::

                          |A B C| |x|                               Ax+By+C   Dx+Ey+F
            Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
                          |G H I| |1|                               Gx+Hy+I   Gx+Hy+I

        :param skia.Rect rect: :py:class:`Rect` to map

        Note: this does not perform perspective clipping (as that might result
        in more than 4 points, so results are suspect if the matrix contains
        perspective.
        """
    def mapVector(self, dx: float, dy: float) -> Point:
        """
        Returns vector (dx, dy) multiplied by :py:class:`Matrix`, treating
        :py:class:`Matrix` translation as zero.

        Given::

                     | A B 0 |         | dx |
            Matrix = | D E 0 |,  vec = | dy |
                     | G H I |         |  1 |

        each result vector is computed as::

                           |A B 0| |dx|                                       A*dx+B*dy    D*dx+E*dy
            Matrix * vec = |D E 0| |dy| = |A*dx+B*dy D*dx+E*dy G*dx+H*dy+I| = ----------, ----------
                           |G H I| | 1|                                       G*dx+H*dy+I  G*dx+*dHy+I

        :param float dx: x-axis value of vector to map
        :param float dy: y-axis value of vector to map
        :return: mapped vector
        """
    def mapVectors(self, src: list[Point]) -> list[Point]:
        """
        Maps src vector array to vector :py:class:`Point` array.

        Vectors are mapped by multiplying each vector by :py:class:`Matrix`,
        treating :py:class:`Matrix` translation as zero. Given::

                     | A B 0 |         | x |
            Matrix = | D E 0 |,  src = | y |
                     | G H I |         | 1 |

        where::

            for (i = 0; i < count; ++i) {
                x = src[i].fX
                y = src[i].fY
            }

        each dst vector is computed as::

                           |A B 0| |x|                            Ax+By     Dx+Ey
            Matrix * src = |D E 0| |y| = |Ax+By Dx+Ey Gx+Hy+I| = ------- , -------
                           |G H I| |1|                           Gx+Hy+I   Gx+Hy+I

        :param List[skia.Point] src: vectors to transform
        """
    def mapXY(self, x: float, y: float) -> Point:
        """
        Returns :py:class:`Point` (x, y) multiplied by :py:class:`Matrix`.

        Given::

                     | A B C |       | x |
            Matrix = | D E F |, pt = | y |
                     | G H I |       | 1 |

        result is computed as::

                          |A B C| |x|                               Ax+By+C   Dx+Ey+F
            Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
                          |G H I| |1|                               Gx+Hy+I   Gx+Hy+I

        :param float x: x-axis value of :py:class:`Point` to map
        :param float y: y-axis value of :py:class:`Point` to map
        :return: mapped :py:class:`Point`
        """
    def normalizePerspective(self) -> None:
        """
        A matrix is categorized as 'perspective' if the bottom row is not
        [0, 0, 1].

        However, for most uses (e.g. mapPoints) a bottom row of [0, 0, X]
        behaves like a non-perspective matrix, though it will be categorized as
        perspective. Calling :py:meth:`normalizePerspective` will change the
        matrix such that, if its bottom row was [0, 0, X], it will be changed to
        [0, 0, 1] by scaling the rest of the matrix by 1/X::

            | A B C | | A/X B/X C/X | | D E F | -> \\
            | D/X E/X F/X | for X != 0 | 0 0 X | | 0 0 1 |
        """
    def postConcat(self, other: Matrix) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` other multiplied by
        :py:class:`Matrix`.

        This can be thought of mapping by other after applying
        :py:class:`Matrix`.

        Given::

                     | J K L |           | A B C |
            Matrix = | M N O |,  other = | D E F |
                     | P Q R |           | G H I |

        sets :py:class:`Matrix` to::

                             | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
            other * Matrix = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                             | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |

        :param skia.Matrix other: :py:class:`Matrix` on left side of multiply
            expression
        """
    @typing.overload
    def postRotate(self, degrees: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from rotating
        by degrees about pivot point (px, py), multiplied by :py:class:`Matrix`.

        This can be thought of as rotating about a pivot point after applying
        :py:class:`Matrix`.

        Positive degrees rotates clockwise.

        Given::

                     | J K L |                        | c -s dx |
            Matrix = | M N O |,  R(degrees, px, py) = | s  c dy |
                     | P Q R |                        | 0  0  1 |

        where::

            c = cos(degrees)
            s = sin(degrees)
            dx = s * py + (1 - c) * px
            dy = -s * px + (1 - c) * py

        sets :py:class:`Matrix` to::

                                          |c -s dx| |J K L|   |cJ-sM+dx*P cK-sN+dx*Q cL-sO+dx+R|
            R(degrees, px, py) * Matrix = |s  c dy| |M N O| = |sJ+cM+dy*P sK+cN+dy*Q sL+cO+dy*R|
                                          |0  0  1| |P Q R|   |         P          Q          R|

        :degrees: angle of axes relative to upright axes
        :px:  pivot on x-axis
        :py:  pivot on y-axis
        """
    @typing.overload
    def postRotate(self, degrees: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from rotating
        by degrees about pivot point (0, 0), multiplied by :py:class:`Matrix`.

        This can be thought of as rotating about the origin after applying
        :py:class:`Matrix`.

        Positive degrees rotates clockwise.

        Given::

                     | J K L |                        | c -s 0 |
            Matrix = | M N O |,  R(degrees, px, py) = | s  c 0 |
                     | P Q R |                        | 0  0 1 |

        where::

            c = cos(degrees)
            s = sin(degrees)

        sets :py:class:`Matrix` to::

                                          | c -s dx | | J K L |   | cJ-sM cK-sN cL-sO |
            R(degrees, px, py) * Matrix = | s  c dy | | M N O | = | sJ+cM sK+cN sL+cO |
                                          | 0  0  1 | | P Q R |   |     P     Q     R |

        :degrees: angle of axes relative to upright axes
        """
    @typing.overload
    def postScale(self, sx: float, sy: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from scaling
        by (sx, sy) about pivot point (px, py), multiplied by
        :py:class:`Matrix`.

        This can be thought of as scaling about a pivot point after applying :py:class:`Matrix`.

        Given::

                     | J K L |                       | sx  0 dx |
            Matrix = | M N O |,  S(sx, sy, px, py) = |  0 sy dy |
                     | P Q R |                       |  0  0  1 |

        where::

            dx = px - sx * px
            dy = py - sy * py

        sets :py:class:`Matrix` to::

                                         | sx  0 dx | | J K L |   | sx*J+dx*P sx*K+dx*Q sx*L+dx+R |
            S(sx, sy, px, py) * Matrix = |  0 sy dy | | M N O | = | sy*M+dy*P sy*N+dy*Q sy*O+dy*R |
                                         |  0  0  1 | | P Q R |   |         P         Q         R |

        :sx: horizontal scale factor
        :sy: vertical scale factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def postScale(self, sx: float, sy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from scaling
        by (sx, sy) about pivot point (0, 0), multiplied by :py:class:`Matrix`.

        This can be thought of as scaling about the origin after applying
        :py:class:`Matrix`.

        Given::

                     | J K L |               | sx  0  0 |
            Matrix = | M N O |,  S(sx, sy) = |  0 sy  0 |
                     | P Q R |               |  0  0  1 |

        sets :py:class:`Matrix` to::

                                 | sx  0  0 | | J K L |   | sx*J sx*K sx*L |
            S(sx, sy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |
                                 |  0  0  1 | | P Q R |   |    P    Q    R |

        :sx: horizontal scale factor
        :sy: vertical scale factor
        """
    @typing.overload
    def postSkew(self, kx: float, ky: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from skewing
        by (kx, ky) about pivot point (px, py), multiplied by
        :py:class:`Matrix`.

        This can be thought of as skewing about a pivot point after applying
        :py:class:`Matrix`.

        Given::

                     | J K L |                       |  1 kx dx |
            Matrix = | M N O |,  K(kx, ky, px, py) = | ky  1 dy |
                     | P Q R |                       |  0  0  1 |

        where::

            dx = -kx * py
            dy = -ky * px

        sets :py:class:`Matrix` to::

                                         | 1 kx dx| |J K L|   |J+kx*M+dx*P K+kx*N+dx*Q L+kx*O+dx+R|
            K(kx, ky, px, py) * Matrix = |ky  1 dy| |M N O| = |ky*J+M+dy*P ky*K+N+dy*Q ky*L+O+dy*R|
                                         | 0  0  1| |P Q R|   |          P           Q           R|

        :kx: horizontal skew factor
        :ky: vertical skew factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def postSkew(self, kx: float, ky: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from skewing
        by (kx, ky) about pivot point (0, 0), multiplied by :py:class:`Matrix`.

        This can be thought of as skewing about the origin after applying
        :py:class:`Matrix`.

        Given::

                     | J K L |               |  1 kx 0 |
            Matrix = | M N O |,  K(kx, ky) = | ky  1 0 |
                     | P Q R |               |  0  0 1 |

        sets :py:class:`Matrix` to::

                                 |  1 kx 0 | | J K L |   | J+kx*M K+kx*N L+kx*O |
            K(kx, ky) * Matrix = | ky  1 0 | | M N O | = | ky*J+M ky*K+N ky*L+O |
                                 |  0  0 1 | | P Q R |   |      P      Q      R |

        :kx: horizontal skew factor
        :ky: vertical skew factor
        """
    def postTranslate(self, dx: float, dy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` constructed from
        translation (dx, dy) multiplied by :py:class:`Matrix`.

        This can be thought of as moving the point to be mapped after applying
        :py:class:`Matrix`.

        Given::

                     | J K L |               | 1 0 dx |
            Matrix = | M N O |,  T(dx, dy) = | 0 1 dy |
                     | P Q R |               | 0 0  1 |

        sets :py:class:`Matrix` to::

                                 | 1 0 dx | | J K L |   | J+dx*P K+dx*Q L+dx*R |
            T(dx, dy) * Matrix = | 0 1 dy | | M N O | = | M+dy*P N+dy*Q O+dy*R |
                                 | 0 0  1 | | P Q R |   |      P      Q      R |

        :param float dx: x-axis translation after applying :py:class:`Matrix`
        :param float dy: y-axis translation after applying :py:class:`Matrix`
        """
    def preConcat(self, other: Matrix) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` other.

        This can be thought of mapping by other before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |          | J K L |
            Matrix = | D E F |, other = | M N O |
                     | G H I |          | P Q R |

        sets :py:class:`Matrix` to::

                             | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
            Matrix * other = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                             | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |

        :param skia.Matrix other: :py:class:`Matrix` on right side of multiply
            expression
        """
    @typing.overload
    def preRotate(self, degrees: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from rotating by degrees about pivot
        point (px, py).

        This can be thought of as rotating about a pivot point before applying
        :py:class:`Matrix`.

        Positive degrees rotates clockwise.

        Given::

                     | A B C |                        | c -s dx |
            Matrix = | D E F |,  R(degrees, px, py) = | s  c dy |
                     | G H I |                        | 0  0  1 |

        where::

            c = cos(degrees)
            s = sin(degrees)
            dx = s * py + (1 - c) * px
            dy = -s * px + (1 - c) * py

        sets :py:class:`Matrix` to::

                                          | A B C | | c -s dx |   | Ac+Bs -As+Bc A*dx+B*dy+C |
            Matrix * R(degrees, px, py) = | D E F | | s  c dy | = | Dc+Es -Ds+Ec D*dx+E*dy+F |
                                          | G H I | | 0  0  1 |   | Gc+Hs -Gs+Hc G*dx+H*dy+I |

        :degrees: angle of axes relative to upright axes
        :px:  pivot on x-axis
        :py:  pivot on y-axis
        """
    @typing.overload
    def preRotate(self, degrees: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from rotating by degrees about pivot
        point (0, 0).

        This can be thought of as rotating about the origin before applying
        :py:class:`Matrix`.

        Positive degrees rotates clockwise.

        Given::

                     | A B C |                        | c -s 0 |
            Matrix = | D E F |,  R(degrees, px, py) = | s  c 0 |
                     | G H I |                        | 0  0 1 |

        where::

            c = cos(degrees)
            s = sin(degrees)

        sets :py:class:`Matrix` to::

                                          | A B C | | c -s 0 |   | Ac+Bs -As+Bc C |
            Matrix * R(degrees, px, py) = | D E F | | s  c 0 | = | Dc+Es -Ds+Ec F |
                                          | G H I | | 0  0 1 |   | Gc+Hs -Gs+Hc I |

        :degrees: angle of axes relative to upright axes
        """
    @typing.overload
    def preScale(self, sx: float, sy: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from scaling by (sx, sy) about pivot
        point (px, py).

        This can be thought of as scaling about a pivot point before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |                       | sx  0 dx |
            Matrix = | D E F |,  S(sx, sy, px, py) = |  0 sy dy |
                     | G H I |                       |  0  0  1 |

        where::

            dx = px - sx * px
            dy = py - sy * py

        sets :py:class:`Matrix` to::

                                         | A B C | | sx  0 dx |   | A*sx B*sy A*dx+B*dy+C |
            Matrix * S(sx, sy, px, py) = | D E F | |  0 sy dy | = | D*sx E*sy D*dx+E*dy+F |
                                         | G H I | |  0  0  1 |   | G*sx H*sy G*dx+H*dy+I |

        :sx: horizontal scale factor
        :sy: vertical scale factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def preScale(self, sx: float, sy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from scaling by (sx, sy) about pivot
        point (0, 0).

        This can be thought of as scaling about the origin before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |               | sx  0  0 |
            Matrix = | D E F |,  S(sx, sy) = |  0 sy  0 |
                     | G H I |               |  0  0  1 |

        sets :py:class:`Matrix` to::

                                 | A B C | | sx  0  0 |   | A*sx B*sy C |
            Matrix * S(sx, sy) = | D E F | |  0 sy  0 | = | D*sx E*sy F |
                                 | G H I | |  0  0  1 |   | G*sx H*sy I |

        :sx: horizontal scale factor
        :sy: vertical scale factor
        """
    @typing.overload
    def preSkew(self, kx: float, ky: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from skewing by (kx, ky) about pivot
        point (px, py).

        This can be thought of as skewing about a pivot point before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |                       |  1 kx dx |
            Matrix = | D E F |,  K(kx, ky, px, py) = | ky  1 dy |
                     | G H I |                       |  0  0  1 |

        where::

            dx = -kx * py
            dy = -ky * px

        sets :py:class:`Matrix` to::

                                         | A B C | |  1 kx dx |   | A+B*ky A*kx+B A*dx+B*dy+C |
            Matrix * K(kx, ky, px, py) = | D E F | | ky  1 dy | = | D+E*ky D*kx+E D*dx+E*dy+F |
                                         | G H I | |  0  0  1 |   | G+H*ky G*kx+H G*dx+H*dy+I |

        :kx: horizontal skew factor
        :ky: vertical skew factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def preSkew(self, kx: float, ky: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from skewing by (kx, ky) about pivot
        point (0, 0).

        This can be thought of as skewing about the origin before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |               |  1 kx 0 |
            Matrix = | D E F |,  K(kx, ky) = | ky  1 0 |
                     | G H I |               |  0  0 1 |

        sets :py:class:`Matrix` to::

                                 | A B C | |  1 kx 0 |   | A+B*ky A*kx+B C |
            Matrix * K(kx, ky) = | D E F | | ky  1 0 | = | D+E*ky D*kx+E F |
                                 | G H I | |  0  0 1 |   | G+H*ky G*kx+H I |

        :kx: horizontal skew factor
        :ky: vertical skew factor
        """
    def preTranslate(self, dx: float, dy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` multiplied by
        :py:class:`Matrix` constructed from translation (dx, dy).

        This can be thought of as moving the point to be mapped before applying
        :py:class:`Matrix`.

        Given::

                     | A B C |               | 1 0 dx |
            Matrix = | D E F |,  T(dx, dy) = | 0 1 dy |
                     | G H I |               | 0 0  1 |

        sets :py:class:`Matrix` to::

                                 | A B C | | 1 0 dx |   | A B A*dx+B*dy+C |
            Matrix * T(dx, dy) = | D E F | | 0 1 dy | = | D E D*dx+E*dy+F |
                                 | G H I | | 0 0  1 |   | G H G*dx+H*dy+I |

        :param dx: x-axis translation before applying :py:class:`Matrix`
        :param dy: y-axis translation before applying :py:class:`Matrix`
        """
    def preservesAxisAlignment(self) -> bool:
        """
        Returns true :py:class:`Matrix` maps :py:class:`Rect` to another
        :py:class:`Rect`.

        If true, :py:class:`Matrix` is identity, or scales, or rotates a
        multiple of 90 degrees, or mirrors on axes. In all cases,
        :py:class:`Matrix` may also have translation. :py:class:`Matrix` form is
        either::

            | scale-x    0    translate-x |
            |    0    scale-y translate-y |
            |    0       0         1      |

        or::

            |    0     rotate-x translate-x |
            | rotate-y    0     translate-y |
            |    0        0          1      |

        for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.

        Also called :py:meth:`rectStaysRect`; use the one that provides better
        inline documentation.

        :return: true if :py:class:`Matrix` maps one :py:class:`Rect` into
            another
        """
    def preservesRightAngles(self, tol: float = ...) -> bool:
        """
        Returns true if :py:class:`Matrix` contains only translation, rotation,
        reflection, and scale.

        Scale may differ along rotated axes. Returns false if :py:class:`Matrix`
        skewing, perspective, or degenerate forms that collapse to a line or
        point.

        Preserves right angles, but not requiring that the arms of the angle
        retain equal lengths.

        :param float tol: to be deprecated
        :return: true if :py:class:`Matrix` only rotates, scales, translates
        """
    def rc(self, r: int, c: int) -> float:
        """
        Returns one matrix value from a particular row/column. Asserts if index
        is out of range and SK_DEBUG is defined.

        :param r:  matrix row to fetch
        :param c:  matrix column to fetch
        :return:   value at the given matrix position
        """
    def rectStaysRect(self) -> bool:
        """
        Returns true SkMatrix maps SkRect to another SkRect.

        If true, :py:class:`Matrix` is identity, or scales, or rotates a
        multiple of 90 degrees, or mirrors on axes. In all cases,
        :py:class:`Matrix` may also have translation. :py:class:`Matrix` form is
        either::

            | scale-x    0    translate-x |
            |    0    scale-y translate-y |
            |    0       0         1      |

        or::

            |    0     rotate-x translate-x |
            | rotate-y    0     translate-y |
            |    0        0          1      |
            for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.

        Also called :py:meth:`preservesAxisAlignment`; use the one that provides
        better inline documentation.

        :return: true if :py:class:`Matrix` maps one :py:class:`Rect` into
            another
        """
    def reset(self) -> Matrix:
        """
        Sets :py:class:`Matrix` to identity; which has no effect on mapped
        :py:class:`Point`.

        Sets :py:class:`Matrix` to::

            | 1 0 0 |
            | 0 1 0 |
            | 0 0 1 |

        Also called :py:meth:`setIdentity`; use the one that provides better
        inline documentation.
        """
    def set(self, index: int, value: float) -> None:
        """
        Returns writable :py:class:`Matrix` value.

        Asserts if index is out of range and SK_DEBUG is defined. Clears
        internal cache anticipating that caller will change :py:class:`Matrix`
        value.

        Next call to read :py:class:`Matrix` state may recompute cache;
        subsequent writes to :py:class:`Matrix` value must be followed by
        :py:meth:`dirtyMatrixTypeCache`.

        :param int index: one of: kMScaleX, kMSkewX, kMTransX, kMSkewY,
            kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2
        :param value: value to set
        """
    def set9(self, buffer: list[float]) -> Matrix:
        """
        Sets :py:class:`Matrix` to nine scalar values in values, in member value
        ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY,
        kMTransY, kMPersp0, kMPersp1, kMPersp2.

        Sets matrix to::

            | values[0] values[1] values[2] |
            | values[3] values[4] values[5] |
            | values[6] values[7] values[8] |

        In the future, set9 followed by get9 may not return the same values.
        Since :py:class:`Matrix` maps non-homogeneous coordinates, scaling all
        nine values produces an equivalent transformation, possibly improving
        precision.

        :param values: nine scalar values
        """
    def setAffine(self, affine: list[float]) -> Matrix:
        """
        Sets :py:class:`Matrix` to affine values, passed in column major order.

        Given affine, column, then row, as::

            | scale-x  skew-x translate-x |
            |  skew-y scale-y translate-y |

        :py:class:`Matrix` is set, row, then column, to::

            | scale-x  skew-x translate-x |
            |  skew-y scale-y translate-y |
            |       0       0           1 |

        :param affine: 3 by 2 affine matrix
        """
    def setAll(
        self,
        scaleX: float,
        skewX: float,
        transX: float,
        skewY: float,
        scaleY: float,
        transY: float,
        persp0: float,
        persp1: float,
        persp2: float,
    ) -> Matrix:
        """
        Sets all values from parameters.

        Sets matrix to::

            | scaleX skewX transX |
            | skewY scaleY transY |
            | persp0 persp1 persp2 |

        :param float scaleX:  horizontal scale factor to store
        :param float skewX:   horizontal skew factor to store
        :param float transX:  horizontal translation to store
        :param float skewY:   vertical skew factor to store
        :param float scaleY:  vertical scale factor to store
        :param float transY:  vertical translation to store
        :param float persp0:  input x-axis values perspective factor to store
        :param float persp1:  input y-axis values perspective factor to store
        :param float persp2:  perspective scale factor to store
        """
    def setConcat(self, a: Matrix, b: Matrix) -> Matrix:
        """
        Sets :py:class:`Matrix` to :py:class:`Matrix` a multiplied by
        :py:class:`Matrix` b.

        Either a or b may be this.

        Given::

                | A B C |      | J K L |
            a = | D E F |, b = | M N O |
                | G H I |      | P Q R |

        sets :py:class:`Matrix` to::

                    | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
            a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                    | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |

        :param skia.Matrix a: :py:class:`Matrix` on left side of multiply
            expression
        :param skia.Matrix b: :py:class:`Matrix` on right side of multiply
            expression
        """
    def setIdentity(self) -> Matrix:
        """
        Sets :py:class:`Matrix` to identity; which has no effect on mapped
        :py:class:`Point`.

        Sets :py:class:`Matrix` to::

            | 1 0 0 |
            | 0 1 0 |
            | 0 0 1 |

        Also called :py:meth:`reset`; use the one that provides better inline
        documentation.
        """
    def setPerspX(self, v: float) -> Matrix:
        """
        Sets input x-axis perspective factor, which causes mapXY() to vary input
        x-axis values inversely proportional to input y-axis values.

        :param float v: perspective factor
        """
    def setPerspY(self, v: float) -> Matrix:
        """
        Sets input y-axis perspective factor, which causes mapXY() to vary input
        y-axis values inversely proportional to input x-axis values.

        :param float v: perspective factor
        """
    def setPolyToPoly(self, src: list[Point], dst: list[Point]) -> bool:
        """
        Sets :py:class:`Matrix` to map src to dst.

        count must be zero or greater, and four or less.

        If count is zero, sets :py:class:`Matrix` to identity and returns true.
        If count is one, sets :py:class:`Matrix` to translate and returns true.
        If count is two or more, sets :py:class:`Matrix` to map
        :py:class:`Point` if possible; returns false if :py:class:`Matrix`
        cannot be constructed. If count is four, :py:class:`Matrix` may include
        perspective.

        :param List[skia.Point] src: :py:class:`Point` to map from
        :param List[skia.Point] dst: :py:class:`Point` to map to
        :return: true if :py:class:`Matrix` was constructed successfully
        """
    def setRSXform(self, rsxForm: RSXform) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate, scale, and translate using a
        compressed matrix form.

        Vector (rsxForm.fSSin, rsxForm.fSCos) describes the angle of rotation
        relative to (0, 1). Vector length specifies scale. Mapped point is
        rotated and scaled by vector, then translated by (rsxForm.fTx,
        rsxForm.fTy).

        :param skia.RSXform rsxForm: compressed :py:class:`RSXform` matrix
        :return: reference to :py:class:`Matrix`
        """
    def setRectToRect(self, src: Rect, dst: Rect, stf: Matrix.ScaleToFit) -> bool:
        """
        Sets :py:class:`Matrix` to scale and translate src :py:class:`Rect` to
        dst :py:class:`Rect`.

        stf selects whether mapping completely fills dst or preserves the aspect
        ratio, and how to align src within dst. Returns false if src is empty,
        and sets :py:class:`Matrix` to identity. Returns true if dst is empty,
        and sets :py:class:`Matrix` to:

            | 0 0 0 |
            | 0 0 0 |
            | 0 0 1 |

        :param skia.Rect src: :py:class:`Rect` to map from
        :param skia.Rect dst: :py:class:`Rect` to map to
        :param skia.Matrix.ScaleToFit stf: mapping method
        :return: true if :py:class:`Matrix` can represent :py:class:`Rect`
            mapping
        """
    @typing.overload
    def setRotate(self, degrees: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate by degrees about a pivot point at (px,
        py).

        The pivot point is unchanged when mapped with :py:class:`Matrix`.

        Positive degrees rotates clockwise.

        :degrees: angle of axes relative to upright axes
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def setRotate(self, degrees: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate by degrees about a pivot point at (0,
        0).

        Positive degrees rotates clockwise.

        :degrees: angle of axes relative to upright axes
        """
    @typing.overload
    def setScale(self, sx: float, sy: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to scale by sx and sy, about a pivot point at
        (px, py).

        The pivot point is unchanged when mapped with :py:class:`Matrix`.

        :sx: horizontal scale factor
        :sy: vertical scale factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def setScale(self, sx: float, sy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to scale by sx and sy about at pivot point at
        (0, 0).

        :sx: horizontal scale factor
        :sy: vertical scale factor
        """
    def setScaleTranslate(self, sx: float, sy: float, tx: float, ty: float) -> None:
        """
        Initializes :py:class:`Matrix` with scale and translate elements.

            | sx 0 tx |
            | 0 sy ty |
            | 0  0  1 |

        :param float sx: horizontal scale factor to store
        :param float sy: vertical scale factor to store
        :param float tx: horizontal translation to store
        :param float ty: vertical translation to store
        """
    def setScaleX(self, v: float) -> Matrix:
        """
        Sets horizontal scale factor.

        :param float v: horizontal scale factor to store
        """
    def setScaleY(self, v: float) -> Matrix:
        """
        Sets vertical scale factor.

        :param float v: vertical scale factor to store
        """
    @typing.overload
    def setSinCos(
        self,
        sinValue: float,
        cosValue: float,
        px: float,
        py: float,
    ) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate by sinValue and cosValue, about a
        pivot point at (px, py).

        The pivot point is unchanged when mapped with :py:class:`Matrix`.

        Vector (sinValue, cosValue) describes the angle of rotation relative to
        (0, 1). Vector length specifies scale.

        :sinValue: rotation vector x-axis component
        :cosValue: rotation vector y-axis component
        :px:  pivot on x-axis
        :py:  pivot on y-axis
        """
    @typing.overload
    def setSinCos(self, sinValue: float, cosValue: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to rotate by sinValue and cosValue, about a
        pivot point at (0, 0).

        Vector (sinValue, cosValue) describes the angle of rotation relative to
        (0, 1). Vector length specifies scale.

        :sinValue: rotation vector x-axis component
        :cosValue: rotation vector y-axis component
        """
    @typing.overload
    def setSkew(self, kx: float, ky: float, px: float, py: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to skew by kx and ky, about a pivot point at
        (px, py).

        The pivot point is unchanged when mapped with :py:class:`Matrix`.

        :kx: horizontal skew factor
        :ky: vertical skew factor
        :px: pivot on x-axis
        :py: pivot on y-axis
        """
    @typing.overload
    def setSkew(self, kx: float, ky: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to skew by kx and ky, about a pivot point at
        (0, 0).

        :kx: horizontal skew factor
        :ky: vertical skew factor
        """
    def setSkewX(self, v: float) -> Matrix:
        """
        Sets horizontal skew factor.

        :param float v: horizontal skew factor to store
        """
    def setSkewY(self, v: float) -> Matrix:
        """
        Sets vertical skew factor.

        :param v: vertical skew factor to store
        """
    @typing.overload
    def setTranslate(self, dx: float, dy: float) -> Matrix:
        """
        Sets :py:class:`Matrix` to translate by (dx, dy).

        :dx: horizontal translation
        :dy: vertical translation
        """
    @typing.overload
    def setTranslate(self, v: Point) -> Matrix:
        """
        Sets :py:class:`Matrix` to translate by (v.fX, v.fY).

        :v: vector containing horizontal and vertical
            translation
        """
    def setTranslateX(self, v: float) -> Matrix:
        """
        Sets horizontal translation.

        :param float v: horizontal translation to store
        """
    def setTranslateY(self, v: float) -> Matrix:
        """
        Sets vertical translation.

        :param float v: vertical translation to store
        """

class MemoryStream(StreamMemory):
    @staticmethod
    def Make(data: Data) -> MemoryStream: ...
    @staticmethod
    def MakeCopy(data: typing_extensions.Buffer) -> MemoryStream: ...
    @staticmethod
    def MakeDirect(data: typing_extensions.Buffer) -> MemoryStream: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, length: int) -> None: ...
    @typing.overload
    def __init__(
        self,
        data: typing_extensions.Buffer,
        copyData: bool = False,
    ) -> None: ...
    @typing.overload
    def __init__(self, data: capsule, length: int, copyData: bool = False) -> None: ...
    @typing.overload
    def __init__(self, data: Data) -> None: ...
    def asData(self) -> Data: ...
    def getAtPos(self) -> capsule: ...
    def setData(self, data: Data) -> None: ...
    def setMemory(
        self,
        data: typing_extensions.Buffer,
        copyData: bool = False,
    ) -> None: ...
    def skipToAlign4(self) -> None: ...

class MipmapBuilder:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self, arg0: ImageInfo) -> None: ...
    def attachTo(self, arg0: Image) -> Image:
        """
        If these levels are compatible with src, return a new Image that
        combines src's base level with these levels as mip levels.

        If not compatible, this returns nullptr.
        """
    def countLevels(self) -> int: ...
    def level(self, arg0: int) -> Pixmap: ...

class MipmapMode:
    """
    Members:

      kNone : ignore mipmap levels, sample from the "base"

      kNearest : sample from the nearest level

      kLinear : interpolate between the two nearest levels
    """

    __members__: typing.ClassVar[
        dict[str, MipmapMode]
    ]  # value = {'kNone': <MipmapMode.kNone: 0>, 'kNearest': <MipmapMode.kNearest: 1>, 'kLinear': <MipmapMode.kLinear: 2>}
    kLinear: typing.ClassVar[MipmapMode]  # value = <MipmapMode.kLinear: 2>
    kNearest: typing.ClassVar[MipmapMode]  # value = <MipmapMode.kNearest: 1>
    kNone: typing.ClassVar[MipmapMode]  # value = <MipmapMode.kNone: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NullWStream(WStream):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class OpBuilder:
    """

    Perform a series of path operations, optimized for unioning many paths together.
    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def add(self, path: Path, op: PathOp) -> None:
        """
        Add one or more paths and their operand.

        The builder is empty before the first path is added, so the result of a
        single add is (emptyPath OP path).

        :param path: The second operand.
        :param op:   The operator to apply to the existing and supplied paths.
        """
    def resolve(self) -> Path:
        """
        Computes the sum of all paths and operands, and resets the builder to
        its initial state.

        :param result:  The product of the operands.
        :return: True if the operation succeeded.
        """

class OverdrawColorFilter:
    """

    Uses the value in the src alpha channel to set the dst pixel.

    0 -> colors[0] 1 -> colors[1] ... 5 (or larger) -> colors[5]

    """

    kNumColors: typing.ClassVar[int] = 6
    @staticmethod
    def MakeWithColors(colors: list[int]) -> ColorFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class PDF:
    class AttributeList:
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self) -> None: ...
        def appendFloat(self, owner: str, name: str, value: float) -> None: ...
        def appendFloatArray(
            self,
            owner: str,
            name: str,
            value: list[float],
        ) -> None: ...
        def appendInt(self, owner: str, name: str, value: int) -> None: ...
        def appendString(self, owner: str, name: str, value: str) -> None: ...
        def appendStringArray(
            self,
            owner: str,
            name: str,
            value: list[int],
        ) -> None: ...

    class Metadata:
        """

        Optional metadata to be passed into the PDF factory function.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: dict) -> None: ...
        @property
        def fAuthor(self) -> String:
            """
            The name of the person who created the document.
            """
        @fAuthor.setter
        def fAuthor(self, arg0: String) -> None: ...
        @property
        def fCreator(self) -> String:
            """
            If the document was converted to PDF from another format,
            the name of the conforming product that created the
            original document from which it was converted.
            """
        @fCreator.setter
        def fCreator(self, arg0: String) -> None: ...
        @property
        def fEncodingQuality(self) -> int:
            """
            Encoding quality controls the trade-off between size and quality. By
            default this is set to 101 percent, which corresponds to lossless
            encoding. If this value is set to a value <= 100, and the image is
            opaque, it will be encoded (using JPEG) with that quality setting.
            """
        @fEncodingQuality.setter
        def fEncodingQuality(self, arg0: int) -> None: ...
        @property
        def fKeywords(self) -> String:
            """
            Keywords associated with the document.  Commas may be used to delineate
            keywords within the string.
            """
        @fKeywords.setter
        def fKeywords(self, arg0: String) -> None: ...
        @property
        def fPDFA(self) -> bool:
            """
            If true, include XMP metadata, a document UUID, and sRGB output intent
            information.  This adds length to the document and makes it
            non-reproducable, but are necessary features for PDF/A-2b conformance
            """
        @fPDFA.setter
        def fPDFA(self, arg0: bool) -> None: ...
        @property
        def fProducer(self) -> String:
            """
            The product that is converting this document to PDF.
            """
        @fProducer.setter
        def fProducer(self, arg0: String) -> None: ...
        @property
        def fRasterDPI(self) -> float:
            """
            The DPI (pixels-per-inch) at which features without native PDF support
            will be rasterized (e.g. draw image with perspective, draw text with
            perspective, ...)  A larger DPI would create a PDF that reflects the
            original intent with better fidelity, but it can make for larger PDF
            files too, which would use more memory while rendering, and it would be
            slower to be processed or sent online or to printer.
            """
        @fRasterDPI.setter
        def fRasterDPI(self, arg0: float) -> None: ...
        @property
        def fStructureElementTreeRoot(self) -> PDF.StructureElementNode:
            """
            An optional tree of structured document tags that provide
            a semantic representation of the content. The caller
            should retain ownership.
            """
        @fStructureElementTreeRoot.setter
        def fStructureElementTreeRoot(self, arg0: PDF.StructureElementNode) -> None: ...
        @property
        def fSubject(self) -> String:
            """
            The subject of the document.
            """
        @fSubject.setter
        def fSubject(self, arg0: String) -> None: ...
        @property
        def fTitle(self) -> String:
            """
            The document's title.
            """
        @fTitle.setter
        def fTitle(self, arg0: String) -> None: ...

    class StructureElementNode:
        """

        A node in a PDF structure tree, giving a semantic representation
        of the content.  Each node ID is associated with content
        by passing the :py:class:`Canvas` and node ID to :py:class:`PDF.SetNodeId`
        when drawing. NodeIDs should be unique within each tree.

        """

        fAlt: String
        fLang: String
        fNodeId: int
        fTypeString: String
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self) -> None: ...
        @property
        def fAttributes(self) -> PDF.AttributeList: ...

    @staticmethod
    @typing.overload
    def MakeDocument(stream: WStream, metadata: PDF.Metadata) -> Document:
        """
        Create a PDF-backed document, writing the results into a
        :py:class:`WStream`.

        PDF pages are sized in point units. 1 pt == 1/72 inch == 127/360 mm.

        :stream:  A PDF document will be written to this stream. The
            document may write to the stream at anytime during its lifetime,
            until either :py:meth:`~Document.close` is called or the document is
            deleted.
        :metadata:  a PDFmetadata object. Any fields may be left empty.
        :return: NULL if there is an error, otherwise a newly created PDF-backed
            :py:class:`Document`.
        """
    @staticmethod
    @typing.overload
    def MakeDocument(stream: WStream) -> Document: ...
    @staticmethod
    @typing.overload
    def MakeDocument(stream: WStream, **kwargs) -> Document: ...
    @staticmethod
    def SetNodeId(canvas: Canvas, nodeId: int) -> None:
        """
        Associate a node ID with subsequent drawing commands in an
        :py:class:`Canvas`.

        The same node ID can appear in a :py:class:`~PDF.StructureElementNode`
        in order to associate a document's structure element tree with its
        content.

        A node ID of zero indicates no node ID.

        :param canvas: The canvas used to draw to the PDF.
        :param nodeId: The node ID for subsequent drawing commands.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Paint:
    """

    :py:class:`Paint` controls options applied when drawing.

    :py:class:`Paint` collects all options outside of the :py:class:`Canvas`
    clip and :py:class:`Canvas` matrix.

    Various options apply to strokes and fills, and images.

    :py:class:`Paint` collects effects and filters that describe single-pass and
    multiple-pass algorithms that alter the drawing geometry, color, and
    transparency. For instance, :py:class:`Paint` does not directly implement
    dashing or blur, but contains the objects that do so.

    Example::

        paint = skia.Paint(
            Alphaf=1.0,
            AntiAlias=True,
            Color=skia.ColorBLUE,
            StrokeWidth=2,
            Style=skia.Paint.kStroke_Style,
        )

    :py:class:`Paint` is implicitly convertible from python dict. It is
    possible to replace :py:class:`Paint` with ``dict`` where required::

        canvas.drawPaint({"Color": 0xFFFFFFFF})
        canvas.drawLine((0, 0), (1, 1), {"Color": 0xFF0000FF})

    """
    class Cap:
        """
        Members:

          kButt_Cap : no stroke extension

          kRound_Cap : adds circle

          kSquare_Cap : adds square

          kLast_Cap : largest Cap value

          kDefault_Cap : equivalent to kButt_Cap
        """

        __members__: typing.ClassVar[
            dict[str, Paint.Cap]
        ]  # value = {'kButt_Cap': <Cap.kButt_Cap: 0>, 'kRound_Cap': <Cap.kRound_Cap: 1>, 'kSquare_Cap': <Cap.kSquare_Cap: 2>, 'kLast_Cap': <Cap.kSquare_Cap: 2>, 'kDefault_Cap': <Cap.kButt_Cap: 0>}
        kButt_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kButt_Cap: 0>
        kDefault_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kButt_Cap: 0>
        kLast_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kSquare_Cap: 2>
        kRound_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kRound_Cap: 1>
        kSquare_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kSquare_Cap: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Join:
        """
        Members:

          kMiter_Join : extends to miter limit

          kRound_Join : adds circle

          kBevel_Join : connects outside edges

          kLast_Join : equivalent to the largest value for Join

          kDefault_Join : equivalent to kMiter_Join
        """

        __members__: typing.ClassVar[
            dict[str, Paint.Join]
        ]  # value = {'kMiter_Join': <Join.kMiter_Join: 0>, 'kRound_Join': <Join.kRound_Join: 1>, 'kBevel_Join': <Join.kBevel_Join: 2>, 'kLast_Join': <Join.kBevel_Join: 2>, 'kDefault_Join': <Join.kMiter_Join: 0>}
        kBevel_Join: typing.ClassVar[Paint.Join]  # value = <Join.kBevel_Join: 2>
        kDefault_Join: typing.ClassVar[Paint.Join]  # value = <Join.kMiter_Join: 0>
        kLast_Join: typing.ClassVar[Paint.Join]  # value = <Join.kBevel_Join: 2>
        kMiter_Join: typing.ClassVar[Paint.Join]  # value = <Join.kMiter_Join: 0>
        kRound_Join: typing.ClassVar[Paint.Join]  # value = <Join.kRound_Join: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Style:
        """
        Members:

          kFill_Style : set to fill geometry

          kStroke_Style : set to stroke geometry

          kStrokeAndFill_Style : sets to stroke and fill geometry
        """

        __members__: typing.ClassVar[
            dict[str, Paint.Style]
        ]  # value = {'kFill_Style': <Style.kFill_Style: 0>, 'kStroke_Style': <Style.kStroke_Style: 1>, 'kStrokeAndFill_Style': <Style.kStrokeAndFill_Style: 2>}
        kFill_Style: typing.ClassVar[Paint.Style]  # value = <Style.kFill_Style: 0>
        kStrokeAndFill_Style: typing.ClassVar[
            Paint.Style
        ]  # value = <Style.kStrokeAndFill_Style: 2>
        kStroke_Style: typing.ClassVar[Paint.Style]  # value = <Style.kStroke_Style: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kBevel_Join: typing.ClassVar[Paint.Join]  # value = <Join.kBevel_Join: 2>
    kButt_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kButt_Cap: 0>
    kCapCount: typing.ClassVar[int] = 3
    kDefault_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kButt_Cap: 0>
    kDefault_Join: typing.ClassVar[Paint.Join]  # value = <Join.kMiter_Join: 0>
    kFill_Style: typing.ClassVar[Paint.Style]  # value = <Style.kFill_Style: 0>
    kJoinCount: typing.ClassVar[int] = 3
    kLast_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kSquare_Cap: 2>
    kLast_Join: typing.ClassVar[Paint.Join]  # value = <Join.kBevel_Join: 2>
    kMiter_Join: typing.ClassVar[Paint.Join]  # value = <Join.kMiter_Join: 0>
    kRound_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kRound_Cap: 1>
    kRound_Join: typing.ClassVar[Paint.Join]  # value = <Join.kRound_Join: 1>
    kSquare_Cap: typing.ClassVar[Paint.Cap]  # value = <Cap.kSquare_Cap: 2>
    kStrokeAndFill_Style: typing.ClassVar[
        Paint.Style
    ]  # value = <Style.kStrokeAndFill_Style: 2>
    kStroke_Style: typing.ClassVar[Paint.Style]  # value = <Style.kStroke_Style: 1>
    kStyleCount: typing.ClassVar[int] = 3
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: Paint) -> bool:
        """
        Compares a and b, and returns true if a and b are equivalent.

        May return false if :py:class:`PathEffect`, :py:class:`Shader`,
        :py:class:`MaskFilter`, :py:class:`ColorFilter`, or
        :py:class:`ImageFilter` have identical contents but different pointers.

        :param other: :py:class:`Paint` to compare
        :return: true if :py:class:`Paint` pair are equivalent
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Constructs :py:class:`Paint` with default values.
        """
    @typing.overload
    def __init__(self, color: Color4f, colorSpace: ColorSpace | None = None) -> None:
        """
        Constructs :py:class:`Paint` with default values and the given color.

        Sets alpha and RGB used when stroking and filling. The color is four
        floating point values, unpremultiplied. The color values are interpreted
        as being in the colorSpace. If colorSpace is nullptr, then color is
        assumed to be in the sRGB color space.

        :color: unpremultiplied RGBA
        :colorSpace: :py:class:`ColorSpace` describing the
            encoding of color
        """
    @typing.overload
    def __init__(self, paint: Paint) -> None:
        """
        Makes a shallow copy of :py:class:`Paint`.

        :py:class:`PathEffect`, :py:class:`Shader`, :py:class:`MaskFilter`,
        :py:class:`ColorFilter`, and :py:class:`ImageFilter` are shared between
        the original paint and the copy. Objects containing :py:class:`RefCnt`
        increment their references by one.

        The referenced objects :py:class:`PathEffect`, :py:class:`Shader`,
        :py:class:`MaskFilter`, :py:class:`ColorFilter`, and
        :py:class:`ImageFilter` cannot be modified after they are created. This
        prevents objects with :py:class:`RefCnt` from being modified once
        :py:class:`Paint` refers to them.

        :paint: original to copy
        """
    @typing.overload
    def __init__(self, **kwargs) -> None:
        """
        Constructs :py:class:`Paint` with keyword arguments. See ``setXXX``
        methods for required signatures.

        Example::

            paint = skia.Paint(
                Alpha=255,
                Alphaf=1.0,
                AntiAlias=True,
                Color=0xFFFFFFFF,
                Color4f=skia.Color4f.FromColor(0xFF00FF00),
                ColorFilter=skia.LumaColorFilter.Make(),
                Dither=False,
                FilterQuality=skia.kMedium_FilterQuality,
                ImageFilter=skia.ImageFilters.Blur(1.0, 1.0),
                MaskFilter=skia.MaskFilter.MakeBlur(skia.kNormal_BlurStyle, 1.0),
                PathEffect=skia.DashPathEffect.Make([2.0, 1.0], 0),
                Shader=skia.Shaders.Empty(),
                StrokeCap=skia.Paint.kButt_Cap,
                StrokeJoin=skia.Paint.kMiter_Join,
                StrokeMiter=0,
                StrokeWidth=2,
                Style=skia.Paint.kStroke_Style,
            )
        """
    @typing.overload
    def __init__(self, d: dict) -> None:
        """
        Constructs :py:class:`Paint` from python dict::

            d = {
                "Alpha": 255,
                "Alphaf": 1.0,
                "AntiAlias": True,
                "Color": 0xFFFFFFFF,
                "Color4f": skia.Color4f.FromColor(0xFF00FF00),
                "ColorFilter": skia.LumaColorFilter.Make(),
                "Dither": False,
                "FilterQuality": skia.kMedium_FilterQuality,
                "ImageFilter": skia.ImageFilters.Blur(1.0, 1.0),
                "MaskFilter": skia.MaskFilter.MakeBlur(skia.kNormal_BlurStyle, 1.0),
                "PathEffect": skia.DashPathEffect.Make([2.0, 1.0], 0),
                "Shader": skia.Shaders.Empty(),
                "StrokeCap": skia.Paint.kButt_Cap,
                "StrokeJoin": skia.Paint.kMiter_Join,
                "StrokeMiter": 0,
                "StrokeWidth": 2,
                "Style": skia.Paint.kStroke_Style,
            }
            paint = skia.Paint(d)
        """
    def __ne__(self, other: Paint) -> bool:
        """
        Compares a and b, and returns true if a and b are not equivalent.

        May return true if :py:class:`PathEffect`, :py:class:`Shader`,
        :py:class:`MaskFilter`, :py:class:`ColorFilter`, or
        :py:class:`ImageFilter` have identical contents but different pointers.

        :param other: :py:class:`Paint` to compare
        :return: true if :py:class:`Paint` pair are not equivalent
        """
    def canComputeFastBounds(self) -> bool:
        """
        (to be made private) Returns true if :py:class:`Paint` does not include
        elements requiring extensive computation to compute
        :py:class:`BaseDevice` bounds of drawn geometry.

        For instance, :py:class:`Paint` with :py:class:`PathEffect` always
        returns false.

        :return: true if :py:class:`Paint` allows for fast computation of bounds
        """
    def computeFastBounds(self, orig: Rect) -> Rect:
        """
        (to be made private) Only call this if :py:meth:`canComputeFastBounds`
        returned true.

        This takes a raw rectangle (the raw bounds of a shape), and adjusts it
        for stylistic effects in the paint (e.g. stroking). It returns the
        adjusted bounds that can then be used for :py:meth:`Canvas.quickReject`
        tests.

        :param orig:     geometry modified by :py:class:`Paint` when drawn
        :return:         fast computed bounds
        """
    def computeFastStrokeBounds(self, orig: Rect) -> Rect:
        """
        (to be made private)

        :param orig:    geometry modified by SkPaint when drawn
        :return:        fast computed bounds
        """
    def doComputeFastBounds(self, orig: Rect, style: Paint.Style) -> Rect:
        """
        (to be made private) Computes the bounds, overriding the
        :py:class:`Paint` :py:class:`Paint.Style`.

        This can be used to account for additional width required by stroking
        orig, without altering :py:class:`Paint.Style` set to fill.

        :param orig:    geometry modified by :py:class:`Paint` when drawn
        :param style:   overrides :py:class:`Paint.Style`
        :return:        fast computed bounds
        """
    def getAlpha(self) -> int: ...
    def getAlphaf(self) -> float:
        """
        Retrieves alpha from the color used when stroking and filling.

        :return: alpha ranging from zero, fully transparent, to 255, fully
            opaque
        """
    def getBlendMode(self) -> BlendMode:
        """
        Returns :py:class:`BlendMode`.

        By default, returns :py:attr:`BlendMode.kSrcOver`.

        :return: mode used to combine source color with destination color
        """
    def getColor(self) -> int:
        """
        Retrieves alpha and RGB, unpremultiplied, packed into 32 bits.

        Use helpers :py:func:`ColorGetA`, :py:func:`ColorGetR`,
        :py:func:`ColorGetG`, and :py:func:`ColorGetB` to extract a color
        component.

        :return: unpremultiplied ARGB
        """
    def getColor4f(self) -> Color4f:
        """
        Retrieves alpha and RGB, unpremultiplied, as four floating point values.

        RGB are are extended sRGB values (sRGB gamut, and encoded with the sRGB
        transfer function).

        :return: unpremultiplied RGBA
        """
    def getColorFilter(self) -> ColorFilter:
        """
        Returns :py:class:`ColorFilter` if set, or nullptr.

        Does not alter :py:class:`ColorFilter` :py:class:`RefCnt`.

        :return: :py:class:`ColorFilter` if previously set, nullptr otherwise
        """
    def getFillPath(
        self,
        src: Path,
        dst: Path,
        cullRect: Rect | None = None,
        resScale: float = 1,
    ) -> bool:
        """
        Returns the filled equivalent of the stroked path.

        :param src: :py:class:`Path` read to create a filled version
        :param dst: resulting :py:class:`Path`; may be the same as src, but may
            not be nullptr
        :param cullRect: optional limit passed to :py:class:`PathEffect`
        :param resScale: if > 1, increase precision, else if (0 < resScale < 1)
            reduce precision to favor speed and size
        :return: true if the path represents style fill, or false if it
            represents hairline
        """
    def getImageFilter(self) -> ImageFilter:
        """
        Returns :py:class:`ImageFilter` if set, or nullptr.

        Does not alter :py:class:`ImageFilter` :py:class:`RefCnt`.

        :return: :py:class:`ImageFilter` if previously set, nullptr otherwise
        """
    def getMaskFilter(self) -> MaskFilter:
        """
        Returns :py:class:`MaskFilter` if set, or nullptr.

        Does not alter :py:class:`MaskFilter` :py:class:`RefCnt`.

        :return: :py:class:`MaskFilter` if previously set, nullptr otherwise
        """
    def getPathEffect(self) -> PathEffect:
        """
        Returns :py:class:`PathEffect` if set, or nullptr.

        Does not alter :py:class:`PathEffect` :py:class:`RefCnt`.

        :return: :py:class:`PathEffect` if previously set, nullptr otherwise
        """
    def getShader(self) -> Shader:
        """
        Returns optional colors used when filling a path, such as a gradient.

        Does not alter :py:class:`Shader` :py:class:`RefCnt`.

        :return: :py:class:`Shader` if previously set, nullptr otherwise
        """
    def getStrokeCap(self) -> Paint.Cap:
        """
        Returns the geometry drawn at the beginning and end of strokes.
        """
    def getStrokeJoin(self) -> Paint.Join:
        """
        Returns the geometry drawn at the corners of strokes.
        """
    def getStrokeMiter(self) -> float:
        """
        Returns the limit at which a sharp corner is drawn beveled.

        :return: zero and greater miter limit
        """
    def getStrokeWidth(self) -> float:
        """
        Returns the thickness of the pen used by SkPaint to outline the shape.

        :return: zero for hairline, greater than zero for pen thickness
        """
    def getStyle(self) -> Paint.Style:
        """
        Returns whether the geometry is filled, stroked, or filled and stroked.
        """
    def isAntiAlias(self) -> bool:
        """
        Returns true if pixels on the active edges of :py:class:`Path` may be
        drawn with partial transparency.

        :return: antialiasing state
        """
    def isDither(self) -> bool:
        """
        Returns true if color error may be distributed to smooth color
        transition.

        :return: dithering state
        """
    def isSrcOver(self) -> bool:
        """
        Returns true if :py:class:`BlendMode` is :py:attr:`BlendMode.kSrcOver`,
        the default.

        :return: true if :py:class:`BlendMode` is :py:attr:`BlendMode.kSrcOver`
        """
    def nothingToDraw(self) -> bool:
        """
        Returns true if :py:class:`Paint` prevents all drawing; otherwise, the
        :py:class:`Paint` may or may not allow drawing.

        Returns true if, for example, :py:class:`BlendMode` combined with alpha
        computes a new alpha of zero.

        :return: true if :py:class:`Paint` prevents all drawing
        """
    def refColorFilter(self) -> ColorFilter:
        """
        Returns :py:class:`ColorFilter` if set, or nullptr.

        Increases :py:class:`ColorFilter` :py:class:`RefCnt` by one.

        :return: :py:class:`ColorFilter` if set, or nullptr
        """
    def refImageFilter(self) -> ImageFilter:
        """
        Returns :py:class:`ImageFilter` if set, or nullptr.

        Increases :py:class:`ImageFilter` :py:class:`RefCnt` by one.

        :return: :py:class:`ImageFilter` if previously set, nullptr otherwise
        """
    def refMaskFilter(self) -> MaskFilter:
        """
        Returns :py:class:`MaskFilter` if set, or nullptr.

        Increases :py:class:`MaskFilter` :py:class:`RefCnt` by one.

        :return: :py:class:`MaskFilter` if previously set, nullptr otherwise
        """
    def refPathEffect(self) -> PathEffect:
        """
        Returns :py:class:`PathEffect` if set, or nullptr.

        Increases :py:class:`PathEffect` :py:class:`RefCnt` by one.

        :return: :py:class:`PathEffect` if previously set, nullptr otherwise
        """
    def refShader(self) -> Shader:
        """
        Returns optional colors used when filling a path, such as a gradient.

        Increases :py:class:`Shader` :py:class:`RefCnt` by one.

        :return: :py:class:`Shader` if previously set, nullptr otherwise
        """
    def reset(self) -> None:
        """
        Sets all :py:class:`Paint` contents to their initial values.

        This is equivalent to replacing :py:class:`Paint` with the result of
        :py:meth:`__init__` without arguments.
        """
    def setARGB(self, a: int, r: int, g: int, b: int) -> None:
        """
        Sets color used when drawing solid fills.

        The color components range from 0 to 255. The color is unpremultiplied;
        alpha sets the transparency independent of RGB.

        :param int a: amount of alpha, from fully transparent (0) to fully
            opaque (255)
        :param int r: amount of red, from no red (0) to full red (255)
        :param int g: amount of green, from no green (0) to full green (255)
        :param int b: amount of blue, from no blue (0) to full blue (255)
        """
    def setAlpha(self, a: int) -> None: ...
    def setAlphaf(self, a: float) -> None:
        """
        Replaces alpha, leaving RGB unchanged.

        An out of range value triggers an assert in the debug build. a is a
        value from 0.0 to 1.0. a set to zero makes color fully transparent; a
        set to 1.0 makes color fully opaque.

        :param float a: alpha component of color
        """
    def setAntiAlias(self, aa: bool) -> None:
        """
        Requests, but does not require, that edge pixels draw opaque or with
        partial transparency.

        :param bool aa: setting for antialiasing
        """
    def setBlendMode(self, mode: BlendMode) -> None:
        """
        Sets :py:class:`BlendMode` to mode.

        Does not check for valid input.

        :param skia.BlendMode mode: :py:class:`BlendMode` used to combine source
            color and destination
        """
    def setColor(self, color: int) -> None:
        """
        Sets alpha and RGB used when stroking and filling.

        The color is a 32-bit value, unpremultiplied, packing 8-bit components
        for alpha, red, blue, and green.

        :param int color: unpremultiplied ARGB
        """
    def setColor4f(self, color: Color4f, colorSpace: ColorSpace | None = None) -> None:
        """
        Sets alpha and RGB used when stroking and filling.

        The color is four floating point values, unpremultiplied. The color
        values are interpreted as being in the colorSpace. If colorSpace is
        nullptr, then color is assumed to be in the sRGB color space.

        :param skia.Color4f color: unpremultiplied RGBA
        :param skia.ColorSpace colorSpace: :py:class:`ColorSpace` describing the
            encoding of color
        """
    def setColorFilter(self, colorFilter: ColorFilter) -> None:
        """
        Sets :py:class:`ColorFilter` to filter, decreasing :py:class:`RefCnt` of
        the previous :py:class:`ColorFilter`.

        Pass nullptr to clear :py:class:`ColorFilter`.

        Increments filter :py:class:`RefCnt` by one.

        :param skia.ColorFilter colorFilter: :py:class:`ColorFilter` to apply to
            subsequent draw
        """
    def setDither(self, dither: bool) -> None:
        """
        Requests, but does not require, to distribute color error.

        :param bool dither: dither  setting for ditering
        """
    def setImageFilter(self, imageFilter: ImageFilter) -> None:
        """
        Sets :py:class:`ImageFilter` to imageFilter, decreasing
        :py:class:`RefCnt` of the previous :py:class:`ImageFilter`.

        Pass nullptr to clear :py:class:`ImageFilter`, and remove
        :py:class:`ImageFilter` effect on drawing.

        Increments imageFilter :py:class:`RefCnt` by one.

        :param skia.ImageFilter imageFilter: how :py:class:`Image` is sampled
            when transformed
        """
    def setMaskFilter(self, maskFilter: MaskFilter) -> None:
        """
        Sets :py:class:`MaskFilter` to maskFilter, decreasing :py:class:`RefCnt`
        of the previous :py:class:`MaskFilter`.

        Pass nullptr to clear :py:class:`MaskFilter` and leave
        :py:class:`MaskFilter` effect on mask alpha unaltered.

        Increments maskFilter :py:class:`RefCnt` by one.

        :param skia.MaskFilter maskFilter: modifies clipping mask generated from
            drawn geometry
        """
    def setPathEffect(self, pathEffect: PathEffect) -> None:
        """
        Sets :py:class:`PathEffect` to pathEffect, decreasing :py:class:`RefCnt`
        of the previous :py:class:`PathEffect`.

        Pass nullptr to leave the path geometry unaltered.

        Increments pathEffect :py:class:`RefCnt` by one.

        :param skia.PathEffect pathEffect: replace :py:class:`Path` with a
            modification when drawn
        """
    def setShader(self, shader: Shader) -> None:
        """
        Sets optional colors used when filling a path, such as a gradient.

        Sets :py:class:`Shader` to shader, decreasing :py:class:`RefCnt` of the
        previous :py:class:`Shader`. Increments shader :py:class:`RefCnt` by
        one.

        :param skia.Shader shader: how geometry is filled with color; if
            nullptr, color is used instead
        """
    def setStrokeCap(self, cap: Paint.Cap) -> None:
        """
        Sets the geometry drawn at the beginning and end of strokes.
        """
    def setStrokeJoin(self, join: Paint.Join) -> None:
        """
        Sets the geometry drawn at the corners of strokes.
        """
    def setStrokeMiter(self, miter: float) -> None:
        """
        Sets the limit at which a sharp corner is drawn beveled.

        Valid values are zero and greater. Has no effect if miter is less than zero.

        :param float miter: zero and greater miter limit
        """
    def setStrokeWidth(self, width: float) -> None:
        """
        Sets the thickness of the pen used by the paint to outline the shape.

        Has no effect if width is less than zero.

        :param float width: zero thickness for hairline; greater than zero for
            pen thickness
        """
    def setStyle(self, style: Paint.Style) -> None:
        """
        Sets whether the geometry is filled, stroked, or filled and stroked.

        Has no effect if style is not a legal :py:class:`Paint.Style` value.
        """

class Path:
    """

    :py:class:`Path` contain geometry.

    :py:class:`Path` may be empty, or contain one or more verbs that outline a
    figure. :py:class:`Path` always starts with a move verb to a Cartesian
    coordinate, and may be followed by additional verbs that add lines or
    curves. Adding a close verb makes the geometry into a continuous loop, a
    closed contour. :py:class:`Path` may contain any number of contours, each
    beginning with a move verb.

    :py:class:`Path` contours may contain only a move verb, or may also contain
    lines, quadratic beziers, conics, and cubic beziers. :py:class:`Path`
    contours may be open or closed.

    When used to draw a filled area, :py:class:`Path` describes whether the fill
    is inside or outside the geometry. :py:class:`Path` also describes the
    winding rule used to fill overlapping contours.

    Internally, :py:class:`Path` lazily computes metrics likes bounds and
    convexity. Call :py:meth:`Path.updateBoundsCache` to make :py:class:`Path`
    thread safe.

    Example::

        path = skia.Path()
        path.addCircle(25, 25, 10)
        path.addRect((50, 60, 70, 70))

        for verb, points in path:
            print(verb)

    """
    class AddPathMode:
        """
        Members:

          kAppend_AddPathMode : appended to destination unaltered

          kExtend_AddPathMode : add line if prior contour is not closed
        """

        __members__: typing.ClassVar[
            dict[str, Path.AddPathMode]
        ]  # value = {'kAppend_AddPathMode': <AddPathMode.kAppend_AddPathMode: 0>, 'kExtend_AddPathMode': <AddPathMode.kExtend_AddPathMode: 1>}
        kAppend_AddPathMode: typing.ClassVar[
            Path.AddPathMode
        ]  # value = <AddPathMode.kAppend_AddPathMode: 0>
        kExtend_AddPathMode: typing.ClassVar[
            Path.AddPathMode
        ]  # value = <AddPathMode.kExtend_AddPathMode: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ArcSize:
        """
        Members:

          kSmall_ArcSize : smaller of arc pair

          kLarge_ArcSize : larger of arc pair
        """

        __members__: typing.ClassVar[
            dict[str, Path.ArcSize]
        ]  # value = {'kSmall_ArcSize': <ArcSize.kSmall_ArcSize: 0>, 'kLarge_ArcSize': <ArcSize.kLarge_ArcSize: 1>}
        kLarge_ArcSize: typing.ClassVar[
            Path.ArcSize
        ]  # value = <ArcSize.kLarge_ArcSize: 1>
        kSmall_ArcSize: typing.ClassVar[
            Path.ArcSize
        ]  # value = <ArcSize.kSmall_ArcSize: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Iter:
        """

        Iterates through verb array, and associated :py:class:`Point` array and
        conic weight.

        Provides options to treat open contours as closed, and to ignore degenerate
        data.

        Example::

            it = iter(path)
            verb, points = it.next()
            while verb != skia.Path.kDone_Verb:
                print(verb)
                print(points)
                print(it.conicWeight())
                verb, points = it.next()

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None:
            """
            Initializes :py:class:`Iter` with an empty :py:class:`Path`.

            next() on :py:class:`Iter` returns :py:attr:`~skia.Path.kDone_Verb`.
            Call setPath to initialize :py:class:`Iter` at a later time.

            :return: :py:class:`Iter` of empty SkPath
            """
        @typing.overload
        def __init__(self, path: Path, forceClose: bool) -> None:
            """
            Sets :py:class:`Iter` to return elements of verb array,
            :py:class:`Point` array, and conic weight in path.

            If forceClose is true, :py:class:`Iter` will add
            :py:attr:`~skia.Path.kLine_Verb` and :py:attr:`~skia.Path.kClose_Verb`
            after each open contour. path is not altered.

            :path: :py:class:`Path` to iterate
            :forceClose: true if open contours generate
                :py:attr:`~skia.Path.kClose_Verb`

            :return: :py:class:`Iter` of path
            """
        def __iter__(self) -> Path.Iter: ...
        def __next__(self) -> tuple: ...
        def conicWeight(self) -> float:
            """
            Returns conic weight if :py:meth:`next` returned
            :py:attr:`~skia.Path.kConic_Verb`.

            If :py:meth:`next` has not been called, or :py:meth:`next` did not
            return :py:attr:`~skia.Path.kConic_Verb`, result is undefined.

            :return: conic weight for conic :py:class:`Point` returned by
                :py:meth:`next`
            """
        def isCloseLine(self) -> bool:
            """
            Returns true if last:py:attr:`~skia.Path.kLine_Verb` returned by
            :py:meth:`next` was generated by :py:attr:`~skia.Path.kClose_Verb`.

            When true, the end point returned by :py:meth:`next` is also the start
            point of contour.

            If :py:meth:`next` has not been called, or :py:meth:`next` did not
            return :py:attr:`~skia.Path.kLine_Verb`, result is undefined.

            :return: true if last :py:attr:`~skia.Path.kLine_Verb` was generated by
                :py:attr:`~skia.Path.kClose_Verb`
            """
        def isClosedContour(self) -> bool:
            """
            Returns true if subsequent calls to :py:meth:`next` return
            :py:attr:`~skia.Path.kClose_Verb` before returning
            :py:attr:`~skia.Path.kMove_Verb`.

            if true, contour :py:class:`Iter` is processing may end with
            :py:attr:`~skia.Path.kClose_Verb`, or :py:class:`Iter` may have been
            initialized with force close set to true.

            :return: true if contour is closed
            """
        def next(self) -> tuple:
            """
            Returns next :py:class:`~skia.Path.Verb` in verb array, and advances
            :py:class:`Iter`.

            When verb array is exhausted, returns :py:attr:`~skia.Path.kDone_Verb`.

            Zero to four :py:class:`Point` are stored in pts, depending on the
            returned :py:class:`~skia.Path.Verb`.

            :return: tuple of the following: next :py:class:`~skia.Path.Verb` from
                verb array; and storage for :py:class:`Point` data describing
                returned :py:class:`~skia.Path.Verb`
            :rtype: Tuple[skia.Path.Verb,List[skia.Point]]
            """
        def setPath(self, path: Path, forceClose: bool) -> None:
            """
            Sets :py:class:`Iter` to return elements of verb array,
            :py:class:`Point` array, and conic weight in path.

            If forceClose is true, :py:class:`Iter` will add
            :py:attr:`~skia.Path.kLine_Verb` and :py:attr:`~skia.Path.kClose_Verb`
            after each open contour. path is not altered.

            :param skia.Path path: :py:class:`Path` to iterate
            :param bool forceClose: true if open contours generate
                :py:attr:`~skia.Path.kClose_Verb`
            """

    class RawIter:
        """

        Iterates through verb array, and associated :py:class:`Point` array and
        conic weight.

        verb array, :py:class:`Point` array, and conic weight are returned
        unaltered.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None:
            """
            Initializes :py:class:`RawIter` with an empty :py:class:`Path`.

            :py:meth:`next` on :py:class:`RawIter` returns
            :py:attr:`~skia.Path.kDone_Verb`. Call :py:meth:`setPath` to initialize
            :py:class:`RawIter` at a later time.

            :return: :py:class:`RawIter` of empty :py:class:`Path`
            """
        @typing.overload
        def __init__(self, path: Path) -> None:
            """
            Sets :py:class:`RawIter` to return elements of verb array,
            :py:class:`Point` array, and conic weight in path.

            :path: :py:class:`Path` to iterate
            :return: :py:class:`RawIter` of path
            """
        def __iter__(self) -> Path.RawIter: ...
        def __next__(self) -> tuple: ...
        def conicWeight(self) -> float:
            """
            Returns conic weight if :py:meth:`next` returned
            :py:attr:`~skia.Path.kConic_Verb`.

            If :py:meth:`next` has not been called, or :py:meth:`next` did not
            return :py:attr:`~skia.Path.kConic_Verb`, result is undefined.

            :return: conic weight for conic :py:class:`Point` returned by
                :py:meth:`next`
            """
        def next(self) -> tuple:
            """
            Returns next :py:class:`~skia.Path.Verb` in verb array, and advances
            :py:class:`RawIter`.

            When verb array is exhausted, returns :py:attr:`~skia.Path.kDone_Verb`.

            Zero to four :py:class:`Point` are stored in pts, depending on the
            returned :py:class:`~skia.Path.Verb`.

            :return: tuple of the following: next :py:class:`~skia.Path.Verb` from
                verb array; and storage for :py:class:`Point` data describing
                returned :py:class:`~skia.Path.Verb`
            :rtype: Tuple[skia.Path.Verb,List[skia.Point]]
            """
        def peek(self) -> Path.Verb:
            """
            Returns next :py:class:`~skia.Path.Verb`, but does not advance
            :py:class:`RawIter`.

            :return: next :py:class:`~skia.Path.Verb` from verb array
            """
        def setPath(self, path: Path) -> None:
            """
            Sets :py:class:`RawIter` to return elements of verb array,
            :py:class:`Point` array, and conic weight in path.

            :param skia.Path path: :py:class:`Path` to iterate
            """

    class SegmentMask:
        """
        Members:

          kLine_SegmentMask

          kQuad_SegmentMask

          kConic_SegmentMask

          kCubic_SegmentMask
        """

        __members__: typing.ClassVar[
            dict[str, Path.SegmentMask]
        ]  # value = {'kLine_SegmentMask': <SegmentMask.kLine_SegmentMask: 1>, 'kQuad_SegmentMask': <SegmentMask.kQuad_SegmentMask: 2>, 'kConic_SegmentMask': <SegmentMask.kConic_SegmentMask: 4>, 'kCubic_SegmentMask': <SegmentMask.kCubic_SegmentMask: 8>}
        kConic_SegmentMask: typing.ClassVar[
            Path.SegmentMask
        ]  # value = <SegmentMask.kConic_SegmentMask: 4>
        kCubic_SegmentMask: typing.ClassVar[
            Path.SegmentMask
        ]  # value = <SegmentMask.kCubic_SegmentMask: 8>
        kLine_SegmentMask: typing.ClassVar[
            Path.SegmentMask
        ]  # value = <SegmentMask.kLine_SegmentMask: 1>
        kQuad_SegmentMask: typing.ClassVar[
            Path.SegmentMask
        ]  # value = <SegmentMask.kQuad_SegmentMask: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Verb:
        """
        Members:

          kMove_Verb

          kLine_Verb

          kQuad_Verb

          kConic_Verb

          kCubic_Verb

          kClose_Verb

          kDone_Verb
        """

        __members__: typing.ClassVar[
            dict[str, Path.Verb]
        ]  # value = {'kMove_Verb': <Verb.kMove_Verb: 0>, 'kLine_Verb': <Verb.kLine_Verb: 1>, 'kQuad_Verb': <Verb.kQuad_Verb: 2>, 'kConic_Verb': <Verb.kConic_Verb: 3>, 'kCubic_Verb': <Verb.kCubic_Verb: 4>, 'kClose_Verb': <Verb.kClose_Verb: 5>, 'kDone_Verb': <Verb.kDone_Verb: 6>}
        kClose_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kClose_Verb: 5>
        kConic_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kConic_Verb: 3>
        kCubic_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kCubic_Verb: 4>
        kDone_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kDone_Verb: 6>
        kLine_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kLine_Verb: 1>
        kMove_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kMove_Verb: 0>
        kQuad_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kQuad_Verb: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kAppend_AddPathMode: typing.ClassVar[
        Path.AddPathMode
    ]  # value = <AddPathMode.kAppend_AddPathMode: 0>
    kClose_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kClose_Verb: 5>
    kConic_SegmentMask: typing.ClassVar[
        Path.SegmentMask
    ]  # value = <SegmentMask.kConic_SegmentMask: 4>
    kConic_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kConic_Verb: 3>
    kCubic_SegmentMask: typing.ClassVar[
        Path.SegmentMask
    ]  # value = <SegmentMask.kCubic_SegmentMask: 8>
    kCubic_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kCubic_Verb: 4>
    kDone_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kDone_Verb: 6>
    kExtend_AddPathMode: typing.ClassVar[
        Path.AddPathMode
    ]  # value = <AddPathMode.kExtend_AddPathMode: 1>
    kLarge_ArcSize: typing.ClassVar[Path.ArcSize]  # value = <ArcSize.kLarge_ArcSize: 1>
    kLine_SegmentMask: typing.ClassVar[
        Path.SegmentMask
    ]  # value = <SegmentMask.kLine_SegmentMask: 1>
    kLine_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kLine_Verb: 1>
    kMove_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kMove_Verb: 0>
    kQuad_SegmentMask: typing.ClassVar[
        Path.SegmentMask
    ]  # value = <SegmentMask.kQuad_SegmentMask: 2>
    kQuad_Verb: typing.ClassVar[Path.Verb]  # value = <Verb.kQuad_Verb: 2>
    kSmall_ArcSize: typing.ClassVar[Path.ArcSize]  # value = <ArcSize.kSmall_ArcSize: 0>
    @staticmethod
    def Circle(
        center_x: float,
        center_y: float,
        radius: float,
        pathDirection: PathDirection = ...,
    ) -> Path: ...
    @staticmethod
    def ConvertConicToQuads(
        p0: Point,
        p1: Point,
        p2: Point,
        w: float,
        pow2: int,
    ) -> list[Point]:
        """
        Approximates conic with quad array.

        Conic is constructed from start :py:class:`Point` p0, control
        :py:class:`Point` p1, end :py:class:`Point` p2, and weight w. Maximum
        quad count is 2 to the pow2. Every third point in array shares last
        :py:class:`Point` of previous quad and first :py:class:`Point` of next
        quad. Maximum possible return array size is given by:
        (1 + 2 * (1 << pow2)).

        Conic weight determines the amount of influence conic control point has
        on the curve. w less than one represents an elliptical section. w
        greater than one represents a hyperbolic section. w equal to one
        represents a parabolic section.

        Two quad curves are sufficient to approximate an elliptical conic with a
        sweep of up to 90 degrees; in this case, set pow2 to one.

        :param skia.Point p0: conic start :py:class:`Point`
        :param skia.Point p1: conic control :py:class:`Point`
        :param skia.Point p2: conic end :py:class:`Point`
        :param float w: conic weight
        :param int pow2: quad count, as power of two, normally 0 to 5 (1 to 32
            quad curves)
        :return: quad array
        :rtype: List[skia.Point]
        """
    @staticmethod
    def IsCubicDegenerate(
        p1: Point,
        p2: Point,
        p3: Point,
        p4: Point,
        exact: bool,
    ) -> bool:
        """
        Tests if cubic is degenerate.

        Cubic with no length or that moves a very short distance is degenerate;
        it is treated as a point.

        :param skia.Path p1: cubic start point
        :param skia.Path p2: cubic control point 1
        :param skia.Path p3: cubic control point 2
        :param skia.Path p4: cubic end point
        :param bool exact: if true, returns true only if p1, p2, p3, and p4 are
            equal; if false, returns true if p1, p2, p3, and p4 are equal or
            nearly equal
        :return: true if cubic is degenerate; its length is effectively zero
        """
    @staticmethod
    def IsLineDegenerate(p1: Point, p2: Point, exact: bool) -> bool:
        """
        Tests if line between :py:class:`Point` pair is degenerate.

        Line with no length or that moves a very short distance is degenerate;
        it is treated as a point.

        exact changes the equality test. If true, returns true only if p1 equals
        p2. If false, returns true if p1 equals or nearly equals p2.

        :param skia.Point p1: line start point
        :param skia.Point p2: line end point
        :param bool exact: if false, allow nearly equals
        :return: true if line is degenerate; its length is effectively zero
        """
    @staticmethod
    def IsQuadDegenerate(p1: Point, p2: Point, p3: Point, exact: bool) -> bool:
        """
        Tests if quad is degenerate.

        Quad with no length or that moves a very short distance is degenerate;
        it is treated as a point.

        :param skia.Path p1: quad start point
        :param skia.Path p2: quad control point
        :param skia.Path p3: quad end point
        :param bool exact: if true, returns true only if p1, p2, and p3 are
            equal; if false, returns true if p1, p2, and p3 are equal or nearly
            equal
        :return: true if quad is degenerate; its length is effectively zero
        """
    @staticmethod
    def Line(a: Point, b: Point) -> Path: ...
    @staticmethod
    def Make(
        points: list[Point],
        verbs: list[int],
        conicWeights: list[float],
        fillType: PathFillType,
        isVolatile: bool = False,
    ) -> Path:
        """
        Create a new path with the specified segments.

        The points and weights arrays are read in order, based on the sequence
        of verbs.

            Move    1 point
            Line    1 point
            Quad    2 points
            Conic   2 points and 1 weight
            Cubic   3 points
            Close   0 points

        If an illegal sequence of verbs is encountered, or the specified number
        of points or weights is not sufficient given the verbs, an empty Path is
        returned.

        A legal sequence of verbs consists of any number of Contours. A contour
        always begins with a Move verb, followed by 0 or more segments: Line,
        Quad, Conic, Cubic, followed by an optional Close.
        """
    @staticmethod
    def Oval(
        rect: Rect,
        pathDirection: PathDirection = ...,
        startIndex: int = 0,
    ) -> Path: ...
    @staticmethod
    def Polygon(
        points: list[Point],
        isClosed: bool,
        fillType: PathFillType = ...,
        isVolatile: bool = False,
    ) -> Path: ...
    @staticmethod
    @typing.overload
    def RRect(
        rrect: RRect,
        pathDirection: PathDirection = ...,
        startIndex: int = 0,
    ) -> Path: ...
    @staticmethod
    @typing.overload
    def RRect(
        bounds: Rect,
        rx: float,
        ry: float,
        pathDirection: PathDirection = ...,
    ) -> Path: ...
    @staticmethod
    def Rect(
        rect: Rect,
        pathDirection: PathDirection = ...,
        startIndex: int = 0,
    ) -> Path: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: Path) -> bool:
        """
        Compares a and b; returns true if :py:class:`Path.FillType`, verb array,
        :py:class:`Point` array, and weights are equivalent.

        :param skia.Path other: :py:class:`Path` to compare
        :return: true if :py:class:`Path` pair are equivalent
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Constructs an empty :py:class:`Path`.

        By default, :py:class:`Path` has no verbs, no :py:class:`Point`, and no
        weights. :py:class:`FillType` is set to kWinding.
        """
    @typing.overload
    def __init__(self, path: Path) -> None:
        """
        Constructs a copy of an existing path.

        Copy constructor makes two paths identical by value. Internally, path
        and the returned result share pointer values. The underlying verb array,
        :py:class:`Point` array and weights are copied when modified.

        Creating a :py:class:`Path` copy is very efficient and never allocates
        memory. :py:class:`Path` are always copied by value from the interface;
        the underlying shared pointers are not exposed.

        :path: :py:class:`Path` to copy by value
        """
    def __iter__(self) -> Path.Iter: ...
    def __ne__(self, other: Path) -> bool:
        """
        Compares a and b; returns true if :py:class:`Path.FillType`, verb array,
        :py:class:`Point` array, and weights are not equivalent.

        :param skia.Path other: :py:class:`Path` to compare
        :return: true if :py:class:`Path` pair are not equivalent
        """
    def addArc(self, oval: Rect, startAngle: float, sweepAngle: float) -> Path:
        """
        Appends arc to :py:class:`Path`, as the start of new contour.

        Arc added is part of ellipse bounded by oval, from startAngle through
        sweepAngle. Both startAngle and sweepAngle are measured in degrees,
        where zero degrees is aligned with the positive x-axis, and positive
        sweeps extends arc clockwise.

        If sweepAngle <= -360, or sweepAngle >= 360; and startAngle modulo 90 is
        nearly zero, append oval instead of arc. Otherwise, sweepAngle values
        are treated modulo 360, and arc may or may not draw depending on numeric
        rounding.

        :param skia.Rect oval: bounds of ellipse containing arc
        :param float startAngle: starting angle of arc in degrees
        :param float sweepAngle: sweep, in degrees. Positive is clockwise;
            treated modulo 360
        :return: reference to :py:class:`Path`
        """
    def addCircle(
        self,
        x: float,
        y: float,
        radius: float,
        dir: PathDirection = ...,
    ) -> Path:
        """
        Adds circle centered at (x, y) of size radius to :py:class:`Path`,
        appending :py:attr:`PathVerb.kMove`, four :py:attr:`PathVerb.kConic`,
        and :py:attr:`PathVerb.kClose`.

        Circle begins at: (x + radius, y), continuing clockwise if dir is
        :py:attr:`PathDirection.kCW`, and counterclockwise if dir is
        :py:attr:`PathDirection.kCCW`.

        Has no effect if radius is zero or negative.

        :param float x: center of circle
        :param float y: center of circle
        :param float radius: distance from center to edge
        :param skia.PathDirection dir: :py:class:`PathDirection` to wind circle
        :rtype: :py:class:`Path`
        """
    @typing.overload
    def addOval(self, oval: Rect, dir: PathDirection = ...) -> Path:
        """
        Adds oval to path, appending :py:attr:`~skia.Path.kMove_Verb`, four
        :py:attr:`~skia.Path.kConic_Verb`, and
        :py:attr:`~skia.Path.kClose_Verb`.

        Oval is upright ellipse bounded by :py:class:`Rect` oval with radii
        equal to half oval width and half oval height. Oval begins at
        (oval.fRight, oval.centerY()) and continues clockwise if dir is
        :py:attr:`~skia.PathDirection.kCW`, counterclockwise if dir is
        :py:attr:`~skia.PathDirection.kCCW`.

        :oval: bounds of ellipse added
        :dir: :py:class:`~skia.PathDirection` to wind ellipse
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addOval(self, oval: Rect, dir: PathDirection, start: int) -> Path:
        """
        Adds oval to path, appending :py:attr:`~skia.Path.kMove_Verb`, four
        :py:attr:`~skia.Path.kConic_Verb`, and
        :py:attr:`~skia.Path.kClose_Verb`.

        Oval is upright ellipse bounded by :py:class:`Rect` oval with radii
        equal to half oval width and half oval height. Oval begins at start and
        continues clockwise if dir is kCW_Direction, counterclockwise if dir is
        :py:attr:`~skia.PathDirection.kCW`, counterclockwise if dir is
        :py:attr:`~skia.PathDirection.kCCW`.

        :oval: bounds of ellipse added
        :dir: :py:class:`Path`::Direction to wind ellipse
        :start: index of initial point of ellipse
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addPath(
        self,
        src: Path,
        dx: float,
        dy: float,
        mode: Path.AddPathMode = ...,
    ) -> Path:
        """
        Appends src to :py:class:`Path`, offset by (dx, dy).

        If mode is :py:attr:`~Path.kAppend_AddPathMode`, src verb array,
        :py:class:`Point` array, and conic weights are added unaltered. If mode
        is :py:attr:`~Path.kExtend_AddPathMode`, add line before appending
        verbs, :py:class:`Point`, and conic weights.

        :src: :py:class:`Path` verbs, :py:class:`Point`, and conic weights to
            add
        :dx: offset added to src :py:class:`Point` array x-axis coordinates
        :dy: offset added to src :py:class:`Point` array y-axis coordinates
        :mode: :py:attr:`~Path.kAppend_AddPathMode` or
            :py:attr:`~Path.kExtend_AddPathMode`

        refe:return: rence to :py:class:`Path`
        """
    @typing.overload
    def addPath(self, src: Path, mode: Path.AddPathMode = ...) -> Path:
        """
        Appends src to :py:class:`Path`.

        If mode is :py:attr:`~Path.kAppend_AddPathMode`, src verb array,
        :py:class:`Point` array, and conic weights are added unaltered. If mode
        is :py:attr:`~Path.kExtend_AddPathMode`, add line before appending
        verbs, :py:class:`Point`, and conic weights.

        :src: :py:class:`Path` verbs, :py:class:`Point`, and conic weights to
            add
        :mode: :py:attr:`~Path.kAppend_AddPathMode` or
            :py:attr:`~Path.kExtend_AddPathMode`

        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addPath(self, src: Path, matrix: Matrix, mode: Path.AddPathMode = ...) -> Path:
        """
        Appends src to :py:class:`Path`, transformed by matrix.

        Transformed curves may have different verbs, :py:class:`Point`, and
        conic weights.

        If mode is :py:attr:`~Path.kAppend_AddPathMode`, src verb array,
        :py:class:`Point` array, and conic weights are added unaltered. If mode
        is :py:attr:`~Path.kExtend_AddPathMode`, add line before appending
        verbs, :py:class:`Point`, and conic weights.

        :src: :py:class:`Path` verbs, :py:class:`Point`, and conic weights to
            add
        :matrix: transform applied to src
        :mode: :py:attr:`~Path.kAppend_AddPathMode` or
            :py:attr:`~Path.kExtend_AddPathMode`

        :return: reference to :py:class:`Path`
        """
    def addPoly(self, pts: list[Point], close: bool) -> Path:
        """
        Adds contour created from pts.

        Contour added starts at pts[0], then adds a line for every additional
        :py:class:`Point` in pts. If close is true, appends
        :py:attr:`~skia.Path.kClose_Verb` to :py:class:`Path`, connecting last
        and first :py:class:`Point` in pts.

        If pts is empty, append :py:attr:`~skia.Path.kMove_Verb` to path.

        :param pts: iterable of :py:class:`Point`
        :param close: true to add line connecting contour end and start
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRRect(self, rrect: RRect, dir: PathDirection = ...) -> Path:
        """
        Adds rrect to :py:class:`Path`, creating a new closed contour.

        If dir is :py:attr:`~skia.PathDirection.kCW`, rrect starts at top-left
        of the lower-left corner and winds clockwise. If dir is
        :py:attr:`~skia.PathDirection.kCCW`, rrect starts at the bottom-left of
        the upper-left corner and winds counterclockwise.

        After appending, :py:class:`Path` may be empty, or may contain:
        :py:class:`Rect`, oval, or :py:class:`RRect`.

        :rrect: bounds and radii of rounded rectangle
        :dir: :py:class:`Path`::Direction to wind :py:class:`RRect`
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRRect(self, rrect: RRect, dir: PathDirection, start: int) -> Path:
        """
        Adds rrect to :py:class:`Path`, creating a new closed contour.

        If dir is:py:attr:`~skia.PathDirection.kCW`, rrect winds clockwise; if
        dir is :py:attr:`~skia.PathDirection.kCCW`, rrect winds
        counterclockwise. start determines the first point of rrect to add.

        :rrect: bounds and radii of rounded rectangle
        :dir: :py:class:`Path`::Direction to wind :py:class:`RRect`
        :start: index of initial point of :py:class:`RRect`
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRect(self, rect: Rect, dir: PathDirection = ...) -> Path:
        """
        Adds :py:class:`Rect` to :py:class:`Path`, appending
        :py:attr:`~skia.Path.kMove_Verb`, three
        :py:attr:`~skia.Path.kLine_Verb`, and :py:attr:`~skia.Path.kClose_Verb`,
        starting with top-left corner of :py:class:`Rect`; followed by
        top-right, bottom-right, and bottom-left if dir is
        :py:attr:`~skia.Direction.kCW`; or followed by bottom-left,
        bottom-right, and top-right if dir is :py:attr:`~skia._Direction.kCCW`

        :rect: :py:class:`Rect` to add as a closed contour
        :dir: :py:class:`Path`::Direction to wind added contour
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRect(self, rect: Rect, dir: PathDirection, start: int) -> Path:
        """
        Adds :py:class:`Rect` to :py:class:`Path`, appending
        :py:attr:`~skia.Path.kMove_Verb`, three
        :py:attr:`~skia.Path.kLine_Verb`, and k:py:attr:`~skia.Path.Verb.Close`.

        If dir is :py:attr:`~skia.PathDirection.kCW`, :py:class:`Rect` corners
        are added clockwise; if dir is :py:attr:`~skia.PathDirection.kCCW`,
        :py:class:`Rect` corners are added counterclockwise. start determines
        the first corner added.

        :rect: :py:class:`Rect` to add as a closed contour
        :dir: :py:class:`Path`::Direction to wind added contour
        :start: initial corner of :py:class:`Rect` to add

        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRect(
        self,
        left: float,
        top: float,
        right: float,
        bottom: float,
        dir: PathDirection = ...,
    ) -> Path:
        """
        Adds :py:class:`Rect` (left, top, right, bottom) to :py:class:`Path`,
        appending :py:attr:`~skia.Path.kMove_Verb`, three
        :py:attr:`~skia.Path.kLine_Verb`, and :py:attr:`~skia.Path.kClose_Verb`,
        starting with top-left corner of :py:class:`Rect`; followed by
        top-right, bottom-right, and bottom-left if dir is
        :py:attr:`~skia.PathDirection.kCW`; or followed by bottom-left,
        bottom-right, and top-right if dir is
        :py:attr:`~skia.PathDirection.kCCW`.

        :left: smaller x-axis value of :py:class:`Rect`
        :top: smaller y-axis value of :py:class:`Rect`
        :right: larger x-axis value of :py:class:`Rect`
        :bottom: larger y-axis value of :py:class:`Rect`
        :dir: :py:class:`Path`::Direction to wind added contour

        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRoundRect(
        self,
        rect: Rect,
        rx: float,
        ry: float,
        dir: PathDirection = ...,
    ) -> Path:
        """
        Appends :py:class:`RRect` to :py:class:`Path`, creating a new closed
        contour.

        :py:class:`RRect` has bounds equal to rect; each corner is 90 degrees of
        an ellipse with radii (rx, ry). If dir is
        :py:attr:`~skia.PathDirection.kCW`, :py:class:`RRect` starts at top-left
        of the lower-left corner and winds clockwise. If dir is
        :py:attr:`~skia.PathDirection.kCCW`, :py:class:`RRect` starts at the
        bottom-left of the upper-left corner and winds counterclockwise.

        If either rx or ry is too large, rx and ry are scaled uniformly until
        the corners fit. If rx or ry is less than or equal to zero,
        :py:meth:`addRoundRect` appends :py:class:`Rect` rect to
        :py:class:`Path`.

        After appending, :py:class:`Path` may be empty, or may contain:
        :py:class:`Rect`, oval, or :py:class:`RRect`.

        :rect: bounds of :py:class:`RRect`
        :rx: x-axis radius of rounded corners on the :py:class:`RRect`
        :ry: y-axis radius of rounded corners on the :py:class:`RRect`
        :dir: :py:class:`Path`::Direction to wind :py:class:`RRect`
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def addRoundRect(
        self,
        rect: Rect,
        radii: typing.Iterable,
        dir: PathDirection = ...,
    ) -> Path:
        """
        Appends :py:class:`RRect` to :py:class:`Path`, creating a new closed
        contour.

        :py:class:`RRect` has bounds equal to rect; each corner is 90 degrees of
        an ellipse with radii from the array.

        :rect: bounds of :py:class:`RRect`
        :radii: array of 8 :py:class:`Scalar` values, a radius pair for each
            corner
        :dir: :py:class:`Path`::Direction to wind :py:class:`RRect`
        :Returns: reference to :py:class:`Path`
        """
    def approximateBytesUsed(self) -> int:
        """
        Returns the approximate byte size of the SkPath in memory.

        :return: approximate size
        """
    @typing.overload
    def arcTo(
        self,
        oval: Rect,
        startAngle: float,
        sweepAngle: float,
        forceMoveTo: bool,
    ) -> Path:
        """
        Appends arc to :py:class:`Path`.

        Arc added is part of ellipse bounded by oval, from startAngle through
        sweepAngle. Both startAngle and sweepAngle are measured in degrees,
        where zero degrees is aligned with the positive x-axis, and positive
        sweeps extends arc clockwise.

        :py:meth:`arcTo` adds line connecting :py:class:`Path` last
        :py:class:`Point` to initial arc :py:class:`Point` if forceMoveTo is
        false and :py:class:`Path` is not empty. Otherwise, added contour begins
        with first point of arc. Angles greater than -360 and less than 360 are
        treated modulo 360.

        :oval: bounds of ellipse containing arc
        :startAngle: starting angle of arc in degrees
        :sweepAngle: sweep, in degrees. Positive is clockwise; treated modulo
            360
        :forceMoveTo: true to start a new contour with arc
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def arcTo(self, x1: float, y1: float, x2: float, y2: float, radius: float) -> Path:
        """
        Appends arc to :py:class:`Path`, after appending line if needed.

        Arc is implemented by conic weighted to describe part of circle. Arc is
        contained by tangent from last :py:class:`Path` point to (x1, y1), and
        tangent from (x1, y1) to (x2, y2). Arc is part of circle sized to
        radius, positioned so it touches both tangent lines.

        If last Path Point does not start Arc, :py:meth:`arcTo` appends
        connecting Line to Path. The length of Vector from (x1, y1) to (x2, y2)
        does not affect Arc.

        Arc sweep is always less than 180 degrees. If radius is zero, or if
        tangents are nearly parallel, :py:meth:`arcTo` appends Line from last
        Path Point to (x1, y1).

        :py:meth:`arcTo` appends at most one Line and one conic.
        :py:meth:`arcTo` implements the functionality of PostScript arct and
        HTML Canvas arcTo.

        :x1: x-axis value common to pair of tangents
        :y1: y-axis value common to pair of tangents
        :x2: x-axis value end of second tangent
        :y2: y-axis value end of second tangent
        :radius: distance from arc to circle center
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def arcTo(self, p1: Point, p2: Point, radius: float) -> Path:
        """
        Appends arc to :py:class:`Path`, after appending line if needed.

        Arc is implemented by conic weighted to describe part of circle. Arc is
        contained by tangent from last :py:class:`Path` point to p1, and tangent
        from p1 to p2. Arc is part of circle sized to radius, positioned so it
        touches both tangent lines.

        If last :py:class:`Path` :py:class:`Point` does not start arc,
        :py:meth:`arcTo` appends connecting line to :py:class:`Path`. The length
        of vector from p1 to p2 does not affect arc.

        Arc sweep is always less than 180 degrees. If radius is zero, or if
        tangents are nearly parallel, :py:meth:`arcTo` appends line from last
        :py:class:`Path` :py:class:`Point` to p1.

        :py:meth:`arcTo` appends at most one line and one conic.
        :py:meth:`arcTo` implements the functionality of PostScript arct and
        HTML Canvas arcTo.

        :p1: :py:class:`Point` common to pair of tangents
        :p2: end of second tangent
        :radius: distance from arc to circle center
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def arcTo(
        self,
        rx: float,
        ry: float,
        xAxisRotate: float,
        largeArc: Path.ArcSize,
        sweep: PathDirection,
        x: float,
        y: float,
    ) -> Path:
        """
        Appends arc to :py:class:`Path`.

        Arc is implemented by one or more conics weighted to describe part of
        oval with radii (rx, ry) rotated by xAxisRotate degrees. Arc curves from
        last :py:class:`Path` :py:class:`Point` to (x, y), choosing one of four
        possible routes: clockwise or counterclockwise, and smaller or larger.

        Arc sweep is always less than 360 degrees. :py:meth:`arcTo` appends line
        to (x, y) if either radii are zero, or if last :py:class:`Path`
        :py:class:`Point` equals (x, y). :py:meth:`arcTo` scales radii (rx, ry)
        to fit last :py:class:`Path` :py:class:`Point` and (x, y) if both are
        greater than zero but too small.

        :py:meth:`arcTo` appends up to four conic curves. :py:meth:`arcTo`
        implements the functionality of SVG arc, although SVG sweep-flag value
        is opposite the integer value of sweep; SVG sweep-flag uses 1 for
        clockwise, while :py:attr:`~skia.PathDirection.kCW` cast to int is zero.

        :rx: radius on x-axis before x-axis rotation
        :ry: radius on y-axis before x-axis rotation
        :xAxisRotate: x-axis rotation in degrees; positive values are clockwise
        :largeArc: chooses smaller or larger arc
        :sweep: chooses clockwise or counterclockwise arc
        :x: end of arc
        :y: end of arc
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def arcTo(
        self,
        r: Point,
        xAxisRotate: float,
        largeArc: Path.ArcSize,
        sweep: PathDirection,
        xy: Point,
    ) -> Path:
        """
        Appends arc to :py:class:`Path`.

        Arc is implemented by one or more conic weighted to describe part of
        oval with radii (r.fX, r.fY) rotated by xAxisRotate degrees. Arc curves
        from last :py:class:`Path` :py:class:`Point` to (xy.fX, xy.fY), choosing
        one of four possible routes: clockwise or counterclockwise, and smaller
        or larger.

        Arc sweep is always less than 360 degrees. :py:meth:`arcTo` appends line
        to xy if either radii are zero, or if last :py:class:`Path`
        :py:class:`Point` equals (xy.fX, xy.fY). :py:meth:`arcTo` scales radii r
        to fit last :py:class:`Path` :py:class:`Point` and xy if both are
        greater than zero but too small to describe an arc.

        :py:meth:`arcTo` appends up to four conic curves. :py:meth:`arcTo`
        implements the functionality of SVG arc, although SVG sweep-flag value
        is opposite the integer value of sweep; SVG sweep-flag uses 1 for
        clockwise, while :py:attr:`~skia.PathDirection.kCW` cast to int is zero.

        :r: radii on axes before x-axis rotation
        :xAxisRotate: x-axis rotation in degrees; positive values are clockwise
        :largeArc: chooses smaller or larger arc
        :sweep: chooses clockwise or counterclockwise arc
        :xy: end of arc
        :return: reference to :py:class:`Path`
        """
    def close(self) -> Path:
        """
        Appends :py:attr:`Path.Verb.kClose` to :py:class:`Path`.

        A closed contour connects the first and last :py:class:`Point` with
        line, forming a continuous loop. Open and closed contour draw the same
        with :py:attr:`Paint.kFill_Style`. With :py:attr:`Paint.kStroke_Style`,
        open contour draws :py:class:`Paint.Cap` at contour start and end;
        closed contour draws :py:class:`Paint.Join` at contour start and end.

        :py:meth:`close` has no effect if :py:class:`Path` is empty or last
        :py:class:`Path` :py:class:`~Path.Verb` is :py:attr:`Path.Verb.kClose`.

        :return: reference to :py:class:`Path`
        """
    def computeTightBounds(self) -> Rect:
        """
        Returns minimum and maximum axes values of the lines and curves in
        :py:class:`Path`.

        Returns (0, 0, 0, 0) if :py:class:`Path` contains no points. Returned
        bounds width and height may be larger or smaller than area affected when
        :py:class:`Path` is drawn.

        Includes :py:class:`Point` associated with kMove_Verb that define empty
        contours.

        Behaves identically to :py:meth:`getBounds` when :py:class:`Path`
        contains only lines. If :py:class:`Path` contains curves, computed
        bounds includes the maximum extent of the quad, conic, or cubic; is
        slower than :py:meth:`getBounds`; and unlike :py:meth:`getBounds`, does
        not cache the result.

        :return: tight bounds of curves in :py:class:`Path`
        """
    @typing.overload
    def conicTo(self, x1: float, y1: float, x2: float, y2: float, w: float) -> Path:
        """
        Adds conic from last point towards (x1, y1), to (x2, y2), weighted by w.

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding conic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed.

        If w is finite and not one, appends :py:attr:`~skia.Path.kConic_Verb` to
        verb array; and (x1, y1), (x2, y2) to :py:class:`Point` array; and w to
        conic weights.

        If w is one, appends :py:attr:`~skia.Path.kQuad_Verb` to verb array, and
        (x1, y1), (x2, y2) to :py:class:`Point` array.

        If w is not finite, appends :py:attr:`~skia.Path.kLine_Verb` twice to
        verb array, and (x1, y1), (x2, y2) to :py:class:`Point` array.

        :x1: control :py:class:`Point` of conic on x-axis
        :y1: control :py:class:`Point` of conic on y-axis
        :x2: end :py:class:`Point` of conic on x-axis
        :y2: end :py:class:`Point` of conic on y-axis
        :w: weight of added conic

        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def conicTo(self, p1: Point, p2: Point, w: float) -> Path:
        """
        Adds conic from last point towards :py:class:`Point` p1, to
        :py:class:`Point` p2, weighted by w.

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding conic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed.

        If w is finite and not one, appends :py:attr:`~skia.Path.kConic_Verb` to
        verb array; and :py:class:`Point` p1, p2 to :py:class:`Point` array; and
        w to conic weights.

        If w is one, appends :py:attr:`~skia.Path.kQuad_Verb` to verb array, and
        :py:class:`Point` p1, p2 to :py:class:`Point` array.

        If w is not finite, appends :py:attr:`~skia.Path.kLine_Verb` twice to
        verb array, and :py:class:`Point` p1, p2 to :py:class:`Point` array.

        :p1: control :py:class:`Point` of added conic
        :p2: end :py:class:`Point` of added conic
        :w: weight of added conic
        :return: reference to :py:class:`Path`
        """
    def conservativelyContainsRect(self, rect: Rect) -> bool:
        """
        Returns true if rect is contained by :py:class:`Path`.

        May return false when rect is contained by :py:class:`Path`.

        For now, only returns true if :py:class:`Path` has one contour and is
        convex. rect may share points and edges with :py:class:`Path` and be
        contained. Returns true if rect is empty, that is, it has zero width or
        height; and the :py:class:`Point` or line described by rect is contained
        by :py:class:`Path`.

        :param skia.Rect rect: :py:class:`Rect`, line, or :py:class:`Point`
            checked for containment
        :return: true if rect is contained
        """
    def contains(self, x: float, y: float) -> bool:
        """
        Returns true if the point (x, y) is contained by :py:class:`Path`,
        taking into account FillType.

        :param float x: x-axis value of containment test
        :param float y: y-axis value of containment test
        :return: true if :py:class:`Point` is in :py:class:`Path`
        """
    def countPoints(self) -> int:
        """
        Returns the number of points in :py:class:`Path`.

        :py:class:`Point` count is initially zero.

        :return: :py:class:`Path` :py:class:`Point` array length
        """
    def countVerbs(self) -> int:
        """
        Returns the number of verbs: :py:attr:`~Path.kMove_Verb`,
        :py:attr:`~Path.kLine_Verb`, :py:attr:`~Path.kQuad_Verb`,
        :py:attr:`~Path.kConic_Verb`, :py:attr:`~Path.kCubic_Verb`, and
        :py:attr:`~Path.kClose_Verb`; added to :py:class:`Path`.

        :return: length of verb array
        """
    @typing.overload
    def cubicTo(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        x3: float,
        y3: float,
    ) -> Path:
        """
        Adds cubic from last point towards (x1, y1), then towards (x2, y2),
        ending at (x3, y3).

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding cubic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kCubic_Verb` to verb array; and (x1, y1), (x2, y2),
        (x3, y3) to :py:class:`Point` array.

        :x1: first control :py:class:`Point` of cubic on x-axis
        :y1: first control :py:class:`Point` of cubic on y-axis
        :x2: second control :py:class:`Point` of cubic on x-axis
        :y2: second control :py:class:`Point` of cubic on y-axis
        :x3: end :py:class:`Point` of cubic on x-axis
        :y3: end :py:class:`Point` of cubic on y-axis
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def cubicTo(self, p1: Point, p2: Point, p3: Point) -> Path:
        """
        Adds cubic from last point towards :py:class:`Point` p1, then towards
        :py:class:`Point` p2, ending at :py:class:`Point` p3.

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding cubic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kCubic_Verb` to verb array; and :py:class:`Point`
        p1, p2, p3 to :py:class:`Point` array.

        :p1: first control :py:class:`Point` of cubic
        :p2: second control :py:class:`Point` of cubic
        :p3: end :py:class:`Point` of cubic
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def dump(self, stream: WStream, dumpAsHex: bool) -> None:
        """
        Writes text representation of :py:class:`Path` to stream.

        If stream is nullptr, writes to standard output. Set forceClose to true
        to get edges used to fill :py:class:`Path`. Set dumpAsHex true to
        generate exact binary representations of floating point numbers used in
        :py:class:`Point` array and conic weights.

        :stream: writable :py:class:`WStream` receiving :py:class:`Path` text
            representation; may be nullptr
        :dumpAsHex: true if :py:class:`Scalar` values are written as hexadecimal
        """
    @typing.overload
    def dump(self) -> None:
        """
        Writes text representation of :py:class:`Path` to standard output.

        The representation may be directly compiled as C++ code. Floating point
        values are written with limited precision; it may not be possible to
        reconstruct original :py:class:`Path` from output.
        """
    def dumpHex(self) -> None:
        """
        Writes text representation of :py:class:`Path` to standard output.

        The representation may be directly compiled as C++ code. Floating point
        values are written in hexadecimal to preserve their exact bit pattern.
        The output reconstructs the original :py:class:`Path`.

        Use instead of :py:meth:`dump` when submitting
        """
    def getBounds(self) -> Rect:
        """
        Returns minimum and maximum axes values of :py:class:`Point` array.

        Returns (0, 0, 0, 0) if :py:class:`Path` contains no points. Returned
        bounds width and height may be larger or smaller than area affected when
        :py:class:`Path` is drawn.

        :py:class:`Rect` returned includes all :py:class:`Point` added to
        :py:class:`Path`, including :py:class:`Point` associated with
        :py:attr:`~Path.kMove_Verb` that define empty contours.

        :return: bounds of all :py:class:`Point` in :py:class:`Point` array
        """
    def getFillType(self) -> PathFillType:
        """
        Returns :py:class:`PathFillType`, the rule used to fill
        :py:class:`Path`.

        :return: current :py:class:`PathFillType` setting
        """
    def getGenerationID(self) -> int:
        """
        (See Skia bug 1762.) Returns a non-zero, globally unique value.

        A different value is returned if verb array, :py:class:`Point` array, or
        conic weight changes.

        Setting :py:class:`Path.FillType` does not change generation identifier.

        Each time the path is modified, a different generation identifier will
        be returned. :py:class:`Path.FillType` does affect generation identifier
        on Android framework.

        :return: non-zero, globally unique value
        """
    def getLastPt(self, lastPt: Point | None = None) -> bool:
        """
        Returns last point on :py:class:`Path` in lastPt.

        Returns false if :py:class:`Point` array is empty, storing (0, 0) if
        lastPt is not nullptr.

        :param skia.Point lastPt: storage for final :py:class:`Point` in
            :py:class:`Point` array; may be nullptr
        :return: true if :py:class:`Point` array contains one or more
            :py:class:`Point`
        """
    def getPoint(self, index: int) -> Point:
        """
        Returns :py:class:`Point` at index in :py:class:`Point` array.

        Valid range for index is 0 to countPoints() - 1. Returns (0, 0) if index
        is out of range.

        :param skia.Point index: :py:class:`Point` array element selector
        :return: :py:class:`Point` array value or (0, 0)
        """
    def getPoints(self, max: int = 0) -> list[Point]:
        """
        Returns number of points in :py:class:`Path`.

        Up to max points are copied. If max is greater than number of points,
        excess points storage is removed. If max is zero, calls
        :py:meth:`countPoints` to get max.

        :param int max: maximum to copy; must be greater than or equal to zero
        :return: List of :py:class:`skia.Point`
        :rtype: List[skia.Point]
        """
    def getSegmentMasks(self) -> int:
        """
        Returns a mask, where each set bit corresponds to a
        :py:class:`~Path.SegmentMask` constant if :py:class:`Path` contains one
        or more verbs of that type.

        Returns zero if :py:class:`Path` contains no lines, or curves: quads,
        conics, or cubics.

        :py:meth:`getSegmentMasks` returns a cached result; it is very fast.

        :return: SegmentMask bits or zero
        """
    def getVerbs(self, max: int = 0) -> list[Path.Verb]:
        """
        Returns verbs in the path.

        Up to max verbs are copied. The verbs are copied as one byte per verb.

        :param int max: maximum number to copy into verbs
        :return: List of :py:class:`skia.Path.Verb`
        :rtype: List[skia.Path.Verb]
        """
    def incReserve(
        self,
        extraPtCount: int,
        extraVerbCount: int = 0,
        extraConicCount: int = 0,
    ) -> None:
        """
        Grows :py:class:`Path` verb array, :py:class:`Point` array and comics to contain
        extraPtCount additional :py:class:`Point`.

        May improve performance and use less memory by reducing the number and
        size of allocations when creating :py:class:`Path`.

        :param int extraPtCount: number of additional :py:class:`Point` to
            allocate
        :param int extraVerbCount: number of additional verbs
        :param int extraConicCount: number of additional conics
        """
    def interpolate(self, ending: Path, weight: float, out: Path) -> bool:
        """
        Interpolates between :py:class:`Path` with :py:class:`Point` array of
        equal size.

        Copy verb array and weights to out, and set out :py:class:`Point` array
        to a weighted average of this :py:class:`Point` array and ending
        :py:class:`Point` array, using the formula:
        `(Path Point * weight) + ending Point * (1 - weight)`.

        weight is most useful when between zero (ending :py:class:`Point` array)
        and one (this Point_Array); will work with values outside of this range.

        :py:meth:`interpolate` returns false and leaves out unchanged if
        :py:class:`Point` array is not the same size as ending
        :py:class:`Point` array. Call :py:meth:`isInterpolatable` to check
        :py:class:`Path` compatibility prior to calling :py:meth:`interpolate`.

        :param skia.Path ending: :py:class:`Point` array averaged with this
            :py:class:`Point` array
        :param float weight: contribution of this :py:class:`Point` array, and
            one minus contribution of ending :py:class:`Point` array
        :param skia.Path out: :py:class:`Path` replaced by interpolated averages

        :return: true if :py:class:`Path` contain same number of
            :py:class:`Point`
        """
    def isConvex(self) -> bool:
        """
        Returns true if the path is convex.

        If necessary, it will first compute the convexity.
        """
    def isEmpty(self) -> bool:
        """
        Returns if :py:class:`Path` is empty.

        Empty :py:class:`Path` may have FillType but has no :py:class:`Point`,
        :py:class:`Path.Verb`, or conic weight. :py:class:`Path`() constructs
        empty :py:class:`Path`; :py:meth:`reset` and :py:meth:`rewind` make
        :py:class:`Path` empty.

        :return: true if the path contains no :py:class:`Path.Verb` array
        """
    def isFinite(self) -> bool:
        """
        Returns true for finite :py:class:`Point` array values between negative
        SK_ScalarMax and positive SK_ScalarMax.

        Returns false for any :py:class:`Point` array value of
        SK_ScalarInfinity, SK_ScalarNegativeInfinity, or SK_ScalarNaN.

        :return: true if all :py:class:`Point` values are finite
        """
    def isInterpolatable(self, compare: Path) -> bool:
        """
        Returns true if :py:class:`Path` contain equal verbs and equal weights.

        If :py:class:`Path` contain one or more conics, the weights must match.

        :py:meth:`conicTo` may add different verbs depending on conic weight, so
        it is not trivial to interpolate a pair of :py:class:`Path` containing
        conics with different conic weight values.

        :param skia.Path compare: :py:class:`Path` to compare
        :return: true if :py:class:`Path` verb array and weights are equivalent
        """
    def isInverseFillType(self) -> bool:
        """
        Returns if FillType describes area outside :py:class:`Path` geometry.

        The inverse fill area extends indefinitely.

        :return: true if FillType is
            :py:attr:`~skia.PathFillType.kInverseWinding` or
            :py:attr:`~skia.PathFillType.kInverseEvenOdd`
        """
    def isLastContourClosed(self) -> bool:
        """
        Returns if contour is closed.

        Contour is closed if :py:class:`Path` :py:class:`~skia.Path.Verb` array
        was last modified by :py:meth:`close`. When stroked, closed contour
        draws :py:class:`~skia.Paint.Join` instead of
        :py:class:`~skia.Paint.Cap` at first and last :py:class:`Point`.

        :return: true if the last contour ends with a
            :py:attr:`~skia.Path.kClose_Verb`
        """
    def isLine(self, p0: Point | None = None, p1: Point | None = None) -> bool:
        """
        Returns true if :py:class:`Path` contains only one line;
        :py:class:`~skia.Path.Verb` array has two entries:
        :py:attr:`~skia.Path.kMove_Verb`, :py:attr:`~skia.Path.kLine_Verb`.

        If :py:class:`Path` contains one line and line is not nullptr, line is
        set to line start point and line end point. Returns false if
        :py:class:`Path` is not one line; line is unaltered.

        :param skia.Point p0: storage for line start. May be nullptr
        :param skia.Point p1: storage for line end. May be nullptr
        :return: true if :py:class:`Path` contains exactly one line
        """
    def isOval(self, oval: Rect | None = None) -> bool:
        """
        Returns true if this path is recognized as an oval or circle.

        bounds receives bounds of oval.

        bounds is unmodified if oval is not found.

        :param skia.Rect bounds: storage for bounding :py:class:`Rect` of oval;
            may be nullptr
        :return: true if :py:class:`Path` is recognized as an oval or circle
        """
    def isRRect(self, rrect: RRect | None = None) -> bool:
        """
        Returns true if path is representable as :py:class:`RRect`.

        Returns false if path is representable as oval, circle, or
        :py:class:`Rect`.

        rrect receives bounds of :py:class:`RRect`.

        rrect is unmodified if :py:class:`RRect` is not found.

        :param skia.RRect rrect: storage for bounding :py:class:`Rect` of
            :py:class:`RRect`; may be nullptr
        :return: true if :py:class:`Path` contains only :py:class:`RRect`
        """
    def isRect(
        self,
        rect: Rect | None = None,
        isClosed: bool | None = None,
        direction: PathDirection | None = None,
    ) -> bool:
        """
        Returns true if :py:class:`Path` is equivalent to :py:class:`Rect` when
        filled.

        If false: rect, isClosed, and direction are unchanged. If true: rect,
        isClosed, and direction are written to if not nullptr.

        rect may be smaller than the :py:class:`Path` bounds. :py:class:`Path`
        bounds may include :py:attr:`~skia.Path.kMove_Verb` points that do not
        alter the area drawn by the returned rect.

        :param rect: storage for bounds of :py:class:`Rect`; may be nullptr
        :param isClosed: storage set to true if :py:class:`Path` is closed; may
            be nullptr
        :param direction: storage set to :py:class:`Rect` direction; may be
            nullptr
        :return: true if :py:class:`Path` contains :py:class:`Rect`
        """
    def isValid(self) -> bool:
        """
        Returns if :py:class:`Path` data is consistent.

        Corrupt :py:class:`Path` data is detected if internal values are out of
        range or internal storage does not match array dimensions.

        :return: true if :py:class:`Path` data is consistent
        """
    def isVolatile(self) -> bool:
        """
        Returns true if the path is volatile; it will not be altered or
        discarded by the caller after it is drawn.

        :py:class:`Path` by default have volatile set false, allowing
        :py:class:`Surface` to attach a cache of data which speeds repeated
        drawing. If true, :py:class:`Surface` may not speed repeated drawing.

        :return: true if caller will alter :py:class:`Path` after drawing
        """
    @typing.overload
    def lineTo(self, x: float, y: float) -> Path:
        """
        Adds line from last point to (x, y).

        If :py:class:`Path` is empty, or last :py:class:`~Path.Verb` is
        :py:attr:`~Path.kClose_Verb`, last point is set to (0, 0) before adding
        line.

        lineTo() appends :py:attr:`~Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed. lineTo() then appends
        :py:attr:`~Path.kLine_Verb` to verb array and (x, y) to
        :py:class:`Point` array.

        :x: end of added line on x-axis
        :y: end of added line on y-axis
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def lineTo(self, p: Point) -> Path:
        """
        Adds line from last point to :py:class:`Point` p.

        If :py:class:`Path` is empty, or last :py:class:`~Path.Verb` is
        :py:attr:`~Path.kClose_Verb`, last point is set to (0, 0) before adding
        line.

        lineTo() appends :py:attr:`~Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed. lineTo() then appends
        :py:attr:`~Path.kLine_Verb` to verb array and p to :py:class:`Point`
        array.

        :p: end :py:class:`Point` of added line
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def moveTo(self, x: float, y: float) -> Path:
        """
        Adds beginning of contour at :py:class:`Point` (x, y).

        :x: x-axis value of contour start
        :y: y-axis value of contour start
        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def moveTo(self, p: Point) -> Path:
        """
        Adds beginning of contour at :py:class:`Point` p.

        :p: contour start
        :return: reference to :py:class:`Path`
        """
    def offset(self, dx: float, dy: float, dst: Path | None = None) -> None:
        """
        Offsets :py:class:`Point` array by (dx, dy).

        Offset :py:class:`Path` replaces dst. If dst is nullptr,
        :py:class:`Path` is replaced by offset data.

        :param float dx:  offset added to :py:class:`Point` array x-axis
            coordinates
        :param float dy:  offset added to :py:class:`Point` array y-axis
            coordinates
        :param skia.Path dst: overwritten, translated copy of :py:class:`Path`;
            may be nullptr
        """
    @typing.overload
    def quadTo(self, x1: float, y1: float, x2: float, y2: float) -> Path:
        """
        Adds quad from last point towards (x1, y1), to (x2, y2).

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding quad.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kQuad_Verb` to verb array; and (x1, y1), (x2, y2)
        to :py:class:`Point` array.

        :x1: control :py:class:`Point` of quad on x-axis
        :y1: control :py:class:`Point` of quad on y-axis
        :x2: end :py:class:`Point` of quad on x-axis
        :y2: end :py:class:`Point` of quad on y-axis

        :return: reference to :py:class:`Path`
        """
    @typing.overload
    def quadTo(self, p1: Point, p2: Point) -> Path:
        """
        Adds quad from last point towards :py:class:`Point` p1, to
        :py:class:`Point` p2.

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding quad.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kQuad_Verb` to verb array; and :py:class:`Point`
        p1, p2 to :py:class:`Point` array.

        :p1: control :py:class:`Point` of added quad
        :p2: end :py:class:`Point` of added quad

        :return: reference to :py:class:`Path`
        """
    def rArcTo(
        self,
        rx: float,
        ry: float,
        xAxisRotate: float,
        largeArc: Path.ArcSize,
        sweep: PathDirection,
        dx: float,
        dy: float,
    ) -> Path:
        """
        Appends arc to :py:class:`Path`, relative to last :py:class:`Path`
        :py:class:`Point`.

        Arc is implemented by one or more conic, weighted to describe part of
        oval with radii (rx, ry) rotated by xAxisRotate degrees. Arc curves from
        last :py:class:`Path` :py:class:`Point` to relative end
        :py:class:`Point`: (dx, dy), choosing one of four possible routes:
        clockwise or counterclockwise, and smaller or larger. If
        :py:class:`Path` is empty, the start arc :py:class:`Point` is (0, 0).

        Arc sweep is always less than 360 degrees. :py:meth:`arcTo` appends line
        to end :py:class:`Point` if either radii are zero, or if last
        :py:class:`Path` :py:class:`Point` equals end :py:class:`Point`.
        :py:meth:`arcTo` scales radii (rx, ry) to fit last :py:class:`Path`
        :py:class:`Point` and end :py:class:`Point` if both are greater than
        zero but too small to describe an arc.

        :py:meth:`arcTo` appends up to four conic curves. :py:meth:`arcTo`
        implements the functionality of svg arc, although SVG "sweep-flag" value
        is opposite the integer value of sweep; SVG "sweep-flag" uses 1 for
        clockwise, while :py:attr:`~skia.PathDirection.kCW` cast to int is zero.

        :param float rx:  radius before x-axis rotation
        :param float ry:  radius before x-axis rotation
        :param float xAxisRotate: x-axis rotation in degrees; positive values
            are clockwise
        :param skia.ArcSize largeArc: chooses smaller or larger arc
        :param skia.PathDirection sweep: chooses clockwise or counterclockwise
            arc
        :param float dx: x-axis offset end of arc from last :py:class:`Path`
            :py:class:`Point`
        :param float dy: y-axis offset end of arc from last :py:class:`Path`
            :py:class:`Point`
        :return: reference to :py:class:`Path`
        """
    def rConicTo(
        self,
        dx1: float,
        dy1: float,
        dx2: float,
        dy2: float,
        w: float,
    ) -> Path:
        """
        Adds conic from last point towards vector (dx1, dy1), to vector (dx2,
        dy2), weighted by w.

        If :py:class:`Path` is empty, or last :py:class:`Path`::Verb is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding conic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed.

        If w is finite and not one, next appends
        :py:attr:`~skia.Path.kConic_Verb` to verb array, and w is recorded as
        conic weight; otherwise, if w is one, appends
        :py:attr:`~skia.Path.kQuad_Verb` to verb array; or if w is not finite,
        appends :py:attr:`~skia.Path.kLine_Verb` twice to verb array.

        In all cases appends :py:class:`Point` control and end to
        :py:class:`Point` array. control is last point plus vector (dx1, dy1).
        end is last point plus vector (dx2, dy2).

        Function name stands for "relative conic to".

        :param float dx1: offset from last point to conic control on x-axis
        :param float dy1: offset from last point to conic control on y-axis
        :param float dx2: offset from last point to conic end on x-axis
        :param float dy2: offset from last point to conic end on y-axis
        :param float w:   weight of added conic
        :return: reference to :py:class:`Path`
        """
    def rCubicTo(
        self,
        dx1: float,
        dy1: float,
        dx2: float,
        dy2: float,
        dx3: float,
        dy3: float,
    ) -> Path:
        """
        Adds cubic from last point towards vector (dx1, dy1), then towards
        vector (dx2, dy2), to vector (dx3, dy3).

        If :py:class:`Path` is empty, or last :py:class:`Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding cubic.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kCubic_Verb` to verb array; and appends cubic
        control and cubic end to :py:class:`Point` array. Cubic control is last
        point plus vector (dx1, dy1). Cubic end is last point plus vector (dx2,
        dy2). Function name stands for "relative cubic to".

        :param float dx1: offset from last point to first cubic control on
            x-axis
        :param float dy1: offset from last point to first cubic control on
            y-axis
        :param float dx2: offset from last point to second cubic control on
            x-axis
        :param float dy2: offset from last point to second cubic control on
            y-axis
        :param float dx3: offset from last point to cubic end on x-axis
        :param float dy3: offset from last point to cubic end on y-axis
        :return: reference to :py:class:`Path`
        """
    def rLineTo(self, dx: float, dy: float) -> Path:
        """
        Adds line from last point to vector (dx, dy).

        If :py:class:`Path` is empty, or last :py:class:`~Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding line.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kLine_Verb` to verb array and line end to
        :py:class:`Point` array. Line end is last point plus vector (dx, dy).
        Function name stands for "relative line to".

        :param float dx: offset from last point to line end on x-axis
        :param float dy: offset from last point to line end on y-axis
        :return: reference to :py:class:`Path`
        """
    def rMoveTo(self, dx: float, dy: float) -> Path:
        """
        Adds beginning of contour relative to last point.

        If :py:class:`Path` is empty, starts contour at (dx, dy). Otherwise,
        start contour at last point offset by (dx, dy). Function name stands for
        "relative move to".

        :param int dx: offset from last point to contour start on x-axis
        :param int dy: offset from last point to contour start on y-axis
        :return: reference to :py:class:`Path`
        """
    def rQuadTo(self, dx1: float, dy1: float, dx2: float, dy2: float) -> Path:
        """
        Adds quad from last point towards vector (dx1, dy1), to vector (dx2,
        dy2).

        If :py:class:`Path` is empty, or last :py:class:`~Path.Verb` is
        :py:attr:`~skia.Path.kClose_Verb`, last point is set to (0, 0) before
        adding quad.

        Appends :py:attr:`~skia.Path.kMove_Verb` to verb array and (0, 0) to
        :py:class:`Point` array, if needed; then appends
        :py:attr:`~skia.Path.kQuad_Verb` to verb array;and appends quad control
        and quad end to :py:class:`Point` array. Quad control is last point plus
        vector (dx1, dy1). Quad end is last point plus vector (dx2, dy2).
        Function name stands for "relative quad to".

        :param float dx1: offset from last point to quad control on x-axis
        :param float dy1: offset from last point to quad control on y-axis
        :param float dx2: offset from last point to quad end on x-axis
        :param float dy2: offset from last point to quad end on y-axis
        :return: reference to :py:class:`Path`
        """
    def readFromMemory(self, buffer: typing_extensions.Buffer) -> int:
        """
        Initializes :py:class:`Path` from buffer of size length.

        Returns zero if the buffer is data is inconsistent, or the length is too
        small.

        Reads :py:class:`Path.FillType`, verb array, :py:class:`Point` array,
        conic weight, and additionally reads computed information like
        :py:class:`Path.Convexity` and bounds.

        Used only in concert with :py:meth:`writeToMemory`; the format used for
        :py:class:`Path` in memory is not guaranteed.

        :param Union[bytes,bytearray,memoryview] buffer: storage for
            :py:class:`Path`
        :return: number of bytes read, or zero on failure
        """
    def reset(self) -> Path:
        """
        Sets :py:class:`Path` to its initial state.

        Removes verb array, :py:class:`Point` array, and weights, and sets
        FillType to kWinding. Internal storage associated with :py:class:`Path`
        is released.

        :return: reference to :py:class:`Path`
        """
    def reverseAddPath(self, src: Path) -> Path:
        """
        Appends src to :py:class:`Path`, from back to front.

        Reversed src always appends a new contour to :py:class:`Path`.

        :param src: :py:class:`Path` verbs, :py:class:`Point`, and conic weights
            to add
        :return: reference to :py:class:`Path`
        """
    def rewind(self) -> Path:
        """
        Sets :py:class:`Path` to its initial state, preserving internal storage.

        Removes verb array, :py:class:`Point` array, and weights, and sets
        FillType to kWinding. Internal storage associated with :py:class:`Path`
        is retained.

        Use :py:meth:`rewind` instead of :py:meth:`reset` if :py:class:`Path`
        storage will be reused and performance is critical.

        :return: reference to :py:class:`Path`
        """
    def serialize(self) -> Data:
        """
        Writes :py:class:`Path` to buffer, returning the buffer written to,
        wrapped in :py:class:`Data`.

        :py:meth:`serialize` writes :py:class:`~Path.FillType`, verb array,
        :py:class:`Point` array, conic weight, and additionally writes computed
        information like :py:class:`~Path.Convexity` and bounds.

        :py:meth:`serialize` should only be used in concert with
        :py:meth:`readFromMemory`. The format used for :py:class:`Path` in
        memory is not guaranteed.

        :return: :py:class:`Path` data wrapped in :py:class:`Data` buffer
        """
    def setFillType(self, ft: PathFillType) -> None:
        """
        Sets FillType, the rule used to fill :py:class:`Path`.

        While there is no check that ft is legal, values outside of FillType are
        not supported.
        """
    def setIsVolatile(self, isVolatile: bool) -> Path:
        """
        Specifies whether :py:class:`Path` is volatile; whether it will be
        altered or discarded by the caller after it is drawn.

        :py:class:`Path` by default have volatile set false, allowing
        :py:class:`BaseDevice` to attach a cache of data which speeds repeated
        drawing.

        Mark temporary paths, discarded or modified after use, as volatile to
        inform :py:class:`BaseDevice` that the path need not be cached.

        Mark animating :py:class:`Path` volatile to improve performance. Mark
        unchanging :py:class:`Path` non-volatile to improve repeated rendering.

        raster surface :py:class:`Path` draws are affected by volatile for some
        shadows. GPU surface :py:class:`Path` draws are affected by volatile for
        some shadows and concave geometries.

        :param bool isVolatile: true if caller will alter :py:class:`Path` after
            drawing
        """
    @typing.overload
    def setLastPt(self, x: float, y: float) -> None:
        """
        Sets last point to (x, y).

        If :py:class:`Point` array is empty, append
        :py:attr:`~skia.Path.kMove_Verb` to verb array and append (x, y) to
        :py:class:`Point` array.

        :x: set x-axis value of last point
        :y: set y-axis value of last point
        """
    @typing.overload
    def setLastPt(self, p: Point) -> None:
        """
        Sets the last point on the path.

        If :py:class:`Point` array is empty, append
        :py:attr:`~skia.Path.kMove_Verb` to verb array and append p to
        :py:class:`Point` array.

        :p: set value of last point
        """
    def swap(self, other: Path) -> None:
        """
        Exchanges the verb array, :py:class:`Point` array, weights, and
        :py:class:`PathFillType` with other.

        Cached state is also exchanged. :py:meth:`swap` internally exchanges
        pointers, so it is lightweight and does not allocate memory.

        :param skia.Path other: :py:class:`Path` exchanged by value
        """
    def toggleInverseFillType(self) -> None:
        """
        Replaces FillType with its inverse.

        The inverse of FillType describes the area unmodified by the original
        FillType.
        """
    def transform(
        self,
        matrix: Matrix,
        dst: Path | None = None,
        pc: ApplyPerspectiveClip = ...,
    ) -> None:
        """
        Transforms verb array, :py:class:`Point` array, and weight by matrix.

        transform may change verbs and increase their number. Transformed
        :py:class:`Path` replaces dst; if dst is nullptr, original data is
        replaced.

        :param skia.Matrix matrix: :py:class:`Matrix` to apply to
            :py:class:`Path`
        :param skia.Path dst: overwritten, transformed copy of :py:class:`Path`;
            may be nullptr
        :param skia.ApplyPerspectiveClip pc: whether to apply perspective
            clipping
        """
    def updateBoundsCache(self) -> None:
        """
        Updates internal bounds so that subsequent calls to :py:meth:`getBounds`
        are instantaneous.

        Unaltered copies of :py:class:`Path` may also access cached bounds
        through :py:meth:`getBounds`.

        For now, identical to calling :py:meth:`getBounds` and ignoring the
        returned value.

        Call to prepare :py:class:`Path` subsequently drawn from multiple
        threads, to avoid a race condition where each draw separately computes
        the bounds.
        """
    def writeToMemory(self) -> bytes:
        """
        Writes :py:class:`Path` to buffer, returning bytes.

        Writes :py:class:`~Path.FillType`, verb array, :py:class:`Point` array,
        conic weight, and additionally writes computed information like
        :py:class:`~Path.Convexity` and bounds.

        Use only be used in concert with :py:meth:`readFromMemory`; the format
        used for :py:class:`Path` in memory is not guaranteed.

        :return: serialized bytes
        """

class Path1DPathEffect:
    class Style:
        """
        Members:

          kTranslate_Style

          kRotate_Style

          kMorph_Style

          kLastEnum_Style
        """

        __members__: typing.ClassVar[
            dict[str, Path1DPathEffect.Style]
        ]  # value = {'kTranslate_Style': <Style.kTranslate_Style: 0>, 'kRotate_Style': <Style.kRotate_Style: 1>, 'kMorph_Style': <Style.kMorph_Style: 2>, 'kLastEnum_Style': <Style.kMorph_Style: 2>}
        kLastEnum_Style: typing.ClassVar[
            Path1DPathEffect.Style
        ]  # value = <Style.kMorph_Style: 2>
        kMorph_Style: typing.ClassVar[
            Path1DPathEffect.Style
        ]  # value = <Style.kMorph_Style: 2>
        kRotate_Style: typing.ClassVar[
            Path1DPathEffect.Style
        ]  # value = <Style.kRotate_Style: 1>
        kTranslate_Style: typing.ClassVar[
            Path1DPathEffect.Style
        ]  # value = <Style.kTranslate_Style: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kLastEnum_Style: typing.ClassVar[
        Path1DPathEffect.Style
    ]  # value = <Style.kMorph_Style: 2>
    kMorph_Style: typing.ClassVar[
        Path1DPathEffect.Style
    ]  # value = <Style.kMorph_Style: 2>
    kRotate_Style: typing.ClassVar[
        Path1DPathEffect.Style
    ]  # value = <Style.kRotate_Style: 1>
    kTranslate_Style: typing.ClassVar[
        Path1DPathEffect.Style
    ]  # value = <Style.kTranslate_Style: 0>
    @staticmethod
    def Make(
        path: Path,
        advance: float,
        phase: float,
        style: Path1DPathEffect.Style,
    ) -> PathEffect:
        """
        Dash by replicating the specified path.

        :param skia.Path path: The path to replicate (dash)
        :param float advance: The space between instances of path
        :param float phase: distance (mod advance) along path for its initial
            position
        :param skia.Path1DPathEffect.Style style: how to transform path at each
            point (based on the current position and tangent)
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Path2DPathEffect:
    @staticmethod
    def Make(matrix: Matrix, path: Path) -> PathEffect:
        """
        Stamp the specified path to fill the shape, using the matrix to define
        the latice.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class PathBuilder:
    class ArcSize:
        """
        Members:

          kSmall_ArcSize :
                smaller of arc pair


          kLarge_ArcSize :
                larger of arc pair

        """

        __members__: typing.ClassVar[
            dict[str, PathBuilder.ArcSize]
        ]  # value = {'kSmall_ArcSize': <ArcSize.kSmall_ArcSize: 0>, 'kLarge_ArcSize': <ArcSize.kLarge_ArcSize: 1>}
        kLarge_ArcSize: typing.ClassVar[
            PathBuilder.ArcSize
        ]  # value = <ArcSize.kLarge_ArcSize: 1>
        kSmall_ArcSize: typing.ClassVar[
            PathBuilder.ArcSize
        ]  # value = <ArcSize.kSmall_ArcSize: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kLarge_ArcSize: typing.ClassVar[
        PathBuilder.ArcSize
    ]  # value = <ArcSize.kLarge_ArcSize: 1>
    kSmall_ArcSize: typing.ClassVar[
        PathBuilder.ArcSize
    ]  # value = <ArcSize.kSmall_ArcSize: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, path: Path) -> None: ...
    def addArc(
        self,
        oval: Rect,
        startAngleDeg: float,
        sweepAngleDeg: float,
    ) -> PathBuilder:
        """
        Appends arc to the builder, as the start of new contour. Arc added is
        part of ellipse bounded by oval, from startAngle through sweepAngle.
        Both startAngle and sweepAngle are measured in degrees, where zero
        degrees is aligned with the positive x-axis, and positive sweeps
        extends arc clockwise.

        If sweepAngle <= -360, or sweepAngle >= 360; and startAngle modulo 90
        is nearly zero, append oval instead of arc. Otherwise, sweepAngle
        values are treated modulo 360, and arc may or may not draw depending
        on numeric rounding.

        :param oval:          bounds of ellipse containing arc
        :param startAngleDeg: starting angle of arc in degrees
        :param sweepAngleDeg: sweep, in degrees. Positive is clockwise; treated
                              modulo 360
        :return:              reference to this builder
        """
    def addCircle(
        self,
        center_x: float,
        center_y: float,
        radius: float,
        pathDirection: PathDirection = ...,
    ) -> PathBuilder: ...
    @typing.overload
    def addOval(
        self,
        rect: Rect,
        pathDirection: PathDirection,
        startIndex: int,
    ) -> PathBuilder: ...
    @typing.overload
    def addOval(
        self,
        rect: Rect,
        pathDirection: PathDirection = ...,
    ) -> PathBuilder: ...
    def addPolygon(self, points: list[Point], isClosed: bool) -> PathBuilder: ...
    @typing.overload
    def addRRect(
        self,
        rrect: RRect,
        pathDirection: PathDirection,
        startIndex: int,
    ) -> PathBuilder: ...
    @typing.overload
    def addRRect(
        self,
        rrect: RRect,
        pathDirection: PathDirection = ...,
    ) -> PathBuilder: ...
    @typing.overload
    def addRect(
        self,
        rect: Rect,
        pathDirection: PathDirection,
        startIndex: int,
    ) -> PathBuilder: ...
    @typing.overload
    def addRect(
        self,
        rect: Rect,
        pathDirection: PathDirection = ...,
    ) -> PathBuilder: ...
    @typing.overload
    def arcTo(
        self,
        oval: Rect,
        startAngleDeg: float,
        sweepAngleDeg: float,
        forceMoveTo: bool,
    ) -> PathBuilder:
        """
        Appends arc to the builder. Arc added is part of ellipse
        bounded by oval, from startAngle through sweepAngle. Both startAngle and
        sweepAngle are measured in degrees, where zero degrees is aligned with
        the positive x-axis, and positive sweeps extends arc clockwise.

        arcTo() adds line connecting the builder's last point to initial arc
        point if forceMoveTo is false and the builder is not empty. Otherwise,
        added contour begins with first point of arc. Angles greater than -360
        and less than 360 are treated modulo 360.

        :param oval:          bounds of ellipse containing arc
        :param startAngleDeg: starting angle of arc in degrees
        :param sweepAngleDeg: sweep, in degrees. Positive is clockwise; treated
                              modulo 360
        :param forceMoveTo:   true to start a new contour with arc
        :return:              reference to the builder
        """
    @typing.overload
    def arcTo(self, p1: Point, p2: Point, radius: float) -> PathBuilder:
        """
        Appends arc to :py:class:`Path`, after appending line if needed. Arc
        is implemented by conic weighted to describe part of circle. Arc is
        contained by tangent from last :py:class:`Path` point to p1, and
        tangent from p1 to p2. Arc is part of circle sized to radius,
        positioned so it touches both tangent lines.

        If last :py:class:`Path` SkPoint does not start arc, arcTo() appends
        connecting line to :py:class:`Path`. The length of vector from p1 to
        p2 does not affect arc.

        Arc sweep is always less than 180 degrees. If radius is zero, or if
        tangents are nearly parallel, arcTo() appends line from last
        :py:class:`Path` SkPoint to p1.

        arcTo() appends at most one line and one conic. arcTo() implements the
        functionality of PostScript arct and HTML Canvas arcTo.

        :param p1:      SkPoint common to pair of tangents
        :param p2:      end of second tangent
        :param radius:  distance from arc to circle center
        :return:        reference to :py:class:`Path`
        """
    @typing.overload
    def arcTo(
        self,
        r: Point,
        xAxisRotate: float,
        largeArc: PathBuilder.ArcSize,
        sweep: PathDirection,
        xy: Point,
    ) -> PathBuilder:
        """
        Appends arc to :py:class:`Path`. Arc is implemented by one or more
        conic weighted to describe part of oval with radii (r.fX, r.fY)
        rotated by xAxisRotate degrees. Arc curves from last :py:class:`Path`
        :py:class:`Point` to (xy.fX, xy.fY), choosing one of four possible
        routes: clockwise or counterclockwise, and smaller or larger.

        Arc sweep is always less than 360 degrees. arcTo() appends line to xy
        if either radii are zero, or if last :py:class:`Path` :py:class:`Point`
        equals (xy.fX, xy.fY). arcTo() scales radii r to fit last
        :py:class:`Path` :py:class:`Point` and xy if both are greater than zero
        but too small to describe an arc.

        arcTo() appends up to four conic curves. arcTo() implements the
        functionality of SVG arc, although SVG sweep-flag value is opposite
        the integer value of sweep; SVG sweep-flag uses 1 for clockwise, while
        kCW_Direction cast to int is zero.

        :param r:            radii on axes before x-axis rotation
        :param xAxisRotate:  x-axis rotation in degrees; positive values are
                             clockwise
        :param largeArc:     chooses smaller or larger arc
        :param sweep:        chooses clockwise or counterclockwise arc
        :param xy:           end of arc
        :return:             reference to :py:class:`Path`
        """
    def close(self) -> PathBuilder: ...
    def computeBounds(self) -> Rect: ...
    @typing.overload
    def conicTo(self, pt1: Point, pt2: Point, w: float) -> PathBuilder: ...
    @typing.overload
    def conicTo(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        w: float,
    ) -> PathBuilder: ...
    @typing.overload
    def conicTo(self, pts: list[Point], w: float) -> PathBuilder: ...
    @typing.overload
    def cubicTo(self, pt1: Point, pt2: Point, pt3: Point) -> PathBuilder: ...
    @typing.overload
    def cubicTo(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        x3: float,
        y3: float,
    ) -> PathBuilder: ...
    @typing.overload
    def cubicTo(self, pts: list[Point]) -> PathBuilder: ...
    def detach(self) -> Path:
        """
        the builder is reset to empty after returning this path
        """
    def fillType(self) -> PathFillType: ...
    @typing.overload
    def incReserve(self, extraPtCount: int, extraVerbCount: int) -> None:
        """
        Performance hint, to reserve extra storage for subsequent calls to
        lineTo, quadTo, etc.
        """
    @typing.overload
    def incReserve(self, extraPtCount: int) -> None: ...
    @typing.overload
    def lineTo(self, pt: Point) -> PathBuilder: ...
    @typing.overload
    def lineTo(self, x: float, y: float) -> PathBuilder: ...
    @typing.overload
    def moveTo(self, pt: Point) -> PathBuilder: ...
    @typing.overload
    def moveTo(self, x: float, y: float) -> PathBuilder: ...
    def offset(self, dx: float, dy: float) -> PathBuilder: ...
    def polylineTo(self, points: list[Point]) -> PathBuilder:
        """
        Append a series of lineTo(...)
        """
    @typing.overload
    def quadTo(self, pt1: Point, pt2: Point) -> PathBuilder: ...
    @typing.overload
    def quadTo(self, x1: float, y1: float, x2: float, y2: float) -> PathBuilder: ...
    @typing.overload
    def quadTo(self, pts: list[Point]) -> PathBuilder: ...
    @typing.overload
    def rConicTo(self, pt1: Point, pt2: Point, w: float) -> PathBuilder: ...
    @typing.overload
    def rConicTo(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        w: float,
    ) -> PathBuilder: ...
    @typing.overload
    def rCubicTo(self, pt1: Point, pt2: Point, pt3: Point) -> PathBuilder: ...
    @typing.overload
    def rCubicTo(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        x3: float,
        y3: float,
    ) -> PathBuilder: ...
    @typing.overload
    def rLineTo(self, pt: Point) -> PathBuilder: ...
    @typing.overload
    def rLineTo(self, x: float, y: float) -> PathBuilder: ...
    @typing.overload
    def rQuadTo(self, pt1: Point, pt2: Point) -> PathBuilder: ...
    @typing.overload
    def rQuadTo(self, x1: float, y1: float, x2: float, y2: float) -> PathBuilder: ...
    def reset(self) -> PathBuilder: ...
    def setFillType(self, fillType: PathFillType) -> PathBuilder: ...
    def setIsVolatile(self, isVolatile: bool) -> PathBuilder: ...
    def snapshot(self) -> Path:
        """
        the builder is unchanged after returning this path
        """
    def toggleInverseFillType(self) -> PathBuilder: ...

class PathDirection:
    """
    Members:

      kCW : clockwise direction for adding closed contours

      kCCW : counter-clockwise direction for adding closed contours
    """

    __members__: typing.ClassVar[
        dict[str, PathDirection]
    ]  # value = {'kCW': <PathDirection.kCW: 0>, 'kCCW': <PathDirection.kCCW: 1>}
    kCCW: typing.ClassVar[PathDirection]  # value = <PathDirection.kCCW: 1>
    kCW: typing.ClassVar[PathDirection]  # value = <PathDirection.kCW: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathEffect(Flattanable):
    """

    :py:class:`PathEffect` is the base class for objects in the
    :py:class:`Paint` that affect the geometry of a drawing primitive before it
    is transformed by the canvas' matrix and drawn.

    Dashing is implemented as a subclass of :py:class:`PathEffect`.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~skia.DiscretePathEffect
        ~skia.DashPathEffect
        ~skia.CornerPathEffect
        ~skia.Line2DPathEffect
        ~skia.Path1DPathEffect
        ~skia.Path2DPathEffect
        ~skia.MergePathEffect
        ~skia.MatrixPathEffect
        ~skia.StrokePathEffect
        ~skia.TrimPathEffect

    """
    @staticmethod
    def Deserialize(data: typing_extensions.Buffer) -> PathEffect: ...
    @staticmethod
    def GetFlattenableType() -> Flattanable.Type: ...
    @staticmethod
    def MakeCompose(outer: PathEffect, inner: PathEffect) -> PathEffect:
        """
        Returns a patheffect that applies the inner effect to the path, and then
        applies the outer effect to the result of the inner's.

        result = outer(inner(path))
        """
    @staticmethod
    def MakeSum(first: PathEffect, second: PathEffect) -> PathEffect:
        """
        Returns a patheffect that apples each effect (first and second) to the
        original path, and returns a path with the sum of these.

        result = first(path) + second(path)
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def filterPath(
        self,
        dst: Path,
        src: Path,
        stroke_rec: StrokeRec,
        cullR: Rect,
    ) -> bool:
        """
        Given a src path (input) and a stroke-rec (input and output), apply this
        effect to the src path, returning the new path in dst, and return true.

        If this effect cannot be applied, return false and ignore dst and
        stroke-rec.

        The stroke-rec specifies the initial request for stroking (if any). The
        effect can treat this as input only, or it can choose to change the rec
        as well. For example, the effect can decide to change the stroke's width
        or join, or the effect can change the rec from stroke to fill (or fill
        to stroke) in addition to returning a new (dst) path.

        If this method returns true, the caller will apply (as needed) the
        resulting stroke-rec to dst and then draw.
        """

class PathFillType:
    """
    Members:

      kWinding : Specifies that "inside" is computed by a non-zero sum of signed edge crossings.

      kEvenOdd : Specifies that "inside" is computed by an odd number of edge crossings.

      kInverseWinding : Same as Winding, but draws outside of the path, rather than inside.

      kInverseEvenOdd : Same as EvenOdd, but draws outside of the path, rather than inside.
    """

    __members__: typing.ClassVar[
        dict[str, PathFillType]
    ]  # value = {'kWinding': <PathFillType.kWinding: 0>, 'kEvenOdd': <PathFillType.kEvenOdd: 1>, 'kInverseWinding': <PathFillType.kInverseWinding: 2>, 'kInverseEvenOdd': <PathFillType.kInverseEvenOdd: 3>}
    kEvenOdd: typing.ClassVar[PathFillType]  # value = <PathFillType.kEvenOdd: 1>
    kInverseEvenOdd: typing.ClassVar[
        PathFillType
    ]  # value = <PathFillType.kInverseEvenOdd: 3>
    kInverseWinding: typing.ClassVar[
        PathFillType
    ]  # value = <PathFillType.kInverseWinding: 2>
    kWinding: typing.ClassVar[PathFillType]  # value = <PathFillType.kWinding: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathMeasure:
    """

    :py:class:`PathMeasure`

    """
    class GetPosAndTan:
        """
        Members:

          kGetPosition_MatrixFlag : get position

          kGetTangent_MatrixFlag : get tangent

          kGetPosAndTan_MatrixFlag : get position and tangent
        """

        __members__: typing.ClassVar[
            dict[str, PathMeasure.GetPosAndTan]
        ]  # value = {'kGetPosition_MatrixFlag': <GetPosAndTan.kGetPosition_MatrixFlag: 1>, 'kGetTangent_MatrixFlag': <GetPosAndTan.kGetTangent_MatrixFlag: 2>, 'kGetPosAndTan_MatrixFlag': <GetPosAndTan.kGetPosAndTan_MatrixFlag: 3>}
        kGetPosAndTan_MatrixFlag: typing.ClassVar[
            PathMeasure.GetPosAndTan
        ]  # value = <GetPosAndTan.kGetPosAndTan_MatrixFlag: 3>
        kGetPosition_MatrixFlag: typing.ClassVar[
            PathMeasure.GetPosAndTan
        ]  # value = <GetPosAndTan.kGetPosition_MatrixFlag: 1>
        kGetTangent_MatrixFlag: typing.ClassVar[
            PathMeasure.GetPosAndTan
        ]  # value = <GetPosAndTan.kGetTangent_MatrixFlag: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kGetPosAndTan_MatrixFlag: typing.ClassVar[
        PathMeasure.GetPosAndTan
    ]  # value = <GetPosAndTan.kGetPosAndTan_MatrixFlag: 3>
    kGetPosition_MatrixFlag: typing.ClassVar[
        PathMeasure.GetPosAndTan
    ]  # value = <GetPosAndTan.kGetPosition_MatrixFlag: 1>
    kGetTangent_MatrixFlag: typing.ClassVar[
        PathMeasure.GetPosAndTan
    ]  # value = <GetPosAndTan.kGetTangent_MatrixFlag: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None:
        """
        Initializes a PathMeasure without an associated Path
        """
    @typing.overload
    def __init__(self, path: Path, forceClosed: bool, resScale: float = 1.0) -> None:
        """
        Initialize the PathMeasure with the specified path.

        The parts of the path that are needed are copied, so the
        client is free to modify/delete the path after this call.

        resScale controls the precision of the measure. values > 1
        increase the precision (and possibly slow down the
        computation).
        """
    def getLength(self) -> float:
        """
        Return the total length of the current contour, or 0 if no
        path is associated.
        """
    def getMatrix(
        self,
        distance: float,
        flags: PathMeasure.GetPosAndTan = ...,
    ) -> typing.Any:
        """
        Pins distance to 0 <= distance <= getLength(), and then
        computes the corresponding matrix (by calling getPosTan).

        Returns false if there is no path, or a zero-length path was
        specified, in which case matrix is unchanged.

        :return: None if there is no path, or a zero-length path was
        specified. Otherwise returns a :py:class:`Matrix` containing
        the result.
        """
    def getPosTan(self, distance: float) -> typing.Any:
        """
        Pins distance to 0 <= distance <= getLength(), and then
        computes the corresponding position and tangent.

        :return: None if there is no path, or a zero-length path was
        specified. Otherwise returns a tuple containing the position
        :py:class:`Point` and tangent :py:class:`Vector`.
        """
    def getSegment(
        self,
        startD: float,
        stopD: float,
        dst: Path,
        startWithMoveTo: bool,
    ) -> bool:
        """
        Given a start and stop distance, return in dst the intervening
        segment(s).

        :return: If the segment is zero-length, return false, else
        return true. startD and stopD are pinned to legal values
        (0..getLength()). If startD > stopD then return false (and
        leave dst untouched). Begin the segment with a moveTo if
        startWithMoveTo is true
        """
    def isClosed(self) -> bool:
        """
        :return: true if the current contour is closed()
        """
    def nextContour(self) -> bool:
        """
        Move to the next contour in the path.

        :return: true if one exists, or false if we're done with the
        path.
        """
    def setPath(self, arg0: Path, arg1: bool) -> None:
        """
        Reset the pathmeasure with the specified path.

        The parts of the path that are needed are copied, so the
        client is free to modify/delete the path after this call..
        """

class PathOp:
    """

        The logical operations that can be performed when combining two paths.


    Members:

      kDifference_PathOp : subtract the op path from the first path

      kIntersect_PathOp : intersect the two paths

      kUnion_PathOp : union (inclusive-or) the two paths

      kXOR_PathOp : exclusive-or the two paths

      kReverseDifference_PathOp : subtract the first path from the op path
    """

    __members__: typing.ClassVar[
        dict[str, PathOp]
    ]  # value = {'kDifference_PathOp': <PathOp.kDifference_PathOp: 0>, 'kIntersect_PathOp': <PathOp.kIntersect_PathOp: 1>, 'kUnion_PathOp': <PathOp.kUnion_PathOp: 2>, 'kXOR_PathOp': <PathOp.kXOR_PathOp: 3>, 'kReverseDifference_PathOp': <PathOp.kReverseDifference_PathOp: 4>}
    kDifference_PathOp: typing.ClassVar[
        PathOp
    ]  # value = <PathOp.kDifference_PathOp: 0>
    kIntersect_PathOp: typing.ClassVar[PathOp]  # value = <PathOp.kIntersect_PathOp: 1>
    kReverseDifference_PathOp: typing.ClassVar[
        PathOp
    ]  # value = <PathOp.kReverseDifference_PathOp: 4>
    kUnion_PathOp: typing.ClassVar[PathOp]  # value = <PathOp.kUnion_PathOp: 2>
    kXOR_PathOp: typing.ClassVar[PathOp]  # value = <PathOp.kXOR_PathOp: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathSegmentMask:
    """
    Members:

      kLine_PathSegmentMask

      kQuad_PathSegmentMask

      kConic_PathSegmentMask

      kCubic_PathSegmentMask
    """

    __members__: typing.ClassVar[
        dict[str, PathSegmentMask]
    ]  # value = {'kLine_PathSegmentMask': <PathSegmentMask.kLine_PathSegmentMask: 1>, 'kQuad_PathSegmentMask': <PathSegmentMask.kQuad_PathSegmentMask: 2>, 'kConic_PathSegmentMask': <PathSegmentMask.kConic_PathSegmentMask: 4>, 'kCubic_PathSegmentMask': <PathSegmentMask.kCubic_PathSegmentMask: 8>}
    kConic_PathSegmentMask: typing.ClassVar[
        PathSegmentMask
    ]  # value = <PathSegmentMask.kConic_PathSegmentMask: 4>
    kCubic_PathSegmentMask: typing.ClassVar[
        PathSegmentMask
    ]  # value = <PathSegmentMask.kCubic_PathSegmentMask: 8>
    kLine_PathSegmentMask: typing.ClassVar[
        PathSegmentMask
    ]  # value = <PathSegmentMask.kLine_PathSegmentMask: 1>
    kQuad_PathSegmentMask: typing.ClassVar[
        PathSegmentMask
    ]  # value = <PathSegmentMask.kQuad_PathSegmentMask: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PathVerb:
    """
    Members:

      kMove : iter.next returns 1 point

      kLine : iter.next returns 2 points

      kQuad : iter.next returns 3 points

      kConic : iter.next returns 3 points + iter.conicWeight()

      kCubic : iter.next returns 4 points

      kClose : iter.next returns 1 point (contour's moveTo pt)
    """

    __members__: typing.ClassVar[
        dict[str, PathVerb]
    ]  # value = {'kMove': <PathVerb.kMove: 0>, 'kLine': <PathVerb.kLine: 1>, 'kQuad': <PathVerb.kQuad: 2>, 'kConic': <PathVerb.kConic: 3>, 'kCubic': <PathVerb.kCubic: 4>, 'kClose': <PathVerb.kClose: 5>}
    kClose: typing.ClassVar[PathVerb]  # value = <PathVerb.kClose: 5>
    kConic: typing.ClassVar[PathVerb]  # value = <PathVerb.kConic: 3>
    kCubic: typing.ClassVar[PathVerb]  # value = <PathVerb.kCubic: 4>
    kLine: typing.ClassVar[PathVerb]  # value = <PathVerb.kLine: 1>
    kMove: typing.ClassVar[PathVerb]  # value = <PathVerb.kMove: 0>
    kQuad: typing.ClassVar[PathVerb]  # value = <PathVerb.kQuad: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PerlinNoiseShader:
    """

    :py:class:`PerlinNoiseShader` creates an image using the Perlin turbulence
    function.

    It can produce tileable noise if asked to stitch tiles and provided a tile
    size. In order to fill a large area with repeating noise, set the
    stitchTiles flag to true, and render exactly a single tile of noise. Without
    this flag, the result will contain visible seams between tiles.

    The algorithm used is described here:
    http://www.w3.org/TR/SVG/filters.html#feTurbulenceElement

    """
    @staticmethod
    def MakeFractalNoise(
        baseFrequencyX: float,
        baseFrequencyY: float,
        numOctaves: int,
        seed: float,
        tileSize: ISize | None = None,
    ) -> Shader:
        """
        This will construct Perlin noise of the given type (Fractal Noise or
        Turbulence).

        Both base frequencies (X and Y) have a usual range of (0..1) and must be
        non-negative.

        The number of octaves provided should be fairly small, with a limit of
        255 enforced. Each octave doubles the frequency, so 10 octaves would
        produce noise from baseFrequency * 1, * 2, * 4, ..., * 512, which
        quickly yields insignificantly small periods and resembles regular
        unstructured noise rather than Perlin noise.

        If tileSize isn't NULL or an empty size, the tileSize parameter will be
        used to modify the frequencies so that the noise will be tileable for
        the given tile size. If tileSize is NULL or an empty size, the
        frequencies will be used as is without modification.
        """
    @staticmethod
    def MakeTurbulence(
        baseFrequencyX: float,
        baseFrequencyY: float,
        numOctaves: int,
        seed: float,
        tileSize: ISize | None = None,
    ) -> Shader: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Picture(RefCnt):
    """

    :py:class:`Picture` records drawing commands made to :py:class:`Canvas`.

    The command stream may be played in whole or in part at a later time.

    :py:class:`Picture` is an abstract class. :py:class:`Picture` may be
    generated by :py:class:`PictureRecorder` or :py:class:`Drawable`, or from
    :py:class:`Picture` previously saved to :py:class:`Data` or
    :py:class:`Stream`.

    :py:class:`Picture` may contain any :py:class:`Canvas` drawing command, as
    well as one or more :py:class:`Canvas` matrix or :py:class:`Canvas` clip.
    :py:class:`Picture` has a cull :py:class:`Rect`, which is used as a bounding
    box hint. To limit :py:class:`Picture` bounds, use :py:class:`Canvas` clip
    when recording or drawing :py:class:`Picture`.

    Example::

        recorder = skia.PictureRecorder()
        canvas = recorder.beginRecording(skia.Rect(100, 100))
        canvas.clear(0xFFFFFFFF)
        canvas.drawLine(0, 0, 100, 100, skia.Paint())
        picture = recorder.finishRecordingAsPicture()

    """
    @staticmethod
    def MakeFromData(data: Data) -> Picture:
        """
        Recreates :py:class:`Picture` that was serialized into data.

        Returns constructed :py:class:`Picture` if successful. Fails if data
        does not permit constructing valid :py:class:`Picture`.

        :param skia.Data data: container for serial data
        :return: :py:class:`Picture` constructed from data
        :raise: ValueError
        """
    @staticmethod
    def MakeFromStream(stream: Stream) -> Picture:
        """
        Recreates :py:class:`Picture` that was serialized into a stream.

        Returns constructed :py:class:`Picture` if successful; otherwise,
        returns nullptr. Fails if data does not permit constructing valid
        :py:class:`Picture`.

        :param stream: container for serial data
        :return: :py:class:`Picture` constructed from stream data
        """
    @staticmethod
    def MakePlaceholder(cull: Rect) -> Picture:
        """
        Returns a placeholder :py:class:`Picture`.

        Result does not draw, and contains only cull :py:class:`Rect`, a hint of
        its bounds. Result is immutable; it cannot be changed later. Result
        identifier is unique.

        Returned placeholder can be intercepted during playback to insert other
        commands into :py:class:`Canvas` draw stream.

        :param skia.Rect cull: placeholder dimensions
        :return: placeholder with unique identifier
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self, cull: Rect) -> None:
        """
        Returns a placeholder :py:class:`Picture`.

        Result does not draw, and contains only cull :py:class:`Rect`, a hint of
        its bounds. Result is immutable; it cannot be changed later. Result
        identifier is unique.

        Returned placeholder can be intercepted during playback to insert other
        commands into :py:class:`Canvas` draw stream.

        :param skia.Rect cull: placeholder dimensions
        :return: placeholder with unique identifier
        """
    def approximateBytesUsed(self) -> int:
        """
        Returns the approximate byte size of :py:class:`Picture`.

        Does not include large objects referenced by :py:class:`Picture`.

        :return: approximate size
        """
    def approximateOpCount(self, nested: bool = False) -> int:
        """
        Returns the approximate number of operations in :py:class:`Picture`.

        Returned value may be greater or less than the number of
        :py:class:`Canvas` calls recorded: some calls may be recorded as more
        than one operation, other calls may be optimized away.

        :return: approximate operation count
        """
    def cullRect(self) -> Rect:
        """
        Returns cull :py:class:`Rect` for this picture, passed in when
        :py:class:`Picture` was created.

        Returned :py:class:`Rect` does not specify clipping :py:class:`Rect` for
        :py:class:`Picture`; cull is hint of :py:class:`Picture` bounds.

        :py:class:`Picture` is free to discard recorded drawing commands that
        fall outside cull.

        :return: bounds passed when :py:class:`Picture` was created
        """
    def makeShader(
        self,
        tmx: TileMode,
        tmy: TileMode,
        mode: FilterMode,
        localMatrix: Matrix | None = None,
        tile: Rect | None = None,
    ) -> Shader:
        """
        Return a new shader that will draw with this picture.

        :param skia.TileMode tmx: The tiling mode to use when sampling in the
            x-direction.
        :param skia.TileMode tmy: The tiling mode to use when sampling in the
            y-direction.
        :param skia.Matrix localMatrix: Optional matrix used when sampling
        :param skia.Rect tile: The tile rectangle in picture coordinates:
            this represents the subset (or superset) of the picture used when
            building a tile. It is not affected by localMatrix and does not
            imply scaling (only translation and cropping). If null, the tile
            rect is considered equal to the picture bounds.
        :return: Returns a new shader object. Note: this function never returns
            null.
        """
    def playback(self, canvas: Canvas) -> None:
        """
        Replays the drawing commands on the specified canvas.

        In the case that the commands are recorded, each command in the
        :py:class:`Picture` is sent separately to canvas.

        To add a single command to draw :py:class:`Picture` to recording canvas,
        call :py:meth:`Canvas.drawPicture` instead.

        :param skia.Canvas canvas: receiver of drawing commands
        :param callback: allows interruption of playback
        """
    def serialize(self) -> Data:
        """
        Returns storage containing :py:class:`Data` describing
        :py:class:`Picture`.

        :return: storage containing serialized :py:class:`Picture`
        """
    def uniqueID(self) -> int:
        """
        Returns a non-zero value unique among :py:class:`Picture` in Skia
        process.

        :return: identifier for :py:class:`Picture`
        """

class PictureRecorder:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    @typing.overload
    def beginRecording(self, bounds: Rect, bbh: BBoxHierarchy) -> Canvas:
        """
        Returns the canvas that records the drawing commands.
        """
    @typing.overload
    def beginRecording(self, bounds: Rect) -> Canvas:
        """
        Returns the canvas that records the drawing commands.

        :bounds: the cull rect used when recording this picture. Any
            drawing the falls outside of this rect is undefined, and may be
            drawn or it may not.
        :return: the canvas.
        """
    @typing.overload
    def beginRecording(self, width: float, height: float) -> Canvas: ...
    def finishRecordingAsDrawable(self) -> Drawable:
        """
        Signal that the caller is done recording.

        This invalidates the canvas returned by :py:meth:`beginRecording` or
        :py:meth:`getRecordingCanvas`. Ownership of the object is passed to the
        caller, who must call unref() when they are done using it.

        Unlike :py:meth:`finishRecordingAsPicture`, which returns an immutable
        picture, the returned drawable may contain live references to other
        drawables (if they were added to the recording canvas) and therefore
        this drawable will reflect the current state of those nested drawables
        anytime it is drawn or a new picture is snapped from it (by calling
        drawable.newPictureSnapshot()).
        """
    def finishRecordingAsPicture(self) -> Picture:
        """
        Signal that the caller is done recording.

        This invalidates the canvas returned by :py:meth:`beginRecording` or
        :py:meth:`getRecordingCanvas`. Ownership of the object is passed to the
        caller, who must call unref() when they are done using it.

        The returned picture is immutable. If during recording drawables were
        added to the canvas, these will have been "drawn" into a recording
        canvas, so that this resulting picture will reflect their current state,
        but will not contain a live reference to the drawables themselves.
        """
    def finishRecordingAsPictureWithCull(self, cullRect: Rect) -> Picture:
        """
        Signal that the caller is done recording, and update the cull rect to
        use for bounding box hierarchy (BBH) generation.

        The behavior is the same as calling :py:meth:`finishRecordingAsPicture`,
        except that this method updates the cull rect initially passed into
        beginRecording.

        :param skia.Rect cullRect: the new culling rectangle to use as the
            overall bound for BBH generation and subsequent culling operations.
        :return: the picture containing the recorded content.
        """
    def getRecordingCanvas(self) -> Canvas:
        """
        Returns the recording canvas if one is active, or NULL if recording is
        not active.

        This does not alter the refcnt on the canvas (if present).
        """

class PixelGeometry:
    """

        Description of how the LCD strips are arranged for each pixel.

        If this is unknown, or the pixels are meant to be "portable" and/or
        transformed before showing (e.g. rotated, scaled) then use
        :py:attr:`PixelGeometry.kUnknown`.


    Members:

      kUnknown_PixelGeometry

      kRGB_H_PixelGeometry

      kBGR_H_PixelGeometry

      kRGB_V_PixelGeometry

      kBGR_V_PixelGeometry
    """

    __members__: typing.ClassVar[
        dict[str, PixelGeometry]
    ]  # value = {'kUnknown_PixelGeometry': <PixelGeometry.kUnknown_PixelGeometry: 0>, 'kRGB_H_PixelGeometry': <PixelGeometry.kRGB_H_PixelGeometry: 1>, 'kBGR_H_PixelGeometry': <PixelGeometry.kBGR_H_PixelGeometry: 2>, 'kRGB_V_PixelGeometry': <PixelGeometry.kRGB_V_PixelGeometry: 3>, 'kBGR_V_PixelGeometry': <PixelGeometry.kBGR_V_PixelGeometry: 4>}
    kBGR_H_PixelGeometry: typing.ClassVar[
        PixelGeometry
    ]  # value = <PixelGeometry.kBGR_H_PixelGeometry: 2>
    kBGR_V_PixelGeometry: typing.ClassVar[
        PixelGeometry
    ]  # value = <PixelGeometry.kBGR_V_PixelGeometry: 4>
    kRGB_H_PixelGeometry: typing.ClassVar[
        PixelGeometry
    ]  # value = <PixelGeometry.kRGB_H_PixelGeometry: 1>
    kRGB_V_PixelGeometry: typing.ClassVar[
        PixelGeometry
    ]  # value = <PixelGeometry.kRGB_V_PixelGeometry: 3>
    kUnknown_PixelGeometry: typing.ClassVar[
        PixelGeometry
    ]  # value = <PixelGeometry.kUnknown_PixelGeometry: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PixelRef:
    """

    This class is the smart container for pixel memory, and is used with
    :py:class:`Bitmap`.

    This class can be shared/accessed between multiple threads.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Pixmap:
    """

    :py:class:`Pixmap` provides a utility to pair :py:class:`ImageInfo` with
    pixels and row bytes.

    :py:class:`Pixmap` is a low level class which provides convenience functions
    to access raster destinations. :py:class:`Canvas` can not draw
    :py:class:`Pixmap`, nor does :py:class:`Pixmap` provide a direct drawing
    destination.

    Use :py:class:`Bitmap` to draw pixels referenced by :py:class:`Pixmap`; use
    :py:class:`Surface` to draw into pixels referenced by :py:class:`Pixmap`.

    :py:class:`Pixmap` does not try to manage the lifetime of the pixel memory.
    Use :py:class:`PixelRef` to manage pixel memory; :py:class:`PixelRef` is
    safe across threads.

    :py:class:`Pixmap` supports buffer protocol. It is possible to mount
    :py:class:`Pixmap` as array::

        array = np.array(pixmap, copy=False)

    Or mount array as :py:class:`Pixmap` with :py:class:`ImageInfo`::

        buffer = np.zeros((100, 100, 4), np.uint8)
        array = skia.Pixmap(skia.ImageInfo.MakeN32Premul(100, 100), buffer)


    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __getitem__(self, arg0: typing.Any) -> int: ...
    @typing.overload
    def __init__(self) -> None:
        """
        Creates an empty :py:class:`Pixmap` without pixels, with
        :py:attr:`~ColorType.kUnknown_ColorType`, with
        :py:attr:`~AlphaType.kUnknown_AlphaType`, and with a width and height of
        zero.

        Use :py:meth:`reset` to associate pixels, :py:class:`ColorType`,
        :py:class:`AlphaType`, width, and height after :py:class:`Pixmap` has
        been created.

        :return: empty :py:class:`Pixmap`
        """
    @typing.overload
    def __init__(self, info: ImageInfo, data: typing.Any, rowBytes: int) -> None:
        """
        Creates :py:class:`Pixmap` from info width, height,
        :py:class:`AlphaType`, and :py:class:`ColorType`.

        ``data`` points to pixels, or nullptr. rowBytes should be
        ``info.width()`` times ``info.bytesPerPixel()``, or larger.

        No parameter checking is performed; it is up to the caller to ensure
        that data and rowBytes agree with info.

        The memory lifetime of pixels is managed by the caller. When
        :py:class:`Pixmap` goes out of scope, data is unaffected.

        :py:class:`Pixmap` may be later modified by :py:meth:`reset` to change
        its size, pixel type, or storage.

        :info: width, height, :py:class:`AlphaType`,
            :py:class:`ColorType` of :py:class:`ImageInfo`
        :data: pointer to pixels
            allocated by caller; may be nullptr
        :rowBytes: size of one row of data; width times pixel size, or
            larger
        """
    @typing.overload
    def __init__(
        self,
        array: numpy.ndarray,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> None:
        """
        Creates :py:class:`Pixmap` backed by numpy array.

        The memory lifetime of pixels is managed by the caller. When
        :py:class:`Pixmap` goes out of scope, data is unaffected.

        :array: numpy ndarray of shape=(height, width, channels). Must have
            non-zero width and height, and the valid number of channels for the
            specified color type.
        :colorType: color type of the array
        :alphaType: alpha type of the array
        :colorSpace: range of colors; may be nullptr
        """
    def __len__(self) -> int: ...
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def addr(self) -> memoryview:
        """
        Returns pixel address, the base address corresponding to the pixel
        origin.

        It is up to the :py:class:`Pixmap` creator to ensure that pixel address
        is a useful value.

        :return: pixel address
        :rtype: memoryview
        """
    def addr16(self) -> memoryview:
        """
        Returns readable base pixel address.

        Result is addressable as unsigned 16-bit words. Will trigger an assert()
        if :py:class:`ColorType` is not :py:attr:`kRGB_565_ColorType` or
        :py:attr:`kARGB_4444_ColorType`, and is built with SK_DEBUG defined.

        One word corresponds to one pixel.

        :return: readable unsigned 16-bit pointer to pixels
        :rtype: memoryview
        """
    def addr32(self) -> memoryview:
        """
        Returns readable base pixel address.

        Result is addressable as unsigned 32-bit words. Will trigger an assert()
        if :py:class:`ColorType` is not :py:attr:`kRGBA_8888_ColorType` or
        :py:attr:`kBGRA_8888_ColorType`, and is built with SK_DEBUG defined.

        One word corresponds to one pixel.

        :return: readable unsigned 32-bit pointer to pixels
        :rtype: memoryview
        """
    def addr64(self) -> memoryview:
        """
        Returns readable base pixel address.

        Result is addressable as unsigned 64-bit words. Will trigger an assert()
        if :py:class:`ColorType` is not :py:attr:`kRGBA_F16_ColorType` and is
        built with SK_DEBUG defined.

        One word corresponds to one pixel.

        :return: readable unsigned 64-bit pointer to pixels
        :rtype: memoryview
        """
    def addr8(self) -> memoryview:
        """
        Returns readable base pixel address.

        Result is addressable as unsigned 8-bit bytes. Will trigger an assert()
        if :py:class:`ColorType` is not :py:attr:`~ColorType.kAlpha_8_ColorType`
        or :py:attr:`~ColorType.kGray_8_ColorType`, and is built with SK_DEBUG
        defined.

        One byte corresponds to one pixel.

        :return: readable unsigned 8-bit pointer to pixels
        :rtype: memoryview
        """
    def alphaType(self) -> AlphaType: ...
    def bounds(self) -> IRect:
        """
        Returns :py:class:`IRect` ( 0, 0, :py:meth:`width`, :py:meth:`height` ).

        :return: integral rectangle from origin to :py:meth:`width` and
            :py:meth:`height`
        """
    def colorSpace(self) -> ColorSpace:
        """
        Returns :py:class:`ColorSpace`, the range of colors, associated with
        :py:class:`ImageInfo`.

        The reference count of :py:class:`ColorSpace` is unchanged. The returned
        :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace` in :py:class:`ImageInfo`, or nullptr
        """
    def colorType(self) -> ColorType: ...
    def computeByteSize(self) -> int:
        """
        Returns minimum memory required for pixel storage.

        Does not include unused memory on last row when
        :py:meth:`rowBytesAsPixels` exceeds width(). Returns SIZE_MAX if result
        does not fit in size_t. Returns zero if :py:meth:`height` or
        :py:meth:`width` is 0. Returns :py:meth:`height` times
        :py:meth:`rowBytes` if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: size in bytes of image buffer
        """
    def computeIsOpaque(self) -> bool:
        """
        Returns true if all pixels are opaque.

        :py:class:`ColorType` determines how pixels are encoded, and whether
        pixel describes alpha. Returns true for :py:class:`ColorType` without
        alpha in each pixel; for other :py:class:`ColorType`, returns true if
        all pixels have alpha values equivalent to 1.0 or greater.

        For :py:class:`ColorType` :py:attr:`~ColorType.kRGB_565_ColorType` or
        :py:attr:`~ColorType.kGray_8_ColorType`: always returns true. For
        :py:class:`ColorType` :py:attr:`~ColorType.kAlpha_8_ColorType`,
        :py:attr:`~ColorType.kBGRA_8888_ColorType`,
        :py:attr:`~ColorType.kRGBA_8888_ColorType`: returns true if all pixel
        alpha values are 255. For :py:class:`ColorType`
        :py:attr:`~ColorType.kARGB_4444_ColorType`: returns true if all pixel
        alpha values are 15. For :py:attr:`~ColorType.kRGBA_F16_ColorType`:
        returns true if all pixel alpha values are 1.0 or greater.

        Returns false for :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: true if all pixels have opaque values or :py:class:`ColorType`
            is opaque
        """
    def dimensions(self) -> ISize:
        """
        Return the dimensions of the pixmap (from its ImageInfo)
        """
    def erase(self, color: Color4f, subset: IRect | None = None) -> bool:
        """
        Writes color to pixels bounded by subset; returns true on success.

        if subset is nullptr, writes colors pixels inside :py:meth:`bounds`.
        Returns false if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`, if subset is not nullptr and
        does not intersect :py:meth:`bounds`, or if subset is nullptr and
        :py:meth:`bounds` is empty.

        :param color: sRGB unpremultiplied color to write
        :param subset: bounding integer :py:class:`Rect` of pixels to write; may
            be nullptr
        :return: true if pixels are changed
        """
    def extractSubset(self, subset: Pixmap, area: IRect) -> bool:
        """
        Sets subset width, height, pixel address to intersection of
        :py:class:`Pixmap` with area, if intersection is not empty; and return
        true.

        Otherwise, leave subset unchanged and return false.

        Failing to read the return value generates a compile time warning.

        :param skia.Pixmap subset: storage for width, height, pixel address of
            intersection
        :param skia.IRect area: bounds to intersect with :py:class:`Pixmap`
        :return: true if intersection of :py:class:`Pixmap` and area is not
            empty
        """
    def getAlphaf(self, x: int, y: int) -> float:
        """
        Look up the pixel at (x,y) and return its alpha component, normalized to
        [0..1].

        This is roughly equivalent to :py:meth:`~skia.GetColorA`(
        :py:meth:`getColor` ), but can be more efficent (and more precise if the
        pixels store more than 8 bits per component).

        :param int x: column index, zero or greater, and less than width()
        :param int y: row index, zero or greater, and less than height()
        :return: alpha converted to normalized float
        """
    def getColor(self, x: int, y: int) -> int:
        """
        Returns pixel at (x, y) as unpremultiplied color.

        Returns black with alpha if :py:class:`ColorType` is
        :py:attr:`~ColorType.kAlpha_8_ColorType`.

        Input is not validated: out of bounds values of x or y trigger an
        assert() if built with SK_DEBUG defined; and returns undefined values or
        may crash if SK_RELEASE is defined. Fails if :py:class:`ColorType` is
        :py:attr:`~ColorType.kUnknown_ColorType` or pixel address is nullptr.

        :py:class:`ColorSpace` in :py:class:`ImageInfo` is ignored. Some color
        precision may be lost in the conversion to unpremultiplied color;
        original pixel data may have additional precision.

        :param int x: column index, zero or greater, and less than width()
        :param int y: row index, zero or greater, and less than height()
        :return: pixel converted to unpremultiplied color
        """
    def height(self) -> int:
        """
        Returns pixel row count.

        :return: pixel height in SkImageInfo
        """
    def info(self) -> ImageInfo:
        """
        Returns width, height, :py:class:`AlphaType`, :py:class:`ColorType`, and
        :py:class:`ColorSpace`.

        :return: reference to :py:class:`ImageInfo`
        """
    def isOpaque(self) -> bool:
        """
        Returns true if :py:class:`AlphaType` is :py:attr:`kOpaque_AlphaType`.

        Does not check if :py:class:`ColorType` allows alpha, or if any pixel
        value has transparency.

        :return: true if :py:class:`ImageInfo` has opaque :py:class:`AlphaType`
        """
    @typing.overload
    def readPixels(
        self,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int = 0,
        srcX: int = 0,
        srcY: int = 0,
    ) -> bool:
        """
        Copies :py:class:`Rect` of pixels to dstPixels.

        Copy starts at offset (srcX, srcY), and does not exceed
        :py:class:`Pixmap` (:py:meth:`width`, :py:meth:`height`).

        dstInfo specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, and :py:class:`ColorSpace` of destination.
        dstRowBytes specifies the gap from one destination row to the next.
        Returns true if pixels are copied. Returns false if dstInfo address
        equals nullptr, or dstRowBytes is less than ``dstInfo.minRowBytes()``.

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; ``dstInfo.colorType``
        must match. If :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, ``dstInfo.colorSpace`` must
        match. If :py:class:`Pixmap` :py:class:`AlphaType` is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, ``dstInfo.alphaType`` must
        match. If :py:class:`Pixmap` :py:class:`ColorSpace` is nullptr,
        ``dstInfo.colorSpace`` must match. Returns false if pixel conversion is
        not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if :py:meth:`width` or :py:meth:`height` is zero or
        negative. Returns false if abs(srcX) >= Pixmap :py:meth:`width`, or if
        abs(srcY) >= Pixmap :py:meth:`height`.

        :dstInfo: destination width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`
        :dstPixels:   destination pixel storage
        :dstRowBytes: destination row length
        :srcX: column index whose absolute value is less than
            :py:meth:`width`
        :srcY: row index whose absolute value is less than
            :py:meth:`height`
        :return: true if pixels are copied to dstPixels
        """
    @typing.overload
    def readPixels(self, dst: Pixmap, srcX: int = 0, srcY: int = 0) -> bool:
        """
        Copies :py:class:`Rect` of pixels to dst.

        Copy starts at offset (srcX, srcY), and does not exceed
        :py:class:`Pixmap` (:py:meth:`width`, :py:meth:`height`).

        dstInfo specifies width, height, :py:class:`ColorType`,
        :py:class:`AlphaType`, and :py:class:`ColorSpace` of destination.
        dstRowBytes specifies the gap from one destination row to the next.
        Returns true if pixels are copied. Returns false if dstInfo address
        equals nullptr, or dstRowBytes is less than ``dstInfo.minRowBytes()``.

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; ``dstInfo.colorType``
        must match. If :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, ``dstInfo.colorSpace`` must
        match. If :py:class:`Pixmap` :py:class:`AlphaType` is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, ``dstInfo.alphaType`` must
        match. If :py:class:`Pixmap` :py:class:`ColorSpace` is nullptr,
        ``dstInfo.colorSpace`` must match. Returns false if pixel conversion is
        not possible.

        srcX and srcY may be negative to copy only top or left of source.
        Returns false if :py:meth:`width` or :py:meth:`height` is zero or
        negative. Returns false if abs(srcX) >= Pixmap :py:meth:`width`, or if
        abs(srcY) >= Pixmap :py:meth:`height`.

        :dst: :py:class:`ImageInfo` and pixel address to write to
        :srcX: column index whose absolute value is less than
            :py:meth:`width`
        :srcY: row index whose absolute value is less than
            :py:meth:`height`
        :return: true if pixels are copied to dst
        """
    def refColorSpace(self) -> ColorSpace:
        """
        Returns smart pointer to :py:class:`ColorSpace`, the range of colors,
        associated with :py:class:`ImageInfo`.

        The smart pointer tracks the number of objects sharing this
        :py:class:`ColorSpace` reference so the memory is released when the
        owners destruct.

        The returned :py:class:`ColorSpace` is immutable.

        :return: :py:class:`ColorSpace` in :py:class:`ImageInfo` wrapped in a
            smart pointer
        """
    @typing.overload
    def reset(self) -> None:
        """
        Sets width, height, row bytes to zero; pixel address to nullptr;
        :py:class:`ColorType` to :py:attr:`~ColorType.kUnknown_ColorType`; and
        :py:class:`AlphaType` to :py:attr:`~Type.kUnknown_AlphaType`.

        The prior pixels are unaffected; it is up to the caller to release
        pixels memory if desired.
        """
    @typing.overload
    def reset(self, info: ImageInfo, data: typing.Any, rowBytes: int) -> None:
        """
        Sets width, height, :py:class:`AlphaType`, and :py:class:`ColorType`
        from info.

        Sets pixel address from data, which may be nullptr. Sets row bytes from
        rowBytes, which should be ``info.width()`` times
        ``info.bytesPerPixel()``, or larger.

        Does not check data. Asserts if built with SK_DEBUG defined and if
        rowBytes is too small to hold one row of pixels.

        The memory lifetime pixels are managed by the caller. When
        :py:class:`Pixmap` goes out of scope, data is unaffected.

        :param skia.ImageInfo info: width, height, :py:class:`AlphaType`,
            :py:class:`ColorType` of :py:class:`ImageInfo`
        :param Union[bytes,bytearray,memoryview] data: pointer to pixels
            allocated by caller; may be nullptr
        :param int rowBytes: size of one row of data; width times pixel size, or
            larger
        """
    def rowBytes(self) -> int:
        """
        Returns row bytes, the interval from one pixel row to the next.

        Row bytes is at least as large as: ``width() * info().bytesPerPixel()``.

        Returns zero if :py:meth:`colorType` is
        :py:attr:`~ColorType.kUnknown_ColorType`. It is up to the
        :py:class:`Bitmap` creator to ensure that row bytes is a useful value.

        :return: byte length of pixel row
        """
    def rowBytesAsPixels(self) -> int:
        """
        Returns number of pixels that fit on row.

        Should be greater than or equal to :py:meth:`width`.

        :return: maximum pixels per row
        """
    def scalePixels(self, dst: Pixmap, samplingOptions: SamplingOptions = ...) -> bool:
        """
        Copies :py:class:`Pixmap` to dst, scaling pixels to fit ``dst.width()``
        and ``dst.height()``, and converting pixels to match ``dst.colorType()``
        and ``dst.alphaType()``.

        Returns true if pixels are copied. Returns false if ``dst.addr()`` is
        nullptr, or ``dst.rowBytes()`` is less than dst
        :py:meth:`ImageInfo.minRowBytes`.

        Pixels are copied only if pixel conversion is possible. If
        :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, or
        :py:attr:`~ColorType.kAlpha_8_ColorType`; ``dst.colorType()`` must
        match. If :py:class:`Pixmap` :py:class:`ColorType` is
        :py:attr:`~ColorType.kGray_8_ColorType`, ``dst.colorSpace()`` must
        match. If :py:class:`Pixmap` :py:class:`AlphaType` is
        :py:attr:`~AlphaType.kOpaque_AlphaType`, ``dst.alphaType()`` must match.
        If :py:class:`Pixmap` :py:class:`ColorSpace` is nullptr,
        ``dst.colorSpace()`` must match. Returns false if pixel conversion is
        not possible.

        Returns false if :py:class:`Pixmap` :py:meth:`width` or
        :py:meth:`height` is zero or negative.

        Scales the image, with filterQuality, to match ``dst.width()`` and
        ``dst.height()``. filterQuality
        :py:attr:`~FilterQuality.None_FilterQuality` is fastest, typically
        implemented with nearest neighbor filter.
        :py:attr:`~FilterQuality.kLow_FilterQuality` is typically implemented
        with bilerp filter. :py:attr:`~FilterQuality.kMedium_FilterQuality` is
        typically implemented with bilerp filter, and mip-map filter when size
        is reduced. :py:attr:`~FilterQuality.kHigh_FilterQuality` is slowest,
        typically implemented with bicubic filter.

        :param skia.Pixmap dst: destination :py:class:`Pixmap`:
            :py:class:`ImageInfo`, pixels, row bytes
        :param skia.SamplingOptions options: sampling options
        :return: true if pixels are scaled to fit dst
        """
    def setColorSpace(self, colorSpace: ColorSpace) -> None:
        """
        Changes :py:class:`ColorSpace` in :py:class:`ImageInfo`; preserves
        width, height, :py:class:`AlphaType`, and :py:class:`ColorType` in
        :py:class:`Image`, and leaves pixel address and row bytes unchanged.

        :py:class:`ColorSpace` reference count is incremented.

        :param skia.ColorSpace colorSpace: :py:class:`ColorSpace` moved to
            :py:class:`ImageInfo`
        """
    def shiftPerPixel(self) -> int:
        """
        Returns bit shift converting row bytes to row pixels.

        Returns zero for :py:attr:`~ColorType.kUnknown_ColorType`.

        :return: one of: 0, 1, 2, 3; left shift to convert pixels to bytes
        """
    def tobytes(self) -> typing.Any: ...
    def width(self) -> int:
        """
        Returns pixel count in each pixel row.

        Should be equal or less than:
        :py:meth:`rowBytes` / ``info().bytesPerPixel()``.

        :return: pixel width in :py:class:`ImageInfo`
        """
    def writable_addr(self) -> memoryview:
        """
        Returns writable base pixel address.

        :return: writable generic base pointer to pixels
        :rtype: memoryview
        """
    @property
    def __array_interface__(self) -> dict: ...

class Point:
    """

    :py:class:`Point` holds two 32-bit floating point coordinates.

    Example::

        point = skia.Point(0.0, 0.0)
        point = skia.Point((0.0, 0.0))  # Convert from tuple
        print(point.fX, point.fY)
        point + (1, 1)  # Add offset
        point - (0, 0)  # Subtract offset
        point * 2.0  # Scale
        x, y = tuple(point)  # Convert to tuple

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def CrossProduct(a: Point, b: Point) -> float:
        """
        Returns the cross product of vector a and vector b.

        a and b form three-dimensional vectors with z-axis value equal to zero.
        The cross product is a three-dimensional vector with x-axis and y-axis
        values equal to zero. The cross product z-axis component is returned.

        :param a: left side of cross product
        :param b: right side of cross product
        :return: area spanned by vectors signed by angle direction
        """
    @staticmethod
    def Distance(a: Point, b: Point) -> float:
        """
        Returns the Euclidean distance between a and b.

        :param a: line end point
        :param b: line end point
        :return: straight-line distance from a to b
        """
    @staticmethod
    def DotProduct(a: Point, b: Point) -> float:
        """
        Returns the dot product of vector a and vector b.

        :param a: left side of dot product
        :param b: right side of dot product
        :return: product of input magnitudes and cosine of the angle between
            them
        """
    @staticmethod
    def Length(x: float, y: float) -> float:
        """
        Returns the Euclidean distance from origin, computed as:

            sqrt(x * x + y * y)

        :param x: component of length
        :param y: component of length
        :return: straight-line distance to origin
        """
    @staticmethod
    def Make(x: float, y: float) -> Point:
        """
        Sets fX to x, fY to y.

        Used both to set :py:class:`Point` and vector.

        :param x: Scalar x-axis value of constructed :py:class:`Point` or vector
        :param y: Scalar y-axis value of constructed :py:class:`Point` or vector
        :return: :py:class:`Point` (x, y)
        """
    @staticmethod
    def Normalize(vec: Point) -> float:
        """
        Scales (vec->fX, vec->fY) so that length() returns one, while preserving
        ratio of vec->fX to vec->fY, if possible.

        If original length is nearly zero, sets vec to (0, 0) and returns zero;
        otherwise, returns length of vec before vec is scaled.

        Returned prior length may be SK_ScalarInfinity if it can not be
        represented by SkScalar.

        Note that :py:meth:`normalize` is faster if prior length is not
        required.

        :param vec: normalized to unit length
        :return: original vec length
        """
    @staticmethod
    @typing.overload
    def Offset(points: ..., std: ..., offset: Point) -> ...:
        """
        Adds offset to each :py:class:`Point` in points array with count
        entries.

        :points: :py:class:`Point` array
        :offset: vector added to points
        :return: :py:class:`Point` array applied offset
        """
    @staticmethod
    @typing.overload
    def Offset(points: ..., std: ..., dx: float, dy: float) -> ...:
        """
        Adds offset (dx, dy) to each :py:class:`Point` in points array of length
        count.

        :points: :py:class:`Point` array
        :dx: added to fX in points
        :dy: added to fY in points
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __add__(self, other: Point) -> Point:
        """
        Returns :py:class:`Point` resulting from :py:class:`Point` self offset
        by vector other, computed as: (self.fX + other.fX, self.fY + other.fY).

        Can also be used to offset :py:class:`Point` other by vector self,
        returning :py:class:`Point`. Can also be used to add vector to vector,
        returning vector.

        :param other: :py:class:`Point` or vector to add
        :return: :py:class:`Point` equal to self offset by other
        """
    def __eq__(self, other: Point) -> bool:
        """
        Returns true if self is not equivalent to other.

        :param other: :py:class:`Point` to compare
        :return: true if self.fX == other.fX and self.fY == other.fY
        """
    def __iadd__(self, v: Point) -> Point:
        """
        Adds vector v to :py:class:`Point`.

        Sets :py:class:`Point` to: (fX + v.fX, fY + v.fY).

        :param v: vector to add
        """
    def __imul__(self, scale: float) -> Point:
        """
        Multiplies :py:class:`Point` by scale.

        Sets :py:class:`Point` to: (fX * scale, fY * scale).

        :param scale: scalar to multiply by
        :return: reference to :py:class:`Point`
        """
    @typing.overload
    def __init__(self, x: float, y: float) -> None:
        """
        Sets fX to x, fY to y.

        Used both to set :py:class:`Point` and vector.

        :param float x: :py:class:`Scalar` x-axis value of constructed
            :py:class:`Point` or vector
        :param float y: :py:class:`Scalar` y-axis value of constructed
            :py:class:`Point` or vector
        :return: :py:class:`Point` (x, y)
        """
    @typing.overload
    def __init__(self, ipoint: IPoint) -> None: ...
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __isub__(self, v: Point) -> Point:
        """
        Subtracts vector v from :py:class:`Point`.

        Sets :py:class:`Point` to: (fX - v.fX, fY - v.fY).

        :param v: vector to subtract
        """
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __mul__(self, scale: float) -> Point:
        """
        Returns :py:class:`Point` multiplied by scale.
        """
    def __ne__(self, other: Point) -> bool:
        """
        Returns true if self is equivalent to other.

        :param other: :py:class:`Point` to compare
        :return: true if self.fX != other.fX or self.fY != other.fY
        """
    def __neg__(self) -> Point:
        """
        Returns :py:class:`Point` changing the signs of fX and fY.
        """
    def __sub__(self, other: Point) -> Point:
        """
        Returns vector from other to self, computed as (self.fX - other.fX,
        self.fY - other.fY).

        Can also be used to subtract vector from :py:class:`Point`, returning
        :py:class:`Point`. Can also be used to subtract vector from vector,
        returning vector.

        :param other: :py:class:`Point` to subtract
        :return: vector from other to self
        """
    def cross(self, vec: Point) -> float:
        """
        Returns the cross product of vector and vec.

        Vector and vec form three-dimensional vectors with z-axis value equal to
        zero. The cross product is a three-dimensional vector with x-axis and
        y-axis values equal to zero. The cross product z-axis component is
        returned.

        :param vec: right side of cross product
        :return: area spanned by vectors signed by angle direction
        """
    def distanceToOrigin(self) -> float:
        """
        Returns the Euclidean distance from origin, computed as:

            sqrt(fX * fX + fY * fY)

        :return: straight-line distance to origin
        """
    def dot(self, vec: Point) -> float:
        """
        Returns the dot product of vector and vector vec.

        :param vec: right side of dot product
        :return: product of input magnitudes and cosine of the angle between
            them
        """
    def equals(self, x: float, y: float) -> bool:
        """
        Returns true if :py:class:`Point` is equivalent to :py:class:`Point`
        constructed from (x, y).

        :param x: value compared with fX
        :param y: value compared with fY
        :return: true if :py:class:`Point` equals (x, y)
        """
    def isFinite(self) -> bool:
        """
        Returns true if both fX and fY are measurable values.

        :return: true for values other than infinities and NaN
        """
    def isZero(self) -> bool:
        """
        Returns true if fX and fY are both zero.

        :return: true if fX is zero and fY is zero
        """
    @typing.overload
    def iset(self, x: int, y: int) -> None:
        """
        Sets fX to x and fY to y, promoting integers to SkScalar values.

        Assigning a large integer value directly to fX or fY may cause a
        compiler error, triggered by narrowing conversion of int to SkScalar.
        This safely casts x and y to avoid the error.

        :x: new value for fX
        :y: new value for fY
        """
    @typing.overload
    def iset(self, p: IPoint) -> None:
        """
        Sets fX to p.fX and fY to p.fY, promoting integers to SkScalar values.

        Assigning an :py:class:`IPoint` containing a large integer value
        directly to fX or fY may cause a compiler error, triggered by narrowing
        conversion of int to SkScalar. This safely casts p.fX and p.fY to avoid
        the error.

        :p: :py:class:`IPoint` members promoted to SkScalar
        """
    def length(self) -> float:
        """
        Returns the Euclidean distance from origin, computed as:

            sqrt(fX * fX + fY * fY)

        :return: straight-line distance to origin
        """
    def negate(self) -> None:
        """
        Changes the sign of fX and fY.
        """
    def normalize(self) -> bool:
        """
        Scales (fX, fY) so that :py:meth:`length` returns one, while preserving
        ratio of fX to fY, if possible.

        If prior length is nearly zero, sets vector to (0, 0) and returns false;
        otherwise returns true.

        :return: true if former length is not zero or nearly zero
        """
    def offset(self, dx: float, dy: float) -> None:
        """
        Adds offset (dx, dy) to :py:class:`Point`.

        :param dx: added to fX
        :param dy: added to fY
        """
    def scale(self, scale: float) -> Point:
        """
        Sets dst to :py:class:`Point` times scale.

        dst may be :py:class:`Point` to modify :py:class:`Point` in place.

        It is also possible to use operators::

            p * scale
            p *= scale  # in-place

        :param scale: factor to multiply :py:class:`Point` by
        """
    def set(self, x: float, y: float) -> None:
        """
        Sets fX to x and fY to y.

        :param x: new value for fX
        :param y: new value for fY
        """
    def setAbs(self, pt: Point) -> None:
        """
        Sets fX to absolute value of pt.fX; and fY to absolute value of pt.fY.

        :param pt: members providing magnitude for fX and fY
        """
    @typing.overload
    def setLength(self, length: float) -> bool:
        """
        Scales vector so that :py:meth:`distanceToOrigin` returns length, if
        possible.

        If former length is nearly zero, sets vector to (0, 0) and return false;
        otherwise returns true.

        :length: straight-line distance to origin
        :return: true if former length is not zero or nearly zero
        """
    @typing.overload
    def setLength(self, x: float, y: float, length: float) -> bool:
        """
        Sets vector to (x, y) scaled to length, if possible.

        If former length is nearly zero, sets vector to (0, 0) and return false;
        otherwise returns true.

        :x: proportional value for fX
        :y: proportional value for fY
        :length: straight-line distance to origin
        :return: true if (x, y) length is not zero or nearly zero
        """
    def setNormalize(self, x: float, y: float) -> bool:
        """
        Sets vector to (x, y) scaled so :py:meth:`length` returns one, and so
        that (fX, fY) is proportional to (x, y).

        If (x, y) length is nearly zero, sets vector to (0, 0) and returns
        false; otherwise returns true.

        :param x: proportional value for fX
        :param y: proportional value for fY
        :return: true if (x, y) length is not zero or nearly zero
        """
    def x(self) -> float:
        """
        Returns x-axis value of :py:class:`Point` or vector.
        """
    def y(self) -> float:
        """
        Returns y-axis value of :py:class:`Point` or vector.
        """
    @property
    def fX(self) -> float:
        """
        x-axis value
        """
    @fX.setter
    def fX(self, arg0: float) -> None: ...
    @property
    def fY(self) -> float:
        """
        y-axis value
        """
    @fY.setter
    def fY(self, arg0: float) -> None: ...

class Point3:
    """

    :py:class:`Point` holds three 32-bit floating point coordinates.

    Example::

        point = skia.Point3(0.0, 0.0, 0.0)
        point = skia.Point3((0.0, 0.0, 0.0))  # Convert from tuple
        print(point.fX, point.fY, point.fZ)
        x, y, z = tuple(point)  # Convert to tuple

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def CrossProduct(a: Point3, b: Point3) -> Point3:
        """
        Returns the cross product of a and b, treating them as 3D vectors.
        """
    @staticmethod
    def DotProduct(a: Point3, b: Point3) -> float:
        """
        Returns the dot product of a and b, treating them as 3D vectors.
        """
    @staticmethod
    def Length(x: float, y: float, z: float) -> float:
        """
        Returns the Euclidian distance from (0,0,0) to (x,y,z)
        """
    @staticmethod
    def Make(x: float, y: float, z: float) -> Point3: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __add__(self, other: Point3) -> Point3:
        """
        Returns a new point whose coordinates are the sum of a and b (a + b)
        """
    def __eq__(self, other: Point3) -> bool: ...
    def __iadd__(self, v: Point3) -> Point3:
        """
        Add v's coordinates to the point's.
        """
    @typing.overload
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __isub__(self, v: Point3) -> Point3:
        """
        Subtract v's coordinates from the point's.
        """
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Point3) -> bool: ...
    def __neg__(self) -> Point3:
        """
        Return a new point whose X, Y and Z coordinates are the negative of the
        original point's.
        """
    def __rmul__(self, scale: float) -> Point3: ...
    def __sub__(self, other: Point3) -> Point3:
        """
        Returns a new point whose coordinates are the difference between a and b
        (i.e., a - b)
        """
    def cross(self, vec: Point3) -> Point3: ...
    def dot(self, vec: Point3) -> float: ...
    def isFinite(self) -> bool:
        """
        Returns true if fX, fY, and fZ are measurable values.
        """
    def length(self) -> float:
        """
        Return the Euclidian distance from (0,0,0) to the point.
        """
    def makeScale(self, scale: float) -> Point3:
        """
        Return a new point whose X, Y and Z coordinates are scaled.
        """
    def normalize(self) -> bool:
        """
        Set the point (vector) to be unit-length in the same direction as it
        already points.

        If the point has a degenerate length (i.e., nearly 0) then set it to
        (0,0,0) and return false; otherwise return true.
        """
    def scale(self, scale: float) -> None:
        """
        Scale the point's coordinates by scale.
        """
    def set(self, x: float, y: float, z: float) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    @property
    def fX(self) -> float:
        """
        x-axis value
        """
    @fX.setter
    def fX(self, arg0: float) -> None: ...
    @property
    def fY(self) -> float:
        """
        y-axis value
        """
    @fY.setter
    def fY(self, arg0: float) -> None: ...
    @property
    def fZ(self) -> float:
        """
        z-axis value
        """
    @fZ.setter
    def fZ(self, arg0: float) -> None: ...

class RRect:
    """

    :py:class:`RRect` describes a rounded rectangle with a bounds and a pair of
    radii for each corner.

    The bounds and radii can be set so that :py:class:`RRect` describes: a
    rectangle with sharp corners; a circle; an oval; or a rectangle with one or
    more rounded corners.

    :py:class:`RRect` allows implementing CSS properties that describe rounded
    corners. :py:class:`RRect` may have up to eight different radii, one for
    each axis on each of its four corners.

    :py:class:`RRect` may modify the provided parameters when initializing
    bounds and radii. If either axis radii is zero or less: radii are stored as
    zero; corner is square. If corner curves overlap, radii are proportionally
    reduced to fit within bounds.

    """
    class Corner:
        """
        Members:

          kUpperLeft_Corner : index of top-left corner radii

          kUpperRight_Corner : index of top-right corner radii

          kLowerRight_Corner : index of bottom-right corner radii

          kLowerLeft_Corner : index of bottom-left corner radii
        """

        __members__: typing.ClassVar[
            dict[str, RRect.Corner]
        ]  # value = {'kUpperLeft_Corner': <Corner.kUpperLeft_Corner: 0>, 'kUpperRight_Corner': <Corner.kUpperRight_Corner: 1>, 'kLowerRight_Corner': <Corner.kLowerRight_Corner: 2>, 'kLowerLeft_Corner': <Corner.kLowerLeft_Corner: 3>}
        kLowerLeft_Corner: typing.ClassVar[
            RRect.Corner
        ]  # value = <Corner.kLowerLeft_Corner: 3>
        kLowerRight_Corner: typing.ClassVar[
            RRect.Corner
        ]  # value = <Corner.kLowerRight_Corner: 2>
        kUpperLeft_Corner: typing.ClassVar[
            RRect.Corner
        ]  # value = <Corner.kUpperLeft_Corner: 0>
        kUpperRight_Corner: typing.ClassVar[
            RRect.Corner
        ]  # value = <Corner.kUpperRight_Corner: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Type:
        """
        Members:

          kEmpty_Type : zero width or height

          kRect_Type : non-zero width and height, and zeroed radii

          kOval_Type : non-zero width and height filled with radii

          kSimple_Type : non-zero width and height with equal radii

          kNinePatch_Type : non-zero width and height with axis-aligned radii

          kComplex_Type : non-zero width and height with arbitrary radii

          kLastType : largest Type value
        """

        __members__: typing.ClassVar[
            dict[str, RRect.Type]
        ]  # value = {'kEmpty_Type': <Type.kEmpty_Type: 0>, 'kRect_Type': <Type.kRect_Type: 1>, 'kOval_Type': <Type.kOval_Type: 2>, 'kSimple_Type': <Type.kSimple_Type: 3>, 'kNinePatch_Type': <Type.kNinePatch_Type: 4>, 'kComplex_Type': <Type.kComplex_Type: 5>, 'kLastType': <Type.kComplex_Type: 5>}
        kComplex_Type: typing.ClassVar[RRect.Type]  # value = <Type.kComplex_Type: 5>
        kEmpty_Type: typing.ClassVar[RRect.Type]  # value = <Type.kEmpty_Type: 0>
        kLastType: typing.ClassVar[RRect.Type]  # value = <Type.kComplex_Type: 5>
        kNinePatch_Type: typing.ClassVar[
            RRect.Type
        ]  # value = <Type.kNinePatch_Type: 4>
        kOval_Type: typing.ClassVar[RRect.Type]  # value = <Type.kOval_Type: 2>
        kRect_Type: typing.ClassVar[RRect.Type]  # value = <Type.kRect_Type: 1>
        kSimple_Type: typing.ClassVar[RRect.Type]  # value = <Type.kSimple_Type: 3>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kComplex_Type: typing.ClassVar[RRect.Type]  # value = <Type.kComplex_Type: 5>
    kEmpty_Type: typing.ClassVar[RRect.Type]  # value = <Type.kEmpty_Type: 0>
    kLastType: typing.ClassVar[RRect.Type]  # value = <Type.kComplex_Type: 5>
    kLowerLeft_Corner: typing.ClassVar[
        RRect.Corner
    ]  # value = <Corner.kLowerLeft_Corner: 3>
    kLowerRight_Corner: typing.ClassVar[
        RRect.Corner
    ]  # value = <Corner.kLowerRight_Corner: 2>
    kNinePatch_Type: typing.ClassVar[RRect.Type]  # value = <Type.kNinePatch_Type: 4>
    kOval_Type: typing.ClassVar[RRect.Type]  # value = <Type.kOval_Type: 2>
    kRect_Type: typing.ClassVar[RRect.Type]  # value = <Type.kRect_Type: 1>
    kSimple_Type: typing.ClassVar[RRect.Type]  # value = <Type.kSimple_Type: 3>
    kSizeInMemory: typing.ClassVar[int] = 48
    kUpperLeft_Corner: typing.ClassVar[
        RRect.Corner
    ]  # value = <Corner.kUpperLeft_Corner: 0>
    kUpperRight_Corner: typing.ClassVar[
        RRect.Corner
    ]  # value = <Corner.kUpperRight_Corner: 1>
    @staticmethod
    def MakeEmpty() -> RRect:
        """
        Initializes bounds at (0, 0), the origin, with zero width and height.

        Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

        :return: empty :py:class:`RRect`
        """
    @staticmethod
    def MakeOval(oval: Rect) -> RRect:
        """
        Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis
        radii to half oval.height().

        If oval bounds is empty, sets to kEmpty_Type. Otherwise, sets to
        kOval_Type.

        :param oval:    bounds of oval
        :return: oval
        """
    @staticmethod
    def MakeRect(r: Rect) -> RRect:
        """
        Initializes to copy of r bounds and zeroes corner radii.

        :param r: bounds to copy
        :return: copy of r
        """
    @staticmethod
    def MakeRectXY(rect: Rect, xRad: float, yRad: float) -> RRect:
        """
        Sets to rounded rectangle with the same radii for all four corners.

        If rect is empty, sets to kEmpty_Type. Otherwise, if xRad and yRad are
        zero, sets to kRect_Type. Otherwise, if xRad is at least half
        rect.width() and yRad is at least half rect.height(), sets to
        kOval_Type. Otherwise, sets to kSimple_Type.

        :param rect:    bounds of rounded rectangle
        :param xRad:    x-axis radius of corners
        :param yRad:    y-axis radius of corners
        :return: rounded rectangle
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: RRect) -> bool:
        """
        Returns true if bounds and radii in self are equal to bounds and radii
        in other.

        self and other are not equal if either contain NaN. self and other are
        equal if members contain zeroes with different signs.

        :param other: :py:class:`Rect` bounds and radii to compare
        :return: true if members are equal
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Initializes bounds at (0, 0), the origin, with zero width and height.

        Initializes corner radii to (0, 0), and sets type of kEmpty_Type.

        :return: empty :py:class:`RRect`
        """
    @typing.overload
    def __init__(self, rrect: RRect) -> None:
        """
        Initializes to copy of rrect bounds and corner radii.

        :rrect: bounds and corner to copy
        :return: copy of rrect
        """
    @typing.overload
    def __init__(self, rect: Rect, xRad: float, yRad: float) -> None:
        """
        Initializes to rounded rectangle with the same radii for all four
        corners.

        If rect is empty, sets to kEmpty_Type. Otherwise, if xRad and yRad are
        zero, sets to kRect_Type. Otherwise, if xRad is at least half
        rect.width() and yRad is at least half rect.height(), sets to
        kOval_Type. Otherwise, sets to kSimple_Type.

        :rect:    bounds of rounded rectangle
        :xRad:    x-axis radius of corners
        :yRad:    y-axis radius of corners
        :return: rounded rectangle
        """
    def __ne__(self, other: RRect) -> bool:
        """
        Returns true if bounds and radii in self are not equal to bounds and
        radii in other.

        self and other are not equal if either contain NaN. self and other are
        equal if members contain zeroes with different signs.

        :param other: :py:class:`Rect` bounds and radii to compare
        :return: true if members are not equal
        """
    def contains(self, rect: Rect) -> bool:
        """
        Returns true if rect is inside the bounds and corner radii, and if
        :py:class:`RRect` and rect are not empty.

        :param rect:  area tested for containment
        :return: true if SkRRect contains rect
        """
    def dump(self, asHex: bool = False) -> None:
        """
        Writes text representation of :py:class:`RRect` to standard output.

        Set asHex true to generate exact binary representations of floating
        point numbers.

        :param asHex:  true if Scalar values are written as hexadecimal
        """
    def dumpHex(self) -> None:
        """
        Writes text representation of :py:class:`RRect` to standard output.

        The representation may be directly compiled as C++ code. Floating point
        values are written in hexadecimal to preserve their exact bit pattern.
        The output reconstructs the original :py:class:`RRect`.
        """
    def dumpToString(self, asHex: bool) -> String: ...
    def getBounds(self) -> Rect:
        """
        Returns bounds.

        Bounds may have zero width or zero height. Bounds right is greater than
        or equal to left; bounds bottom is greater than or equal to top. Result
        is identical to :py:meth:`rect`.

        :return: bounding box
        """
    def getSimpleRadii(self) -> Point:
        """
        Returns top-left corner radii.

        If :py:meth:`type` returns kEmpty_Type, kRect_Type, kOval_Type, or
        kSimple_Type, returns a value representative of all corner radii. If
        :py:meth:`type` returns kNinePatch_Type or kComplex_Type, at least one
        of the remaining three corners has a different value.

        :return: corner radii for simple types
        """
    def getType(self) -> RRect.Type: ...
    def height(self) -> float:
        """
        Returns span on the y-axis.

        This does not check if result fits in 32-bit float; result may be
        infinity.

        :return: rect().fBottom minus rect().fTop
        """
    @typing.overload
    def inset(self, dx: float, dy: float, dst: RRect) -> None:
        """
        Copies :py:class:`RRect` to dst, then insets dst bounds by dx and dy,
        and adjusts dst radii by dx and dy.

        dx and dy may be positive, negative, or zero. dst may be
        :py:class:`RRect`.

        If either corner radius is zero, the corner has no curvature and is
        unchanged. Otherwise, if adjusted radius becomes negative, pins radius
        to zero. If dx exceeds half dst bounds width, dst bounds left and right
        are set to bounds x-axis center. If dy exceeds half dst bounds height,
        dst bounds top and bottom are set to bounds y-axis center.

        If dx or dy cause the bounds to become infinite, dst bounds is zeroed.

        :dx:  added to rect().fLeft, and subtracted from rect().fRight
        :dy:  added to rect().fTop, and subtracted from rect().fBottom
        :dst: insets bounds and radii
        """
    @typing.overload
    def inset(self, dx: float, dy: float) -> None:
        """
        Insets bounds by dx and dy, and adjusts radii by dx and dy.

        dx and dy may be positive, negative, or zero.

        If either corner radius is zero, the corner has no curvature and is
        unchanged. Otherwise, if adjusted radius becomes negative, pins radius
        to zero. If dx exceeds half bounds width, bounds left and right are set
        to bounds x-axis center. If dy exceeds half bounds height, bounds top
        and bottom are set to bounds y-axis center.

        If dx or dy cause the bounds to become infinite, bounds is zeroed.

        :dx:  added to rect().fLeft, and subtracted from rect().fRight
        :dy:  added to rect().fTop, and subtracted from rect().fBottom
        """
    def isComplex(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNinePatch(self) -> bool: ...
    def isOval(self) -> bool: ...
    def isRect(self) -> bool: ...
    def isSimple(self) -> bool: ...
    def isValid(self) -> bool:
        """
        Returns true if bounds and radii values are finite and describe a
        :py:class:`RRect` :py:class:`RRect.Type` that matches
        :py:meth:`getType`.

        All :py:class:`RRect` methods construct valid types, even if the input
        values are not valid. Invalid :py:class:`RRect` data can only be
        generated by corrupting memory.

        :return: true if bounds and radii match :py:meth:`type`
        """
    def makeOffset(self, dx: float, dy: float) -> RRect:
        """
        Returns :py:class:`RRect` translated by (dx, dy).

        :param dx:  offset added to rect().fLeft and rect().fRight
        :param dy:  offset added to rect().fTop and rect().fBottom
        :return: :py:class:`RRect` bounds offset by (dx, dy), with unchanged
            corner radii
        """
    def offset(self, dx: float, dy: float) -> None:
        """
        Translates :py:class:`RRect` by (dx, dy).

        :param dx:  offset added to rect().fLeft and rect().fRight
        :parma dy:  offset added to rect().fTop and rect().fBottom
        """
    @typing.overload
    def outset(self, dx: float, dy: float, dst: RRect) -> None:
        """
        Outsets dst bounds by dx and dy, and adjusts radii by dx and dy.

        dx and dy may be positive, negative, or zero.

        If either corner radius is zero, the corner has no curvature and is
        unchanged. Otherwise, if adjusted radius becomes negative, pins radius
        to zero. If dx exceeds half dst bounds width, dst bounds left and right
        are set to bounds x-axis center. If dy exceeds half dst bounds height,
        dst bounds top and bottom are set to bounds y-axis center.

        If dx or dy cause the bounds to become infinite, dst bounds is zeroed.

        :dx:  subtracted from rect().fLeft, and added to rect().fRight
        :dy:  subtracted from rect().fTop, and added to rect().fBottom
        :dst: outset bounds and radii
        """
    @typing.overload
    def outset(self, dx: float, dy: float) -> None:
        """
        Outsets bounds by dx and dy, and adjusts radii by dx and dy.

        dx and dy may be positive, negative, or zero.

        If either corner radius is zero, the corner has no curvature and is
        unchanged. Otherwise, if adjusted radius becomes negative, pins radius
        to zero. If dx exceeds half bounds width, bounds left and right are set
        to bounds x-axis center. If dy exceeds half bounds height, bounds top
        and bottom are set to bounds y-axis center.

        If dx or dy cause the bounds to become infinite, bounds is zeroed.

        :dx:  subtracted from rect().fLeft, and added to rect().fRight
        :dy:  subtracted from rect().fTop, and added to rect().fBottom
        """
    def radii(self, corner: RRect.Corner) -> Point:
        """
        Returns scalar pair for radius of curve on x-axis and y-axis for one
        corner.

        Both radii may be zero. If not zero, both are positive and finite.

        :return: x-axis and y-axis radii for one corner
        """
    def readFromMemory(self, buffer: str) -> int:
        """
        Reads :py:class:`RRect` from buffer, reading kSizeInMemory bytes.

        Returns kSizeInMemory, bytes read if length is at least kSizeInMemory.
        Otherwise, returns zero.

        :param buffer:  memory to read from
        :return: bytes read, or 0 if length is less than kSizeInMemory
        """
    def rect(self) -> Rect:
        """
        Returns bounds.

        Bounds may have zero width or zero height. Bounds right is greater than
        or equal to left; bounds bottom is greater than or equal to top. Result
        is identical to :py:meth:`getBounds`.

        :return: bounding box
        """
    def setEmpty(self) -> None:
        """
        Sets bounds to zero width and height at (0, 0), the origin.

        Sets corner radii to zero and sets type to kEmpty_Type.
        """
    def setNinePatch(
        self,
        rect: Rect,
        leftRad: float,
        topRad: float,
        rightRad: float,
        bottomRad: float,
    ) -> None:
        """
        Sets bounds to rect.

        Sets radii to (leftRad, topRad), (rightRad, topRad), (rightRad,
        bottomRad), (leftRad, bottomRad).

        If rect is empty, sets to kEmpty_Type. Otherwise, if leftRad and
        rightRad are zero, sets to kRect_Type. Otherwise, if topRad and
        bottomRad are zero, sets to kRect_Type. Otherwise, if leftRad and
        rightRad are equal and at least half rect.width(), and topRad and
        bottomRad are equal at least half rect.height(), sets to kOval_Type.
        Otherwise, if leftRad and rightRad are equal, and topRad and bottomRad
        are equal, sets to kSimple_Type. Otherwise, sets to kNinePatch_Type.

        Nine patch refers to the nine parts defined by the radii: one center
        rectangle, four edge patches, and four corner patches.

        :param rect:    bounds of rounded rectangle
        :param leftRad: left-top and left-bottom x-axis radius
        :param topRad:  left-top and right-top y-axis radius
        :param rightRad:    right-top and right-bottom x-axis radius
        :param bottomRad:   left-bottom and right-bottom y-axis radius
        """
    def setOval(self, oval: Rect) -> None:
        """
        Sets bounds to oval, x-axis radii to half oval.width(), and all y-axis
        radii to half oval.height().

        If oval bounds is empty, sets to kEmpty_Type. Otherwise, sets to
        kOval_Type.

        :param oval:    bounds of oval
        """
    def setRect(self, rect: Rect) -> None:
        """
        Sets bounds to sorted rect, and sets corner radii to zero.

        If set bounds has width and height, and sets type to kRect_Type;
        otherwise, sets type to kEmpty_Type.

        :param rect:    bounds to set
        """
    def setRectRadii(self, rect: Rect, radii: list[Point]) -> None:
        """
        Sets bounds to rect.

        Sets radii array for individual control of all for corners.

        If rect is empty, sets to kEmpty_Type. Otherwise, if one of each corner
        radii are zero, sets to kRect_Type. Otherwise, if all x-axis radii are
        equal and at least half rect.width(), and all y-axis radii are equal at
        least half rect.height(), sets to kOval_Type. Otherwise, if all x-axis
        radii are equal, and all y-axis radii are equal, sets to kSimple_Type.
        Otherwise, sets to kNinePatch_Type.

        :param rect:    bounds of rounded rectangle
        :param radii:   corner x-axis and y-axis radii
        """
    def setRectXY(self, rect: Rect, xRad: float, yRad: float) -> None:
        """
        Sets to rounded rectangle with the same radii for all four corners.

        If rect is empty, sets to kEmpty_Type. Otherwise, if xRad or yRad is
        zero, sets to kRect_Type. Otherwise, if xRad is at least half
        rect.width() and yRad is at least half rect.height(), sets to
        kOval_Type. Otherwise, sets to kSimple_Type.

        :param rect:  bounds of rounded rectangle
        :param xRad:  x-axis radius of corners
        :param yRad:  y-axis radius of corners
        """
    def transform(self, matrix: Matrix, dst: RRect) -> bool:
        """
        Transforms by :py:class:`RRect` by matrix, storing result in dst.

        Returns true if :py:class:`RRect` transformed can be represented by
        another :py:class:`RRect`. Returns false if matrix contains
        transformations that are not axis aligned.

        Asserts in debug builds if :py:class:`RRect` equals dst.

        :param matrix:  :py:class:`Matrix` specifying the transform
        :param dst: :py:class:`RRect` to store the result
        :return: true if transformation succeeded.
        """
    def type(self) -> RRect.Type: ...
    def width(self) -> float:
        """
        Returns span on the x-axis.

        This does not check if result fits in 32-bit float; result may be
        infinity.

        :return: rect().fRight minus rect().fLeft
        """
    def writeToMemory(self) -> bytes:
        """
        Writes :py:class:`RRect` to buffer.

        Writes kSizeInMemory bytes, and returns kSizeInMemory, the number of
        bytes written.

        :return: bytes written, kSizeInMemory
        """

class RSXform:
    """

    A compressed form of a rotation+scale matrix.

        [ fSCos -fSSin fTx ]
        [ fSSin fSCos fTy ]
        [ 0 0 1 ]

    """

    fSCos: float
    fSSin: float
    fTx: float
    fTy: float
    @staticmethod
    def Make(scos: float, ssin: float, tx: float, ty: float) -> RSXform: ...
    @staticmethod
    def MakeFromRadians(
        scale: float,
        radians: float,
        tx: float,
        ty: float,
        ax: float,
        ay: float,
    ) -> RSXform: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self, scos: float, ssin: float, tx: float, ty: float) -> None: ...
    def rectStaysRect(self) -> bool: ...
    def set(self, scos: float, ssin: float, tx: float, ty: float) -> None: ...
    def setIdentity(self) -> None: ...
    @typing.overload
    def toQuad(self, width: float, height: float, quqd: Point) -> None: ...
    @typing.overload
    def toQuad(self, size: Size, quqd: Point) -> None: ...
    def toTriStrip(self, width: float, height: float, strip: Point) -> None: ...

class RTreeFactory(BBHFactory):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __call__(self) -> BBoxHierarchy: ...
    def __init__(self) -> None: ...

class Rect:
    """

    :py:class:`Rect` holds four float coordinates describing the upper and lower
    bounds of a rectangle.

    :py:class:`Rect` may be created from outer bounds or from position, width,
    and height. :py:class:`Rect` describes an area; if its right is less than or
    equal to its left, or if its bottom is less than or equal to its top, it is
    considered empty.

    Example::

        rect = skia.Rect(0, 0, 180, 120)
        rect = skia.Rect((0, 0, 180, 120))  # Convert from tuple
        print(rect.width(), rect.height())
        left, top, right, bottom = tuple(rect)  # Convert to tuple

    """

    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Intersects(a: Rect, b: Rect) -> bool:
        """
        Returns true if a intersects b.

        Returns false if either a or b is empty, or do not intersect.

        :param a:  :py:class:`Rect` to intersect
        :param b:  :py:class:`Rect` to intersect
        :return: true if a and b have area in common
        """
    @staticmethod
    @typing.overload
    def Make(size: ISize) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to (0, 0, size.width(),
        size.height()).

        Does not validate input; size.width() or size.height() may be negative.

        :size: integer values for :py:class:`Rect` width and height
        :return: bounds (0, 0, size.width(), size.height())
        """
    @staticmethod
    @typing.overload
    def Make(irect: IRect) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to irect, promoting integers
        to scalar.

        Does not validate input; fLeft may be greater than fRight, fTop may be
        greater than fBottom.

        :irect: integer unsorted bounds
        :return: irect members converted to Scalar
        """
    @staticmethod
    def MakeEmpty() -> Rect:
        """
        Returns constructed :py:class:`Rect` set to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.

        :return: bounds (0, 0, 0, 0)
        """
    @staticmethod
    def MakeIWH(w: int, h: int) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to integer values (0, 0, w, h).

        Does not validate input; w or h may be negative.

        Use to avoid a compiler warning that input may lose precision when
        stored. Use :py:class:`IRect` for an exact integer rectangle.

        :param w: integer width of constructed :py:class:`Rect`
        :param h: integer height of constructed :py:class:`Rect`
        :return: bounds (0, 0, w, h)
        """
    @staticmethod
    def MakeLTRB(l: float, t: float, r: float, b: float) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to (l, t, r, b).

        Does not sort input; :py:class:`Rect` may result in fLeft greater than
        fRight, or fTop greater than fBottom.

        :param l:  Scalar stored in fLeft
        :param t:  Scalar stored in fTop
        :param r:  Scalar stored in fRight
        :param b:  Scalar stored in fBottom
        :return: bounds (l, t, r, b)
        """
    @staticmethod
    def MakeSize(size: Size) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to (0, 0, size.width(),
        size.height()).

        Does not validate input; size.width() or size.height() may be negative.

        :param size:  Scalar values for :py:class:`Rect` width and height
        :return: bounds (0, 0, size.width(), size.height())
        """
    @staticmethod
    def MakeWH(w: float, h: float) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to :py:class:`Scalar` values
        (0, 0, w, h).

        Does not validate input; w or h may be negative.

        Passing integer values may generate a compiler warning since
        :py:class:`Rect` cannot represent 32-bit integers exactly. Use
        :py:class:`IRect` for an exact integer rectangle.

        :param w: Scalar width of constructed :py:class:`Rect`
        :param h: Scalar height of constructed :py:class:`Rect`
        :return: bounds (0, 0, w, h)
        """
    @staticmethod
    def MakeXYWH(x: float, y: float, w: float, h: float) -> Rect:
        """
        Returns constructed :py:class:`Rect` set to (x, y, x + w, y + h).

        Does not validate input; w or h may be negative.

        :param x:  stored in fLeft
        :param y:  stored in fTop
        :param w:  added to x and stored in fRight
        :param h:  added to y and stored in fBottom
        :return: bounds at (x, y) with width w and height h
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __contains__(self, arg0: Point) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: Rect) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: IRect) -> bool: ...
    def __eq__(self, other: Rect) -> bool:
        """
        Returns true if all members in self: fLeft, fTop, fRight, and fBottom;
        are equal to the corresponding members in other.

        self and other are not equal if either contain NaN. self and other are
        equal if members contain zeroes with different signs.

        :param other: :py:class:`Rect` to compare
        :return: true if members are equal
        """
    @typing.overload
    def __init__(self) -> None:
        """
        Returns constructed :py:class:`Rect` set to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.

        :return: bounds (0, 0, 0, 0)
        """
    @typing.overload
    def __init__(self, w: float, h: float) -> None:
        """
        Returns constructed :py:class:`Rect` set to :py:class:`Scalar` values
        (0, 0, w, h).

        Does not validate input; w or h may be negative.

        Passing integer values may generate a compiler warning since
        :py:class:`Rect` cannot represent 32-bit integers exactly. Use
        :py:class:`IRect` for an exact integer rectangle.

        :w: Scalar width of constructed :py:class:`Rect`
        :h: Scalar height of constructed :py:class:`Rect`
        :return: bounds (0, 0, w, h)
        """
    @typing.overload
    def __init__(self, l: float, t: float, r: float, b: float) -> None:
        """
        Returns constructed :py:class:`Rect` set to (l, t, r, b).

        Does not sort input; :py:class:`Rect` may result in fLeft greater than
        fRight, or fTop greater than fBottom.

        :l:  Scalar stored in fLeft
        :t:  Scalar stored in fTop
        :r:  Scalar stored in fRight
        :b:  Scalar stored in fBottom
        :return: bounds (l, t, r, b)
        """
    @typing.overload
    def __init__(self, size: ISize) -> None:
        """
        Returns constructed :py:class:`Rect` set to (0, 0, size.width(),
        size.height()).

        Does not validate input; size.width() or size.height() may be negative.

        :size: integer values for :py:class:`Rect` width and height
        :return: bounds (0, 0, size.width(), size.height())
        """
    @typing.overload
    def __init__(self, irect: IRect) -> None:
        """
        Returns constructed :py:class:`Rect` set to irect, promoting integers
        to scalar.

        Does not validate input; fLeft may be greater than fRight, fTop may be
        greater than fBottom.

        :irect: integer unsorted bounds
        :return: irect members converted to Scalar
        """
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Rect) -> bool:
        """
        Returns true if any in self: fLeft, fTop, fRight, and fBottom; does not
        equal to the corresponding members in other.

        self and other are not equal if either contain NaN. self and other are
        equal if members contain zeroes with different signs.

        :param other: :py:class:`Rect` to compare
        :return: true if members are not equal
        """
    def asScalars(self) -> memoryview:
        """
        Returns pointer to first scalar in :py:class:`Rect`, to treat it as an
        array with four entries.

        :return: pointer to fLeft
        """
    def bottom(self) -> float:
        """
        Returns bottom edge of SkRect, if sorted.

        Call :py:meth:`isEmpty` to see if SkRect may be invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        :return: fBottom
        """
    def centerX(self) -> float:
        """
        Returns average of left edge and right edge.

        Result does not change if SkRect is sorted. Result may overflow to
        infinity if :py:class:`Rect` is far from the origin.

        :return: midpoint on x-axis
        """
    def centerY(self) -> float:
        """
        Returns average of top edge and bottom edge.

        Result does not change if :py:class:`Rect` is sorted.

        :return: midpoint on y-axis
        """
    @typing.overload
    def contains(self, x: float, y: float) -> bool:
        """
        Returns true if: fLeft <= x < fRight && fTop <= y < fBottom.

        Returns false if :py:class:`Rect` is empty.

        :x:  test :py:class:`Point` x-coordinate
        :y:  test :py:class:`Point` y-coordinate
        :return: true if (x, y) is inside :py:class:`Rect`
        """
    @typing.overload
    def contains(self, r: Rect) -> bool:
        """
        Returns true if :py:class:`Rect` contains r.

        Returns false if :py:class:`Rect` is empty or r is empty.

        :py:class:`Rect` contains r when :py:class:`Rect` area completely
        includes r area.

        :r: :py:class:`Rect` contained
        :return: true if all sides of :py:class:`Rect` are outside r
        """
    @typing.overload
    def contains(self, r: IRect) -> bool:
        """
        Returns true if :py:class:`Rect` contains r.

        Returns false if :py:class:`Rect` is empty or r is empty.

        :py:class:`Rect` contains r when :py:class:`Rect` area completely
        includes r area.

        :r: :py:class:`IRect` contained
        :return: true if all sides of :py:class:`Rect` are outside r
        """
    def dump(self, asHex: bool = False) -> None:
        """
        Writes text representation of :py:class:`Rect` to standard output.

        Set asHex to true to generate exact binary representations of floating
        point numbers.

        :param asHex: true if Scalar values are written as hexadecimal
        """
    def dumpHex(self) -> None:
        """
        Writes text representation of :py:class:`Rect` to standard output.

        The representation may be directly compiled as C++ code. Floating point
        values are written in hexadecimal to preserve their exact bit pattern.
        The output reconstructs the original :py:class:`Rect`.

        Use instead of dump() when submitting
        """
    def height(self) -> float:
        """
        Returns span on the y-axis.
        """
    def inset(self, dx: float, dy: float) -> None:
        """
        Insets :py:class:`Rect` by (dx, dy).

        If dx is positive, makes :py:class:`Rect` narrower. If dx is negative,
        makes :py:class:`Rect` wider. If dy is positive, makes :py:class:`Rect`
        shorter. If dy is negative, makes :py:class:`Rect` taller.

        :param dx:  added to fLeft and subtracted from fRight
        :param dy:  added to fTop and subtracted from fBottom
        """
    @typing.overload
    def intersect(self, r: Rect) -> bool:
        """
        Returns true if :py:class:`Rect` intersects r, and sets :py:class:`Rect`
        to intersection.

        Returns false if :py:class:`Rect` does not intersect r, and leaves
        :py:class:`Rect` unchanged.

        Returns false if either r or :py:class:`Rect` is empty, leaving
        :py:class:`Rect` unchanged.

        :r: limit of result
        :return: true if r and :py:class:`Rect` have area in common
        """
    @typing.overload
    def intersect(self, a: Rect, b: Rect) -> bool:
        """
        Returns true if a intersects b, and sets :py:class:`Rect` to
        intersection.

        Returns false if a does not intersect b, and leaves :py:class:`Rect`
        unchanged.

        Returns false if either a or b is empty, leaving :py:class:`Rect`
        unchanged.

        :a: :py:class:`Rect` to intersect
        :b: :py:class:`Rect` to intersect
        :return: true if a and b have area in common
        """
    def intersects(self, r: Rect) -> bool:
        """
        Returns true if :py:class:`Rect` intersects r.

        Returns false if either r or :py:class:`Rect` is empty, or do not
        intersect.

        :param r:  :py:class:`Rect` to intersect
        :return: true if r and :py:class:`Rect` have area in common
        """
    def isEmpty(self) -> bool:
        """
        Returns true if fLeft is equal to or greater than fRight, or if fTop is
        equal to or greater than fBottom.

        Call :py:meth:`sort` to reverse rectangles with negative
        :py:meth:`width` or :py:meth:`height`.

        :return: true if :py:meth:`width` or :py:meth:`height` are zero or
            negative
        """
    def isFinite(self) -> bool:
        """
        Returns true if all values in the rectangle are finite: SK_ScalarMin or
        larger, and SK_ScalarMax or smaller.

        :return: true if no member is infinite or NaN
        """
    def isSorted(self) -> bool:
        """
        Returns true if fLeft is equal to or less than fRight, or if fTop is
        equal to or less than fBottom.

        Call :py:meth:`sort` to reverse rectangles with negative
        :py:meth:`width` or :py:meth:`height`.

        :return: true if :py:meth:`width` or :py:meth:`height` are zero or
            positive
        """
    def join(self, r: Rect) -> None:
        """
        Sets :py:class:`Rect` to the union of itself and r.

        Has no effect if r is empty. Otherwise, if :py:class:`Rect` is empty,
        sets :py:class:`Rect` to r.

        :param r: expansion :py:class:`Rect`
        """
    def joinNonEmptyArg(self, r: Rect) -> None:
        """
        Sets :py:class:`Rect` to the union of itself and r.

        Asserts if r is empty and SK_DEBUG is defined. If :py:class:`Rect` is
        empty, sets :py:class:`Rect` to r.

        May produce incorrect results if r is empty.

        :param r: expansion :py:class:`Rect`
        """
    def joinPossiblyEmptyRect(self, r: Rect) -> None:
        """
        Sets :py:class:`Rect` to the union of itself and the construction.

        May produce incorrect results if :py:class:`Rect` or r is empty.

        :param r:  expansion :py:class:`Rect`
        """
    def left(self) -> float:
        """
        Returns left edge of SkRect, if sorted.

        Call :py:meth:`isSorted` to see if SkRect is valid. Call :py:meth:`sort`
        to reverse fLeft and fRight if needed.

        :return: fLeft
        """
    def makeInset(self, dx: float, dy: float) -> Rect:
        """
        Returns :py:class:`Rect`, inset by (dx, dy).

        If dx is negative, :py:class:`Rect` returned is wider. If dx is
        positive, :py:class:`Rect` returned is narrower. If dy is negative,
        :py:class:`Rect` returned is taller. If dy is positive, :py:class:`Rect`
        returned is shorter.

        :param dx: added to fLeft and subtracted from fRight
        :param dy: added to fTop and subtracted from fBottom
        :return: :py:class:`Rect` inset symmetrically left and right, top and
            bottom
        """
    @typing.overload
    def makeOffset(self, dx: float, dy: float) -> Rect:
        """
        Returns :py:class:`Rect` offset by (dx, dy).

        If dx is negative, :py:class:`Rect` returned is moved to the left. If dx
        is positive, :py:class:`Rect` returned is moved to the right. If dy is
        negative, :py:class:`Rect` returned is moved upward. If dy is positive,
        :py:class:`Rect` returned is moved downward.

        :dx: added to fLeft and fRight
        :dy: added to fTop and fBottom
        :return: :py:class:`Rect` offset on axes, with original width and height
        """
    @typing.overload
    def makeOffset(self, v: Point) -> Rect:
        """
        Returns :py:class:`Rect` offset by v.

        :v: added to rect
        :return: :py:class:`Rect` offset on axes, with original width and height
        """
    def makeOutset(self, dx: float, dy: float) -> Rect:
        """
        Returns :py:class:`Rect`, outset by (dx, dy).

        If dx is negative, :py:class:`Rect` returned is narrower. If dx is
        positive, :py:class:`Rect` returned is wider. If dy is negative,
        :py:class:`Rect` returned is shorter. If dy is positive,
        :py:class:`Rect` returned is taller.

        :param dx: subtracted to fLeft and added from fRight
        :param dy: subtracted to fTop and added from fBottom
        :return: :py:class:`Rect` outset symmetrically left and right, top and
            bottom
        """
    def makeSorted(self) -> Rect:
        """
        Returns :py:class:`Rect` with fLeft and fRight swapped if fLeft is
        greater than fRight; and with fTop and fBottom swapped if fTop is
        greater than fBottom.

        Result may be empty; and :py:meth:`width` and :py:meth:`height` will be
        zero or positive.

        :return: sorted :py:class:`Rect`
        """
    @typing.overload
    def offset(self, dx: float, dy: float) -> None:
        """
        Offsets :py:class:`Rect` by adding dx to fLeft, fRight; and by adding dy
        to fTop, fBottom.

        If dx is negative, moves :py:class:`Rect` to the left. If dx is
        positive, moves :py:class:`Rect` to the right. If dy is negative, moves
        :py:class:`Rect` upward. If dy is positive, moves :py:class:`Rect`
        downward.

        :dx:  offset added to fLeft and fRight
        :dy:  offset added to fTop and fBottom
        """
    @typing.overload
    def offset(self, delta: Point) -> None:
        """
        Offsets :py:class:`Rect` by adding delta.fX to fLeft, fRight; and by
        adding delta.fY to fTop, fBottom.

        If delta.fX is negative, moves :py:class:`Rect` to the left. If delta.fX
        is positive, moves :py:class:`Rect` to the right. If delta.fY is
        negative, moves :py:class:`Rect` upward. If delta.fY is positive, moves
        :py:class:`Rect` downward.

        :param delta: added to :py:class:`Rect`
        """
    def offsetTo(self, newX: float, newY: float) -> None:
        """
        Offsets :py:class:`Rect` so that fLeft equals newX, and fTop equals
        newY.

        width and height are unchanged.

        :param newX: stored in fLeft, preserving :py:meth:`width`
        :param newY: stored in fTop, preserving :py:meth:`height`
        """
    def outset(self, dx: float, dy: float) -> None:
        """
        Outsets :py:class:`Rect` by (dx, dy).

        If dx is positive, makes :py:class:`Rect` wider. If dx is negative,
        makes :py:class:`Rect` narrower. If dy is positive, makes
        :py:class:`Rect` taller. If dy is negative, makes :py:class:`Rect`
        shorter.

        :param dx:  subtracted to fLeft and added from fRight
        :param dy:  subtracted to fTop and added from fBottom
        """
    def right(self) -> float:
        """
        Returns right edge of SkRect, if sorted.

        Call :py:meth:`isSorted` to see if SkRect is valid. Call :py:meth:`sort`
        to reverse fLeft and fRight if needed.

        :return: fRight
        """
    def round(self) -> IRect:
        """
        Returns :py:class:`IRect` by adding 0.5 and discarding the fractional
        portion of :py:class:`Rect` members, using (
        ``SkScalarRoundToInt(fLeft)``, ``SkScalarRoundToInt(fTop)``,
        ``SkScalarRoundToInt(fRight)``, ``SkScalarRoundToInt(fBottom)``).

        :return: rounded :py:class:`IRect`
        """
    def roundIn(self) -> IRect:
        """
        Sets :py:class:`Rect` by rounding up fLeft and fTop; and discarding the
        fractional portion of fRight and fBottom, using (
        ``SkScalarCeilToInt(fLeft)``, ``SkScalarCeilToInt(fTop)``,
        ``SkScalarFloorToInt(fRight)``, ``SkScalarFloorToInt(fBottom)``).
        """
    def roundOut(self) -> IRect:
        """
        Sets :py:class:`IRect` by discarding the fractional portion of fLeft and
        fTop; and rounding up fRight and fBottom, using (
        ``SkScalarFloorToInt(fLeft)``, ``SkScalarFloorToInt(fTop)``,
        ``SkScalarCeilToInt(fRight)``, ``SkScalarCeilToInt(fBottom)``).

        :return: rounded :py:class:`IRect`
        """
    @typing.overload
    def set(self, src: IRect) -> None:
        """
        Sets :py:class:`Rect` to src, promoting src members from integer to
        scalar.

        Very large values in src may lose precision.

        :src: integer :py:class:`Rect`
        """
    @typing.overload
    def set(self, p0: Point, p1: Point) -> None:
        """
        Sets bounds to the smallest :py:class:`Rect` enclosing :py:class:`Point`
        p0 and p1.

        The result is sorted and may be empty. Does not check to see if values
        are finite.

        :p0:  corner to include
        :p1:  corner to include
        """
    def setBounds(self, points: list[Point]) -> None:
        """
        Sets to bounds of :py:class:`Point` array with count entries.

        If count is zero or smaller, or if :py:class:`Point` array contains an
        infinity or NaN, sets to (0, 0, 0, 0).

        Result is either empty or sorted: fLeft is less than or equal to fRight,
        and fTop is less than or equal to fBottom.

        :param points: :py:class:`Point` array
        """
    def setBoundsCheck(self, points: list[Point]) -> bool:
        """
        Sets to bounds of :py:class:`Point` array with count entries.

        Returns false if count is zero or smaller, or if :py:class:`Point` array
        contains an infinity or NaN; in these cases sets :py:class:`Rect` to
        (0, 0, 0, 0).

        Result is either empty or sorted: fLeft is less than or equal to fRight,
        and fTop is less than or equal to fBottom.

        :param points: :py:class:`Point` array
        :return: true if all :py:class:`Point` values are finite
        """
    def setBoundsNoCheck(self, points: list[Point]) -> None:
        """
        Sets to bounds of :py:class:`Point` pts array with count entries.

        If any :py:class:`Point` in pts contains infinity or NaN, all
        :py:class:`Rect` dimensions are set to NaN.

        :param points: :py:class:`Point` array
        """
    def setEmpty(self) -> None:
        """
        Sets :py:class:`Rect` to (0, 0, 0, 0).

        Many other rectangles are empty; if left is equal to or greater than
        right, or if top is equal to or greater than bottom. Setting all members
        to zero is a convenience, but does not designate a special empty
        rectangle.
        """
    def setIWH(self, width: int, height: int) -> None: ...
    def setLTRB(self, left: float, top: float, right: float, bottom: float) -> None:
        """
        Sets :py:class:`Rect` to (left, top, right, bottom).

        left and right are not sorted; left is not necessarily less than right.
        top and bottom are not sorted; top is not necessarily less than bottom.

        :param left:   stored in fLeft
        :param top:    stored in fTop
        :param right:  stored in fRight
        :param bottom: stored in fBottom
        """
    def setWH(self, width: float, height: float) -> None:
        """
        Sets :py:class:`Rect` to (0, 0, width, height).

        Does not validate input; width or height may be negative.

        :param width:   stored in fRight
        :param height:  stored in fBottom
        """
    def setXYWH(self, x: float, y: float, width: float, height: float) -> None:
        """
        Sets :py:class:`Rect` to (x, y, x + width, y + height).

        Does not validate input; width or height may be negative.

        :param x:   stored in fLeft
        :param y:   stored in fTop
        :param width:   added to x and stored in fRight
        :param height:  added to y and stored in fBottom
        """
    def sort(self) -> None:
        """
        Swaps fLeft and fRight if fLeft is greater than fRight; and swaps fTop
        and fBottom if fTop is greater than fBottom.

        Result may be empty; and :py:meth:`width` and :py:meth:`height` will be
        zero or positive.
        """
    def toQuad(self) -> list[Point]:
        """
        Returns four points in quad that enclose :py:class:`Rect` ordered as:
        top-left, top-right, bottom-right, bottom-left.

        :return: corners of :py:class:`Rect`
        """
    def top(self) -> float:
        """
        Returns top edge of SkRect, if sorted.

        Call :py:meth:`isEmpty` to see if SkRect may be invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        :return: fTop
        """
    def width(self) -> float:
        """
        Returns span on the x-axis.

        This does not check if :py:class:`Rect` is sorted, or if result fits in
        32-bit float; result may be negative or infinity.

        :return: fRight minus fLeft
        """
    def x(self) -> float:
        """
        Returns left edge of :py:class:`Rect`, if sorted.

        Call :py:meth:`isSorted` to see if :py:class:`Rect` is valid. Call
        :py:meth:`sort` to reverse fLeft and fRight if needed.

        :return: fLeft
        """
    def y(self) -> float:
        """
        Returns top edge of SkRect, if sorted.

        Call :py:meth:`isEmpty` to see if SkRect may be invalid, and
        :py:meth:`sort` to reverse fTop and fBottom if needed.

        :return: fTop
        """
    @property
    def fBottom(self) -> float:
        """
        larger y-axis bounds
        """
    @fBottom.setter
    def fBottom(self, arg0: float) -> None: ...
    @property
    def fLeft(self) -> float:
        """
        smaller x-axis bounds
        """
    @fLeft.setter
    def fLeft(self, arg0: float) -> None: ...
    @property
    def fRight(self) -> float:
        """
        larger x-axis bounds
        """
    @fRight.setter
    def fRight(self, arg0: float) -> None: ...
    @property
    def fTop(self) -> float:
        """
        smaller y-axis bounds
        """
    @fTop.setter
    def fTop(self, arg0: float) -> None: ...

class RefCnt(RefCntBase):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class RefCntBase:
    """

    :py:class:`RefCntBase` is the base class for objects that may be shared by
    multiple objects.

    When an existing owner wants to share a reference, it calls ref(). When an
    owner wants to release its reference, it calls unref(). When the shared
    object's reference count goes to zero as the result of an unref() call, its
    (virtual) destructor is called. It is an error for the destructor to be
    called explicitly (or via the object going out of scope on the stack or
    calling delete) if getRefCnt() > 1.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def ref(self) -> None:
        """
        Increment the reference count.

        Must be balanced by a call to :py:meth:`unref`.
        """
    def unique(self) -> bool:
        """
        May return true if the caller is the only owner.

        Ensures that all previous owner's actions are complete.
        """
    def unref(self) -> None:
        """
        Decrement the reference count.

        If the reference count is 1 before the decrement, then delete the
        object. Note that if this is the case, then the object needs to have
        been allocated via new, and not on the stack.
        """

class Region:
    """

    :py:class:`Region` describes the set of pixels used to clip
    :py:class:`Canvas`.

    :py:class:`Region` is compact, efficiently storing a single integer
    rectangle, or a run length encoded array of rectangles. :py:class:`Region`
    may reduce the current :py:class:`Canvas` clip, or may be drawn as one or
    more integer rectangles. :py:class:`Region` iterator returns the scan lines
    or rectangles contained by it, optionally intersecting a bounding rectangle.

    :py:class:`Region` supports a few operators::

        regionA == regionB  # Equality
        regionA != regionB  # Inequality

        regionA - regionB  # Difference
        regionA & regionB  # Intersect
        regionA | regionB  # Union
        regionA ^ regionB  # XOR

        regionA -= regionB  # In-place Difference
        regionA &= regionB  # In-place Intersect
        regionA |= regionB  # In-place Union
        regionA ^= regionB  # In-place XOR

    """
    class Cliperator:
        """

        Returns the sequence of rectangles, sorted along y-axis, then x-axis, that
        make up :py:class:`Region` intersected with the specified clip rectangle.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self, region: Region, clip: IRect) -> None:
            """
            Sets :py:class:`~Region.Cliperator` to return elements of
            :py:class:`IRect` array in :py:class:`Region` within clip.

            :param skia.Region region: :py:class:`Region` to iterate
            :param skia.IRect clip: bounds of iteration
            :return: :py:class:`Region` iterator
            """
        def __iter__(self) -> Region.Cliperator: ...
        def __next__(self) -> IRect: ...
        def done(self) -> bool:
            """
            Returns true if :py:class:`~Region.Cliperator` is pointing to final
            :py:class:`IRect` in :py:class:`Region`.

            :return: true if data parsing is complete
            """
        def next(self) -> None:
            """
            Advances iterator to next :py:class:`IRect` in :py:class:`Region`
            contained by clip.
            """
        def rect(self) -> IRect:
            """
            Returns :py:class:`IRect` element in :py:class:`Region`, intersected
            with clip passed to :py:class:`~Region.Cliperator` constructor.

            Does not return predictable results if :py:class:`Region` is empty.

            :return: part of :py:class:`Region` inside clip as :py:class:`IRect`
            """

    class Iterator:
        """

        Returns sequence of rectangles, sorted along y-axis, then x-axis, that make
        up :py:class:`Region`.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        @typing.overload
        def __init__(self) -> None:
            """
            Initializes :py:class:`~Region.Iterator` with an empty
            :py:class:`Region`.

            :py:meth:`done` on :py:class:`~Region.Iterator` returns true. Call
            :py:meth:`reset` to initialize :py:class:`~Region.Iterator` at a later
            time.

            :return: empty :py:class:`Region` iterator
            """
        @typing.overload
        def __init__(self, region: Region) -> None:
            """
            Sets :py:class:`~Region.Iterator` to return elements of
            :py:class:`IRect` array in region.

            :region: :py:class:`Region` to iterate
                :py:class:`Region` iterator
            """
        def __iter__(self) -> Region.Iterator: ...
        def __next__(self) -> IRect: ...
        def done(self) -> bool:
            """
            Returns true if :py:class:`~Region.Iterator` is pointing to final
            :py:class:`IRect` in :py:class:`Region`.

            :return: true if data parsing is complete
            """
        def next(self) -> None:
            """
            Advances :py:class:`~Region.Iterator` to next :py:class:`IRect` in
            :py:class:`Region` if it is not done.
            """
        def rect(self) -> IRect:
            """
            Returns :py:class:`IRect` element in :py:class:`Region`.

            Does not return predictable results if :py:class:`Region` is empty.

            :return: part of :py:class:`Region` as :py:class:`IRect`
            """
        def reset(self, region: Region) -> None:
            """
            Resets iterator, using the new :py:class:`Region`.

            :param region: :py:class:`Region` to iterate
            """
        def rewind(self) -> bool:
            """
            :py:class:`Point` :py:class:`~Region.Iterator` to start of
            :py:class:`Region`.

            Returns true if :py:class:`Region` was set; otherwise, returns false.

            :return: true if :py:class:`Region` was set
            """
        def rgn(self) -> Region:
            """
            Returns :py:class:`Region` if set; otherwise, returns nullptr.

            :return: iterated :py:class:`Region`
            """

    class Op:
        """
        Members:

          kDifference_Op

          kIntersect_Op

          kUnion_Op

          kXOR_Op

          kReverseDifference_Op

          kReplace_Op

          kLastOp
        """

        __members__: typing.ClassVar[
            dict[str, Region.Op]
        ]  # value = {'kDifference_Op': <Op.kDifference_Op: 0>, 'kIntersect_Op': <Op.kIntersect_Op: 1>, 'kUnion_Op': <Op.kUnion_Op: 2>, 'kXOR_Op': <Op.kXOR_Op: 3>, 'kReverseDifference_Op': <Op.kReverseDifference_Op: 4>, 'kReplace_Op': <Op.kReplace_Op: 5>, 'kLastOp': <Op.kReplace_Op: 5>}
        kDifference_Op: typing.ClassVar[Region.Op]  # value = <Op.kDifference_Op: 0>
        kIntersect_Op: typing.ClassVar[Region.Op]  # value = <Op.kIntersect_Op: 1>
        kLastOp: typing.ClassVar[Region.Op]  # value = <Op.kReplace_Op: 5>
        kReplace_Op: typing.ClassVar[Region.Op]  # value = <Op.kReplace_Op: 5>
        kReverseDifference_Op: typing.ClassVar[
            Region.Op
        ]  # value = <Op.kReverseDifference_Op: 4>
        kUnion_Op: typing.ClassVar[Region.Op]  # value = <Op.kUnion_Op: 2>
        kXOR_Op: typing.ClassVar[Region.Op]  # value = <Op.kXOR_Op: 3>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Spanerator:
        """

        Returns the line segment ends within :py:class:`Region` that intersect a
        horizontal line.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self, region: Region, y: int, left: int, right: int) -> None:
            """
            Sets :py:class:`Region.Spanerator` to return line segments in
            :py:class:`Region` on scan line.

            :param skia.Region region: :py:class:`Region` to iterate
            :param int y: horizontal line to intersect
            :param int left:  bounds of iteration
            :param int right: bounds of iteration
            :return: :py:class:`Region` iterator
            """
        def __iter__(self) -> Region.Spanerator: ...
        def __next__(self) -> tuple: ...
        def next(self, left: int, right: int) -> bool:
            """
            Advances iterator to next span intersecting :py:class:`Region` within
            line segment provided in constructor.

            Returns true if interval was found.

            :param int left: pointer to span start; may be nullptr
            :param int right: pointer to span end; may be nullptr
            :return: true if interval was found
            """

    __hash__: typing.ClassVar[None] = None
    kDifference_Op: typing.ClassVar[Region.Op]  # value = <Op.kDifference_Op: 0>
    kIntersect_Op: typing.ClassVar[Region.Op]  # value = <Op.kIntersect_Op: 1>
    kLastOp: typing.ClassVar[Region.Op]  # value = <Op.kReplace_Op: 5>
    kOpCnt: typing.ClassVar[int] = 6
    kReplace_Op: typing.ClassVar[Region.Op]  # value = <Op.kReplace_Op: 5>
    kReverseDifference_Op: typing.ClassVar[
        Region.Op
    ]  # value = <Op.kReverseDifference_Op: 4>
    kUnion_Op: typing.ClassVar[Region.Op]  # value = <Op.kUnion_Op: 2>
    kXOR_Op: typing.ClassVar[Region.Op]  # value = <Op.kXOR_Op: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __and__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __and__(self, arg0: IRect) -> Region: ...
    def __eq__(self, other: Region) -> bool:
        """
        Compares :py:class:`Region` and other; returns true if they enclose
        exactly the same area.

        :param skia.Region other: :py:class:`Region` to compare
        :return: true if :py:class:`Region` pair are equivalent
        """
    @typing.overload
    def __iand__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __iand__(self, arg0: IRect) -> Region: ...
    @typing.overload
    def __init__(self) -> None:
        """
        Constructs an empty :py:class:`Region`.

        :py:class:`Region` is set to empty bounds at (0, 0) with zero width and
        height.
        """
    @typing.overload
    def __init__(self, region: Region) -> None:
        """
        Constructs a copy of an existing region.

        Copy constructor makes two regions identical by value. Internally,
        region and the returned result share pointer values. The underlying
        :py:class:`Rect` array is copied when modified.

        Creating a :py:class:`Region` copy is very efficient and never allocates
        memory. :py:class:`Region` are always copied by value from the
        interface; the underlying shared pointers are not exposed.

        :region: :py:class:`Region` to copy by value
        """
    @typing.overload
    def __init__(self, rect: IRect) -> None:
        """
        Constructs a rectangular :py:class:`Region` matching the bounds of rect.

        :rect: bounds of constructed :py:class:`Region`
        """
    @typing.overload
    def __ior__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __ior__(self, arg0: IRect) -> Region: ...
    @typing.overload
    def __isub__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __isub__(self, arg0: IRect) -> Region: ...
    def __iter__(self) -> Region.Iterator: ...
    @typing.overload
    def __ixor__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __ixor__(self, arg0: IRect) -> Region: ...
    def __ne__(self, other: Region) -> bool:
        """
        Compares :py:class:`Region` and other; returns true if they do not
        enclose the same area..

        :param skia.Region other: :py:class:`Region` to compare
        :return: true if :py:class:`Region` pair are not equivalent
        """
    @typing.overload
    def __or__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __or__(self, arg0: IRect) -> Region: ...
    @typing.overload
    def __sub__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __sub__(self, arg0: IRect) -> Region: ...
    @typing.overload
    def __xor__(self, arg0: Region) -> Region: ...
    @typing.overload
    def __xor__(self, arg0: IRect) -> Region: ...
    def cliperator(self, clip: IRect) -> Region.Cliperator:
        """
        Creates :py:class:`~Region.Cliperator` to return elements of
        :py:class:`IRect` array in :py:class:`Region` within clip.

        Example::

            for rect in region.cliperator(skia.IRect(100, 100)):
                pass

        :param skia.IRect clip: bounds of iteration
        """
    def computeRegionComplexity(self) -> int:
        """
        Returns a value that increases with the number of elements in
        :py:class:`Region`.

        Returns zero if :py:class:`Region` is empty. Returns one if
        :py:class:`Region` equals :py:class:`IRect`; otherwise, returns value
        greater than one indicating that :py:class:`Region` is complex.

        Call to compare :py:class:`Region` for relative complexity.

        :return: relative complexity
        """
    @typing.overload
    def contains(self, x: int, y: int) -> bool:
        """
        Returns true if :py:class:`IPoint` (x, y) is inside :py:class:`Region`.

        Returns false if :py:class:`Region` is empty.

        :x: test :py:class:`IPoint` x-coordinate
        :y: test :py:class:`IPoint` y-coordinate
        :return: true if (x, y) is inside :py:class:`Region`
        """
    @typing.overload
    def contains(self, other: IRect) -> bool:
        """
        Returns true if other is completely inside :py:class:`Region`.

        Returns false if :py:class:`Region` or other is empty.

        :other: :py:class:`IRect` to contain
        :return: true if other is inside :py:class:`Region`
        """
    @typing.overload
    def contains(self, other: Region) -> bool:
        """
        Returns true if other is completely inside :py:class:`Region`.

        Returns false if :py:class:`Region` or other is empty.

        :other: :py:class:`Region` to contain
        :return: true if other is inside :py:class:`Region`
        """
    def getBoundaryPath(self, path: Path) -> bool:
        """
        Appends outline of :py:class:`Region` to path.

        Returns true if :py:class:`Region` is not empty; otherwise, returns
        false, and leaves path unmodified.

        :param skia.Path path: :py:class:`Path` to append to
        :return: true if path changed
        """
    def getBounds(self) -> IRect:
        """
        Returns minimum and maximum axes values of :py:class:`IRect` array.

        Returns (0, 0, 0, 0) if :py:class:`Region` is empty.

        :return: combined bounds of all :py:class:`IRect` elements
        """
    @typing.overload
    def intersects(self, rect: IRect) -> bool:
        """
        Returns true if :py:class:`Region` intersects rect.

        Returns false if either rect or :py:class:`Region` is empty, or do not
        intersect.

        :rect: :py:class:`IRect` to intersect
        :return: true if rect and :py:class:`Region` have area in common
        """
    @typing.overload
    def intersects(self, other: Region) -> bool:
        """
        Returns true if :py:class:`Region` intersects other.

        Returns false if either other or :py:class:`Region` is empty, or do not
        intersect.

        :other: :py:class:`Region` to intersect
        :return: true if other and :py:class:`Region` have area in common
        """
    def isComplex(self) -> bool:
        """
        Returns true if :py:class:`Region` is described by more than one
        rectangle.

        :return: true if :py:class:`Region` contains more than one
            :py:class:`IRect`
        """
    def isEmpty(self) -> bool:
        """
        Returns true if :py:class:`Region` is empty.

        Empty :py:class:`Region` has bounds width or height less than or equal
        to zero. :py:meth:`__init__` constructs empty :py:class:`Region`;
        :py:meth:`setEmpty` and :py:meth:`setRect` with dimensionless data make
        :py:class:`Region` empty.

        :return: true if bounds has no width or height
        """
    def isRect(self) -> bool:
        """
        Returns true if :py:class:`Region` is one :py:class:`IRect` with
        positive dimensions.

        :return: true if :py:class:`Region` contains one :py:class:`IRect`
        """
    def iterator(self) -> Region.Iterator:
        """
        Creates :py:class:`~Region.Iterator` to return elements of
        :py:class:`IRect` array in region.

        Example::

            for rect in region.iterator():
                pass
        """
    @typing.overload
    def op(self, rect: IRect, op: Region.Op) -> bool:
        """
        Replaces :py:class:`Region` with the result of :py:class:`Region` op
        rect.

        Returns true if replaced :py:class:`Region` is not empty.

        :rect: :py:class:`IRect` operand
        :return: false if result is empty
        """
    @typing.overload
    def op(self, region: Region, op: Region.Op) -> bool:
        """
        Replaces :py:class:`Region` with the result of :py:class:`Region` op
        region.

        Returns true if replaced :py:class:`Region` is not empty.

        :region: :py:class:`Region` operand
        :return: false if result is empty
        """
    @typing.overload
    def op(self, rect: IRect, region: Region, op: Region.Op) -> bool:
        """
        Replaces :py:class:`Region` with the result of rect op region.

        Returns true if replaced :py:class:`Region` is not empty.

        :rect: :py:class:`IRect` operand
        :region: :py:class:`Region` operand
        :return: false if result is empty
        """
    @typing.overload
    def op(self, region: Region, rect: IRect, op: Region.Op) -> bool:
        """
        Replaces :py:class:`Region` with the result of region op rect.

        Returns true if replaced :py:class:`Region` is not empty.

        :region: :py:class:`Region` operand
        :rect: :py:class:`IRect` operand
        :return: false if result is empty
        """
    @typing.overload
    def op(self, regionA: Region, regionB: Region, op: Region.Op) -> bool:
        """
        Replaces :py:class:`Region` with the result of regionA op regionB.

        Returns true if replaced :py:class:`Region` is not empty.

        :regionA: :py:class:`Region` operand
        :regionB: :py:class:`Region` operand
        :return: false if result is empty
        """
    def quickContains(self, r: IRect) -> bool:
        """
        Returns true if :py:class:`Region` is a single rectangle and contains r.

        May return false even though :py:class:`Region` contains r.

        :param skia.IRect r: :py:class:`IRect` to contain
        :return: true quickly if r points are equal or inside
        """
    @typing.overload
    def quickReject(self, rect: IRect) -> bool:
        """
        Returns true if :py:class:`Region` does not intersect rect.

        Returns true if rect is empty or :py:class:`Region` is empty. May return
        false even though :py:class:`Region` does not intersect rect.

        :rect: :py:class:`IRect` to intersect
        :return: true if rect does not intersect
        """
    @typing.overload
    def quickReject(self, region: Region) -> bool:
        """
        Returns true if :py:class:`Region` does not intersect rgn.

        Returns true if rgn is empty or :py:class:`Region` is empty. May return
        false even though :py:class:`Region` does not intersect rgn.

        :rgn: :py:class:`Region` to intersect
        :return: true if rgn does not intersect
        """
    def readFromMemory(self, data: Data) -> int:
        """
        Constructs :py:class:`Region` from buffer of size length.

        Returns bytes read. Returned value will be multiple of four or zero if
        length was too small.

        :param skia.Data data: binary data
        :return: bytes read
        """
    def set(self, src: Region) -> bool:
        """
        Sets :py:class:`Region` to src, and returns true if src bounds is not
        empty.

        This makes :py:class:`Region` and src identical by value. Internally,
        :py:class:`Region` and src share pointer values. The underlying
        :py:class:`Rect` array is copied when modified.

        Creating a :py:class:`Region` copy is very efficient and never allocates
        memory. :py:class:`Region` are always copied by value from the
        interface; the underlying shared pointers are not exposed.

        :param skia.Region src: :py:class:`Region` to copy
        :return: copy of src
        """
    def setEmpty(self) -> bool:
        """
        Constructs an empty :py:class:`Region`.

        :py:class:`Region` is set to empty bounds at (0, 0) with zero width and
        height. Always returns false.

        :return: false
        """
    def setPath(self, path: Path, clip: Region) -> bool:
        """
        Constructs :py:class:`Region` to match outline of path within clip.

        Returns false if constructed :py:class:`Region` is empty.

        Constructed :py:class:`Region` draws the same pixels as path through
        clip when anti-aliasing is disabled.

        :param skia.Path path: :py:class:`Path` providing outline
        :param skia.Region clip: :py:class:`Region` containing path
        :return: true if constructed :py:class:`Region` is not empty
        """
    def setRect(self, rect: IRect) -> bool:
        """
        Constructs a rectangular :py:class:`Region` matching the bounds of rect.

        If rect is empty, constructs empty and returns false.

        :param skia.Rect rect: bounds of constructed :py:class:`Region`
        :return: true if rect is not empty
        """
    def setRects(self, rects: list[IRect]) -> bool:
        """
        Constructs :py:class:`Region` as the union of :py:class:`IRect` in rects
        array.

        If count is zero, constructs empty :py:class:`Region`. Returns false if
        constructed :py:class:`Region` is empty.

        May be faster than repeated calls to :py:meth:`op`.

        :param List[skia.IRect] rects: array of :py:class:`IRect`
        :return: true if constructed :py:class:`Region` is not empty
        """
    def setRegion(self, region: Region) -> bool:
        """
        Constructs a copy of an existing region.

        Makes two regions identical by value. Internally, region and the
        returned result share pointer values. The underlying :py:class:`Rect`
        array is copied when modified.

        Creating a :py:class:`Region` copy is very efficient and never allocates
        memory. :py:class:`Region` are always copied by value from the
        interface; the underlying shared pointers are not exposed.

        :param skia.Region region: :py:class:`Region` to copy by value
        :return: :py:class:`Region` to copy by value
        """
    def spanerator(self, y: int, left: int, right: int) -> Region.Spanerator:
        """
        Creates :py:class:`Region.Spanerator` to return line segments in
        :py:class:`Region` on scan line.

        Example::

            for left, right in region.spanerator(5, 0, 100):
                pass

        :param int y: horizontal line to intersect
        :param int left:  bounds of iteration
        :param int right: bounds of iteration
        """
    def swap(self, other: Region) -> None:
        """
        Exchanges :py:class:`IRect` array of :py:class:`Region` and other.

        swap() internally exchanges pointers, so it is lightweight and does not
        allocate memory.

        :py:class:`Path` do not copy their content on assignment until they are
        written to, making assignment as efficient as swap().

        :param skia.Region other: other region to swap
        """
    def translate(self, dx: int, dy: int) -> Region:
        """
        Offsets :py:class:`Region` by ivector (dx, dy).

        Has no effect if :py:class:`Region` is empty. If :py:class:`Region` is
        empty, returns empty region.

        :dx: x-axis offset
        :dy: y-axis offset
        """
    def writeToMemory(self) -> Data:
        """
        Writes :py:class:`Region` to :py:class:`Data`.

        :return: :py:class:`Data`
        """

class RuntimeEffect(RefCnt):
    @staticmethod
    @typing.overload
    def MakeForBlender(sksl: String, options: ...) -> RuntimeEffect: ...
    @staticmethod
    @typing.overload
    def MakeForBlender(sksl: String) -> RuntimeEffect: ...
    @staticmethod
    @typing.overload
    def MakeForColorFilter(sksl: String, options: ...) -> RuntimeEffect: ...
    @staticmethod
    @typing.overload
    def MakeForColorFilter(sksl: String) -> RuntimeEffect: ...
    @staticmethod
    @typing.overload
    def MakeForShader(sksl: String, options: ...) -> RuntimeEffect: ...
    @staticmethod
    @typing.overload
    def MakeForShader(sksl: String) -> RuntimeEffect: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def makeBlender(self, uniforms: Data) -> Blender: ...
    @typing.overload
    def makeBlender(
        self,
        uniforms: Data,
        children: SpanRuntimeEffectChildPtr = ...,
    ) -> Blender: ...
    @typing.overload
    def makeColorFilter(self, uniforms: Data) -> ColorFilter: ...
    @typing.overload
    def makeColorFilter(
        self,
        uniforms: Data,
        children: ColorFilter,
        childCount: int,
    ) -> ColorFilter: ...
    @typing.overload
    def makeColorFilter(
        self,
        uniforms: Data,
        children: SpanRuntimeEffectChildPtr,
    ) -> ColorFilter: ...
    @typing.overload
    def makeShader(self, uniforms: Data) -> Shader: ...
    @typing.overload
    def makeShader(
        self,
        uniforms: Data,
        children: Shader,
        childCount: int,
        localMatrix: Matrix | None = None,
    ) -> Shader: ...
    @typing.overload
    def makeShader(
        self,
        uniforms: Data,
        children: SpanRuntimeEffectChildPtr,
        localMatrix: Matrix | None = None,
    ) -> Shader: ...

class RuntimeEffectBuilder:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self, arg0: RuntimeEffect) -> None: ...
    @typing.overload
    def __init__(self, arg0: RuntimeEffect, arg1: Data) -> None: ...
    def child(self, name: str) -> RuntimeEffectBuilderChild: ...
    def children(self) -> SpanRuntimeEffectChildPtr: ...
    def makeBlender(self) -> Blender: ...
    def makeColorFilter(self) -> ColorFilter: ...
    def makeShader(self, localMatrix: Matrix | None = None) -> Shader: ...
    @typing.overload
    def setChild(self, name: str, child: Shader) -> None: ...
    @typing.overload
    def setChild(self, name: str, child: ColorFilter) -> None: ...
    @typing.overload
    def setChild(self, name: str, child: Blender) -> None: ...
    @typing.overload
    def setUniform(self, name: str, uniform: int) -> None: ...
    @typing.overload
    def setUniform(self, name: str, uniform: V3) -> None: ...
    @typing.overload
    def setUniform(self, name: str, uniform: V4) -> None: ...
    @typing.overload
    def setUniform(self, name: str, uniform: list) -> None: ...
    def uniform(self, name: str) -> RuntimeEffectBuilderUniform: ...
    def uniforms(self) -> Data: ...

class RuntimeEffectBuilderChild:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class RuntimeEffectBuilderUniform:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class RuntimeEffectChildPtr:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: Shader) -> None: ...
    @typing.overload
    def __init__(self, arg0: ColorFilter) -> None: ...
    @typing.overload
    def __init__(self, arg0: Blender) -> None: ...

class RuntimeEffectResult:
    effect: RuntimeEffect
    errorText: String
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class SVGCanvas:
    kConvertTextToPaths_Flag: typing.ClassVar[int] = 1
    kNoPrettyXML_Flag: typing.ClassVar[int] = 2
    @staticmethod
    def Make(bounds: Rect, stream: WStream, flags: int = 0) -> Canvas:
        """
        Returns a new canvas that will generate SVG commands from its draw
        calls, and send them to the provided stream. Ownership of the stream is
        not transfered, and it must remain valid for the lifetime of the
        returned canvas::

            stream = skia.FILEWStream("output.svg")
            canvas = skia.SVGCanvas.Make((640, 480), stream)
            draw(canvas)
            # Make sure to delete the canvas before the stream goes out of scope
            del canvas
            stream.flush()

        The canvas may buffer some drawing calls, so the output is not
        guaranteed to be valid or complete until the canvas instance is deleted.

        The 'bounds' parameter defines an initial SVG viewport (viewBox
        attribute on the root SVG element).
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class SVGDOM(RefCnt):
    @staticmethod
    def MakeFromStream(stream: Stream) -> SVGDOM: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def containerSize(self) -> Size: ...
    def render(self, arg0: Canvas) -> None: ...
    def renderNode(self, arg0: Canvas, arg1: str) -> None: ...
    def setContainerSize(self, arg0: Size) -> None: ...

class SamplingOptions:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Aniso(maxAniso: int) -> SamplingOptions: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: SamplingOptions) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, SamplingOptions: SamplingOptions) -> None: ...
    @typing.overload
    def __init__(self, CubicResampler: CubicResampler) -> None: ...
    @typing.overload
    def __init__(self, FilterMode: FilterMode) -> None: ...
    @typing.overload
    def __init__(self, FilterMode: FilterMode, MipmapMode: MipmapMode) -> None: ...
    def __ne__(self, arg0: SamplingOptions) -> bool: ...
    def isAniso(self) -> bool: ...
    @property
    def cubic(self) -> CubicResampler: ...
    @property
    def filter(self) -> FilterMode: ...
    @property
    def maxAniso(self) -> int: ...
    @property
    def mipmap(self) -> MipmapMode: ...
    @property
    def useCubic(self) -> bool: ...

class Shader(Flattanable):
    """

    Shaders specify the source color(s) for what is being drawn.

    If a paint has no shader, then the paint's color is used. If the paint has a
    shader, then the shader's color(s) are use instead, but they are modulated
    by the paint's alpha. This makes it easy to create a shader once (e.g.
    bitmap tiling or gradient) and then change its transparency w/o having to
    modify the original shader... only the paint's alpha needs to be modified.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~skia.Shaders
        ~skia.GradientShader
        ~skia.PerlinNoiseShader

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def isAImage(self, localMatrix: Matrix, xy: list[TileMode] | None = None) -> Image:
        """
        Iff this shader is backed by a single :py:class:`Image`, return its ptr
        (the caller must ref this if they want to keep it longer than the
        lifetime of the shader).

        If not, return nullptr.
        """
    @typing.overload
    def isAImage(self) -> bool: ...
    def isOpaque(self) -> bool:
        """
        Returns true if the shader is guaranteed to produce only opaque colors,
        subject to the :py:class:`Paint` using the shader to apply an opaque
        alpha value.

        Subclasses should override this to allow some optimizations.
        """
    def makeWithColorFilter(self, colorFilter: ColorFilter) -> Shader:
        """
        Create a new shader that produces the same colors as invoking this
        shader and then applying the colorfilter.
        """
    def makeWithLocalMatrix(self, matrix: Matrix) -> Shader:
        """
        Return a shader that will apply the specified localMatrix to this
        shader.

        The specified matrix will be applied before any matrix associated with
        this shader.
        """

class ShaderMaskFilter:
    @staticmethod
    def Make(shader: Shader) -> MaskFilter: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Shaders:
    @staticmethod
    @typing.overload
    def Blend(mode: BlendMode, dst: Shader, src: Shader) -> Shader: ...
    @staticmethod
    @typing.overload
    def Blend(blender: Blender, dst: Shader, src: Shader) -> Shader: ...
    @staticmethod
    @typing.overload
    def Color(color: int) -> Shader: ...
    @staticmethod
    @typing.overload
    def Color(color: Color4f, cs: ColorSpace | None = None) -> Shader: ...
    @staticmethod
    def Empty() -> Shader: ...
    @staticmethod
    def Lerp(t: float, dst: Shader, src: Shader) -> Shader: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Size:
    __hash__: typing.ClassVar[None] = None
    fHeight: float
    fWidth: float
    @staticmethod
    @typing.overload
    def Make(width: float, height: float) -> Size: ...
    @staticmethod
    @typing.overload
    def Make(isize: ISize) -> Size: ...
    @staticmethod
    def MakeEmpty() -> Size: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: Size) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, width: float, height: float) -> None: ...
    @typing.overload
    def __init__(self, isize: ISize) -> None: ...
    @typing.overload
    def __init__(self, t: tuple) -> None: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __ne__(self, other: Size) -> bool: ...
    def equals(self, width: float, height: float) -> bool: ...
    def height(self) -> float: ...
    def isEmpty(self) -> bool:
        """
        Returns true if either width or height are <= 0.
        """
    def isZero(self) -> bool:
        """
        Returns true iff fWidth == 0 && fHeight == 0.
        """
    def set(self, width: float, height: float) -> None: ...
    def setEmpty(self) -> None:
        """
        Set the width and height to 0.
        """
    def toCeil(self) -> ISize: ...
    def toFloor(self) -> ISize: ...
    def toRound(self) -> ISize: ...
    def width(self) -> float: ...

class SpanRuntimeEffectChildPtr:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: RuntimeEffectChildPtr, arg1: int) -> None: ...
    @typing.overload
    def __init__(self, arg0: SpanRuntimeEffectChildPtr) -> None: ...
    @typing.overload
    def __init__(self, arg0: VectorRuntimeEffectChildPtr) -> None: ...
    @typing.overload
    def __init__(self, arg0: ...) -> None: ...

class Stream:
    """

    :py:class:`Stream`  abstraction for a source of bytes.

    Subclasses can be backed by memory, or a file, or something else.

    NOTE:

    Classic "streams" APIs are sort of async, in that on a request for N bytes,
    they may return fewer than N bytes on a given call, in which case the caller
    can "try again" to get more bytes, eventually (modulo an error) receiving
    their total N bytes.

    Skia streams behave differently. They are effectively synchronous, and will
    always return all N bytes of the request if possible. If they return fewer
    (the read() call returns the number of bytes read) then that means there is
    no more data (at EOF or hit an error). The caller should not call again in
    hopes of fulfilling more of the request.

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~FILEStream
        ~MemoryStream

    """
    @staticmethod
    def MakeFromFile(path: str) -> StreamAsset:
        """
        Attempts to open the specified file as a stream, returns nullptr on
        failure.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def duplicate(self) -> Stream:
        """
        Duplicates this stream.

        If this cannot be done, returns NULL. The returned stream will be
        positioned at the beginning of its data.
        """
    def fork(self) -> Stream:
        """
        Duplicates this stream.

        If this cannot be done, returns NULL. The returned stream will be
        positioned the same as this stream.
        """
    def getLength(self) -> int:
        """
        Returns the total length of the stream.

        If this cannot be done, returns 0.

        Reimplemented in :py:class:`MemoryStream`, :py:class:`FILEStream`, and
        :py:class:`StreamAsset`.
        """
    def getMemoryBase(self) -> capsule:
        """
        Returns the starting address for the data.

        If this cannot be done, returns NULL.

        Reimplemented in :py:class:`MemoryStream`, and :py:class:`StreamMemory`.
        """
    def getPosition(self) -> int:
        """
        Returns the current position in the stream.

        If this cannot be done, returns 0.

        Reimplemented in :py:class:`MemoryStream`, :py:class:`FILEStream`, and
        :py:class:`StreamSeekable`.
        """
    def hasLength(self) -> bool:
        """
        Returns true if this stream can report it's total length.

        Reimplemented in :py:class:`StreamAsset`.
        """
    def hasPosition(self) -> bool:
        """
        Returns true if this stream can report it's current position.

        Reimplemented in :py:class:`StreamSeekable`.
        """
    def isAtEnd(self) -> bool:
        """
        Returns true when all the bytes in the stream have been read.

        This may return true early (when there are no more bytes to be read) or
        late (after the first unsuccessful read).

        Implemented in :py:class:`MemoryStream`, and :py:class:`FILEStream`.
        """
    def move(self, offset: int) -> bool:
        """
        Seeks to an relative offset in the stream.

        If this cannot be done, returns false. If an attempt is made to move to
        a position outside the stream, the position will be set to the closest
        point within the stream (beginning or end).

        Reimplemented in :py:class:`MemoryStream`, :py:class:`FILEStream`, and
        :py:class:`StreamSeekable`.
        """
    def peek(self, buffer: typing_extensions.Buffer) -> int:
        """
        Attempt to peek at size bytes.

        If this stream supports peeking, copy min(size, peekable bytes) into
        buffer, and return the number of bytes copied. If the stream does not
        support peeking, or cannot peek any bytes, return 0 and leave buffer
        unchanged. The stream is guaranteed to be in the same visible state
        after this call, regardless of success or failure.

        :param buffer:  Must not be NULL, and must be at least size bytes.
            Destination to copy bytes.
        :param size:  Number of bytes to copy.
        :return: The number of bytes peeked/copied.

        Reimplemented in :py:class:`MemoryStream`.
        """
    def read(self, buffer: typing_extensions.Buffer, size: int = 0) -> int:
        """
        Reads or skips size number of bytes.

        If buffer == NULL, skip size bytes, return how many were skipped. If
        buffer != NULL, copy size bytes into buffer, return how many were
        copied.

        :param buffer:  when NULL skip size bytes, otherwise copy size bytes
            into buffer
        :param size:    the number of bytes to skip or copy; may be nullptr
        :return: the number of bytes actually read.

        Implemented in :py:class:`MemoryStream`, and :py:class:`FILEStream`.
        """
    def readBool(self) -> bool: ...
    def readPackedUInt(self) -> int: ...
    def readS16(self) -> int: ...
    def readS32(self) -> int: ...
    def readS8(self) -> int: ...
    def readScalar(self) -> float: ...
    def readU16(self) -> int: ...
    def readU32(self) -> int: ...
    def readU8(self) -> int: ...
    def rewind(self) -> bool:
        """
        Rewinds to the beginning of the stream.

        Returns true if the stream is known to be at the beginning after this
        call returns.

        Reimplemented in :py:class:`MemoryStream`, :py:class:`FILEStream`, and
        :py:class:`StreamRewindable`.
        """
    def seek(self, position: int) -> bool:
        """
        Seeks to an absolute position in the stream.

        If this cannot be done, returns false. If an attempt is made to seek
        past the end of the stream, the position will be set to the end of the
        stream.

        Reimplemented in :py:class:`MemoryStream`, :py:class:`FILEStream`, and
        :py:class:`StreamSeekable`.
        """
    def skip(self, size: int) -> int:
        """
        Skip size number of bytes.

        :return: the actual number bytes that could be skipped.
        """

class StreamAsset(StreamSeekable):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def duplicate(self) -> StreamSeekable: ...
    def fork(self) -> StreamSeekable: ...

class StreamMemory(StreamAsset):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def duplicate(self) -> StreamSeekable: ...
    def fork(self) -> StreamSeekable: ...

class StreamRewindable(Stream):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def duplicate(self) -> StreamRewindable: ...

class StreamSeekable(StreamRewindable):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def fork(self) -> StreamSeekable: ...

class String:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __contains__(self, subStr: str) -> bool: ...
    def __eq__(self, text: String) -> bool: ...
    def __getitem__(self, arg0: int) -> str: ...
    @typing.overload
    def __iadd__(self, other: String) -> String: ...
    @typing.overload
    def __iadd__(self, other: str) -> String: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, size: int) -> None: ...
    @typing.overload
    def __init__(self, text: str) -> None: ...
    @typing.overload
    def __init__(self, text: str, size: int) -> None: ...
    @typing.overload
    def __init__(self, other: String) -> None: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: str) -> String: ...
    @typing.overload
    def append(self, str: String) -> None: ...
    @typing.overload
    def append(self, text: str) -> None: ...
    @typing.overload
    def append(self, text: str, size: int) -> None: ...
    def appendHex(self, value: int, minDigits: int = 0) -> None: ...
    def appendS32(self, value: int) -> None: ...
    def appendS64(self, value: int, minDigits: int = 0) -> None: ...
    def appendScalar(self, value: float) -> None: ...
    def appendU32(self, value: int) -> None: ...
    def appendU64(self, value: int, minDigits: int = 0) -> None: ...
    def appendUnichar(self, value: int) -> None: ...
    def c_str(self) -> str: ...
    @typing.overload
    def contains(self, subStr: str) -> bool: ...
    @typing.overload
    def contains(self, subChar: str) -> bool: ...
    @typing.overload
    def endsWith(self, suffixStr: str) -> bool: ...
    @typing.overload
    def endsWith(self, suffixChar: str) -> bool: ...
    @typing.overload
    def equals(self, text: String) -> bool: ...
    @typing.overload
    def equals(self, text: str) -> bool: ...
    @typing.overload
    def equals(self, text: str, size: int) -> bool: ...
    def find(self, substring: str) -> int: ...
    def findLastOf(self, subchar: str) -> int: ...
    @typing.overload
    def insert(self, offset: int, src: String) -> None: ...
    @typing.overload
    def insert(self, offset: int, text: str) -> None: ...
    @typing.overload
    def insert(self, offset: int, text: str, size: int) -> None: ...
    def insertHex(self, offset: int, value: int, minDigits: int = 0) -> None: ...
    def insertS32(self, offset: int, value: int) -> None: ...
    def insertS64(self, offset: int, value: int, minDigits: int = 0) -> None: ...
    def insertScalar(self, offset: int, value: float) -> None: ...
    def insertU32(self, offset: int, value: int) -> None: ...
    def insertU64(self, offset: int, value: int, minDigits: int = 0) -> None: ...
    def insertUnichar(self, offset: int, value: int) -> None: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def prepend(self, str: String) -> None: ...
    @typing.overload
    def prepend(self, text: str) -> None: ...
    @typing.overload
    def prepend(self, text: str, size: int) -> None: ...
    def prependHex(self, value: int, minDigits: int = 0) -> None: ...
    def prependS32(self, value: int) -> None: ...
    def prependS64(self, value: int, minDigits: int = 0) -> None: ...
    def prependScalar(self, value: float) -> None: ...
    def prependUnichar(self, value: int) -> None: ...
    def remove(self, offset: int, size: int) -> None: ...
    def reset(self) -> None: ...
    def resize(self, size: int) -> None: ...
    @typing.overload
    def set(self, src: String) -> None: ...
    @typing.overload
    def set(self, text: str) -> None: ...
    @typing.overload
    def set(self, text: str, size: int) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def startsWith(self, prefixStr: str) -> bool: ...
    @typing.overload
    def startsWith(self, prefixChar: str) -> bool: ...
    def swap(self, other: String) -> None:
        """
        Swap contents between this and other.

        This function is guaranteed to never fail or throw.
        """

class StrokeRec:
    class InitStyle:
        """
        Members:

          kHairline_InitStyle

          kFill_InitStyle
        """

        __members__: typing.ClassVar[
            dict[str, StrokeRec.InitStyle]
        ]  # value = {'kHairline_InitStyle': <InitStyle.kHairline_InitStyle: 0>, 'kFill_InitStyle': <InitStyle.kFill_InitStyle: 1>}
        kFill_InitStyle: typing.ClassVar[
            StrokeRec.InitStyle
        ]  # value = <InitStyle.kFill_InitStyle: 1>
        kHairline_InitStyle: typing.ClassVar[
            StrokeRec.InitStyle
        ]  # value = <InitStyle.kHairline_InitStyle: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Style:
        """
        Members:

          kHairline_Style

          kFill_Style

          kStroke_Style

          kStrokeAndFill_Style
        """

        __members__: typing.ClassVar[
            dict[str, StrokeRec.Style]
        ]  # value = {'kHairline_Style': <Style.kHairline_Style: 0>, 'kFill_Style': <Style.kFill_Style: 1>, 'kStroke_Style': <Style.kStroke_Style: 2>, 'kStrokeAndFill_Style': <Style.kStrokeAndFill_Style: 3>}
        kFill_Style: typing.ClassVar[StrokeRec.Style]  # value = <Style.kFill_Style: 1>
        kHairline_Style: typing.ClassVar[
            StrokeRec.Style
        ]  # value = <Style.kHairline_Style: 0>
        kStrokeAndFill_Style: typing.ClassVar[
            StrokeRec.Style
        ]  # value = <Style.kStrokeAndFill_Style: 3>
        kStroke_Style: typing.ClassVar[
            StrokeRec.Style
        ]  # value = <Style.kStroke_Style: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kFill_InitStyle: typing.ClassVar[
        StrokeRec.InitStyle
    ]  # value = <InitStyle.kFill_InitStyle: 1>
    kFill_Style: typing.ClassVar[StrokeRec.Style]  # value = <Style.kFill_Style: 1>
    kHairline_InitStyle: typing.ClassVar[
        StrokeRec.InitStyle
    ]  # value = <InitStyle.kHairline_InitStyle: 0>
    kHairline_Style: typing.ClassVar[
        StrokeRec.Style
    ]  # value = <Style.kHairline_Style: 0>
    kStrokeAndFill_Style: typing.ClassVar[
        StrokeRec.Style
    ]  # value = <Style.kStrokeAndFill_Style: 3>
    kStroke_Style: typing.ClassVar[StrokeRec.Style]  # value = <Style.kStroke_Style: 2>
    kStyleCount: typing.ClassVar[int] = 4
    @staticmethod
    @typing.overload
    def GetInflationRadius(paint: Paint, style: Paint.Style) -> float:
        """
        Equivalent to: :py:class:`StrokeRec` rec(paint, style);
        rec.getInflationRadius(); This does not account for other effects on the
        paint (i.e. path effect).
        """
    @staticmethod
    @typing.overload
    def GetInflationRadius(
        join: Paint.Join,
        miterLimit: float,
        cap: Paint.Cap,
        strokeWidth: float,
    ) -> float: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self, style: StrokeRec.InitStyle) -> None: ...
    @typing.overload
    def __init__(
        self,
        paint: Paint,
        style: Paint.Style,
        resScale: float = 1,
    ) -> None: ...
    @typing.overload
    def __init__(self, paint: Paint, resScale: float = 1) -> None: ...
    def applyToPaint(self, paint: Paint) -> None:
        """
        Apply these stroke parameters to a paint.
        """
    def applyToPath(self, dst: Path, src: Path) -> bool:
        """
        Apply these stroke parameters to the src path, returning the result in
        dst.

        If there was no change (i.e. style == hairline or fill) this returns
        false and dst is unchanged. Otherwise returns true and the result is
        stored in dst.

        src and dst may be the same path.
        """
    def getCap(self) -> Paint.Cap: ...
    def getInflationRadius(self) -> float:
        """
        Gives a conservative value for the outset that should applied to a
        geometries bounds to account for any inflation due to applying this
        strokeRec to the geometry.
        """
    def getJoin(self) -> Paint.Join: ...
    def getMiter(self) -> float: ...
    def getResScale(self) -> float: ...
    def getStyle(self) -> StrokeRec.Style: ...
    def getWidth(self) -> float: ...
    def hasEqualEffect(self, other: StrokeRec) -> bool:
        """
        Compare if two SkStrokeRecs have an equal effect on a path.

        Equal SkStrokeRecs produce equal paths. Equality of produced paths does
        not take the ResScale parameter into account.
        """
    def isFillStyle(self) -> bool: ...
    def isHairlineStyle(self) -> bool: ...
    def needToApply(self) -> bool:
        """
        Returns true if this specifes any thick stroking, i.e.

        :py:meth:`applyToPath` will return true.
        """
    def setFillStyle(self) -> None: ...
    def setHairlineStyle(self) -> None: ...
    def setResScale(self, rs: float) -> None: ...
    def setStrokeParams(
        self,
        cap: Paint.Cap,
        join: Paint.Join,
        miterLimit: float,
    ) -> None: ...
    def setStrokeStyle(self, width: float, strokeAndFill: bool = False) -> None:
        """
        Specify the strokewidth, and optionally if you want stroke + fill.

        Note, if width==0, then this request is taken to mean:
        strokeAndFill==true -> new style will be Fill strokeAndFill==false ->
        new style will be Hairline
        """

class Surface(RefCnt):
    """

    :py:class:`Surface` is responsible for managing the pixels that a canvas
    draws into.

    The pixels can be allocated either in CPU memory (a raster surface) or on
    the GPU (a GrRenderTarget surface). :py:class:`Surface` takes care of
    allocating a :py:class:`Canvas` that will draw into the surface. Call
    :py:meth:`getCanvas` to use that canvas (but don't delete it, it is owned
    by the surface). :py:class:`Surface` always has non-zero dimensions. If
    there is a request for a new surface, and either of the requested dimensions
    are zero, then nullptr will be returned.

    Example::

        surface = skia.Surface(640, 480)
        with surface as canvas:
            draw(canvas)
        image = surface.makeImageSnapshot()


    """
    class AsyncReadResult:
        """

        The result from :py:meth:`Surface.asyncRescaleAndReadPixels` or
        :py:meth:`Surface.asyncRescaleAndReadPixelsYUV420`.

        """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def count(self) -> int: ...
        def data(self, i: int) -> capsule: ...
        def rowBytes(self, i: int) -> int: ...

    class BackendHandleAccess:
        """
        Members:

          kFlushRead_BackendHandleAccess : back-end object is readable

          kFlushWrite_BackendHandleAccess : back-end object is writable

          kDiscardWrite_BackendHandleAccess : back-end object must be overwritten
        """

        __members__: typing.ClassVar[
            dict[str, Surface.BackendHandleAccess]
        ]  # value = {'kFlushRead_BackendHandleAccess': <BackendHandleAccess.kFlushRead_BackendHandleAccess: 0>, 'kFlushWrite_BackendHandleAccess': <BackendHandleAccess.kFlushWrite_BackendHandleAccess: 1>, 'kDiscardWrite_BackendHandleAccess': <BackendHandleAccess.kDiscardWrite_BackendHandleAccess: 2>}
        kDiscardWrite_BackendHandleAccess: typing.ClassVar[
            Surface.BackendHandleAccess
        ]  # value = <BackendHandleAccess.kDiscardWrite_BackendHandleAccess: 2>
        kFlushRead_BackendHandleAccess: typing.ClassVar[
            Surface.BackendHandleAccess
        ]  # value = <BackendHandleAccess.kFlushRead_BackendHandleAccess: 0>
        kFlushWrite_BackendHandleAccess: typing.ClassVar[
            Surface.BackendHandleAccess
        ]  # value = <BackendHandleAccess.kFlushWrite_BackendHandleAccess: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class BackendSurfaceAccess:
        """
        Members:

          kNoAccess : back-end object will not be used by client

          kPresent : back-end surface will be used for presenting to screen
        """

        __members__: typing.ClassVar[
            dict[str, Surface.BackendSurfaceAccess]
        ]  # value = {'kNoAccess': <BackendSurfaceAccess.kNoAccess: 0>, 'kPresent': <BackendSurfaceAccess.kPresent: 1>}
        kNoAccess: typing.ClassVar[
            Surface.BackendSurfaceAccess
        ]  # value = <BackendSurfaceAccess.kNoAccess: 0>
        kPresent: typing.ClassVar[
            Surface.BackendSurfaceAccess
        ]  # value = <BackendSurfaceAccess.kPresent: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class ContentChangeMode:
        """
        Members:

          kDiscard_ContentChangeMode : discards surface on change

          kRetain_ContentChangeMode : preserves surface on change
        """

        __members__: typing.ClassVar[
            dict[str, Surface.ContentChangeMode]
        ]  # value = {'kDiscard_ContentChangeMode': <ContentChangeMode.kDiscard_ContentChangeMode: 0>, 'kRetain_ContentChangeMode': <ContentChangeMode.kRetain_ContentChangeMode: 1>}
        kDiscard_ContentChangeMode: typing.ClassVar[
            Surface.ContentChangeMode
        ]  # value = <ContentChangeMode.kDiscard_ContentChangeMode: 0>
        kRetain_ContentChangeMode: typing.ClassVar[
            Surface.ContentChangeMode
        ]  # value = <ContentChangeMode.kRetain_ContentChangeMode: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RescaleGamma:
        """

            Controls the gamma that rescaling occurs in for
            :py:meth:`Surface.asyncRescaleAndReadPixels` and
            :py:meth:`Surface.asyncRescaleAndReadPixelsYUV420`.


        Members:

          kSrc

          kLinear
        """

        __members__: typing.ClassVar[
            dict[str, Surface.RescaleGamma]
        ]  # value = {'kSrc': <RescaleGamma.kSrc: 0>, 'kLinear': <RescaleGamma.kLinear: 1>}
        kLinear: typing.ClassVar[
            Surface.RescaleGamma
        ]  # value = <RescaleGamma.kLinear: 1>
        kSrc: typing.ClassVar[Surface.RescaleGamma]  # value = <RescaleGamma.kSrc: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kDiscardWrite_BackendHandleAccess: typing.ClassVar[
        Surface.BackendHandleAccess
    ]  # value = <BackendHandleAccess.kDiscardWrite_BackendHandleAccess: 2>
    kDiscard_ContentChangeMode: typing.ClassVar[
        Surface.ContentChangeMode
    ]  # value = <ContentChangeMode.kDiscard_ContentChangeMode: 0>
    kFlushRead_BackendHandleAccess: typing.ClassVar[
        Surface.BackendHandleAccess
    ]  # value = <BackendHandleAccess.kFlushRead_BackendHandleAccess: 0>
    kFlushWrite_BackendHandleAccess: typing.ClassVar[
        Surface.BackendHandleAccess
    ]  # value = <BackendHandleAccess.kFlushWrite_BackendHandleAccess: 1>
    kLinear: typing.ClassVar[Surface.RescaleGamma]  # value = <RescaleGamma.kLinear: 1>
    kNoAccess: typing.ClassVar[
        Surface.BackendSurfaceAccess
    ]  # value = <BackendSurfaceAccess.kNoAccess: 0>
    kPresent: typing.ClassVar[
        Surface.BackendSurfaceAccess
    ]  # value = <BackendSurfaceAccess.kPresent: 1>
    kRetain_ContentChangeMode: typing.ClassVar[
        Surface.ContentChangeMode
    ]  # value = <ContentChangeMode.kRetain_ContentChangeMode: 1>
    kSrc: typing.ClassVar[Surface.RescaleGamma]  # value = <RescaleGamma.kSrc: 0>
    @staticmethod
    def MakeFromBackendRenderTarget(
        context: GrRecordingContext,
        backendRenderTarget: GrBackendRenderTarget,
        origin: GrSurfaceOrigin,
        colorType: ColorType,
        colorSpace: ColorSpace,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Wraps a GPU-backed buffer into :py:class:`Surface`.

        Caller must ensure backendRenderTarget is valid for the lifetime of
        returned :py:class:`Surface`.

        :py:class:`Surface` is returned if all parameters are valid.
        backendRenderTarget is valid if its pixel configuration agrees with
        colorSpace and context; for instance, if backendRenderTarget has an sRGB
        configuration, then context must support sRGB, and colorSpace must be
        present. Further, backendRenderTarget width and height must not exceed
        context capabilities, and the context must be able to support back-end
        render targets.

        Upon success releaseProc is called when it is safe to delete the render
        target in the backend API (accounting only for use of the render target
        by this surface). If :py:class:`Surface` creation fails releaseProc is
        called before this function returns.

        If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.

        :param context: GPU context
        :param backendRenderTarget: GPU intermediate memory buffer
        :param colorSpace:  range of colors
        :param surfaceProps:    LCD striping orientation and setting for device
            independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def MakeFromBackendTexture(
        context: GrRecordingContext,
        backendTexture: GrBackendTexture,
        origin: GrSurfaceOrigin,
        sampleCnt: int,
        colorType: ColorType,
        colorSpace: ColorSpace,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Wraps a GPU-backed texture into :py:class:`Surface`. Caller must ensure
        backendRenderTarget is valid for the lifetime of returned
        :py:class:`Surface`. If sampleCnt greater than zero, creates an
        intermediate MSAA :py:class:`Surface` which is used for drawing
        backendTexture.

        :py:class:`Surface` is returned if all parameters are valid.
        backendTexture is valid if its pixel configuration agrees with
        colorSpace and context; for instance, if backendTexture has an sRGB
        configuration, then context must support sRGB, and colorSpace must be
        present. Further, backendTexture width and height must not exceed
        context capabilities, and the context must be able to support back-end
        textures.

        Upon success textureReleaseProc is called when it is safe to delete the
        texture in the backend API (accounting only for use of the texture by
        this surface). If :py:class:`Surface` creation fails textureReleaseProc
        is called before this function returns.

        If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.

        :context: GPU context
        :backendTexture:  texture residing on GPU
        :sampleCnt:  samples per pixel, or 0 to disable full scene anti-aliasing
        :colorSpace:  range of colors; may be nullptr
        :surfaceProps:    LCD striping orientation and setting for device
            independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def MakeNull(width: int, height: int) -> Surface:
        """
        Returns :py:class:`Surface` without backing pixels.

        Drawing to :py:class:`Canvas` returned from :py:class:`Surface` has no
        effect. Calling makeImageSnapshot() on returned :py:class:`Surface`
        returns nullptr.

        :param int width: one or greater
        :param int height: one or greater

        :return: :py:class:`Surface` if width and height are positive;
            otherwise, nullptr
        """
    @staticmethod
    def MakeRaster(
        imageInfo: ImageInfo,
        rowBytes: int = 0,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Allocates raster :py:class:`Surface`.

        :py:class:`Canvas` returned by :py:class:`Surface` draws directly into
        pixels. Allocates and zeroes pixel memory. Pixel memory size is
        imageInfo.height() times rowBytes, or times imageInfo.minRowBytes() if
        rowBytes is zero. Pixel memory is deleted when :py:class:`Surface` is
        deleted.

        :py:class:`Surface` is returned if all parameters are valid. Valid
        parameters include: info dimensions are greater than zero; info contains
        :py:class:`ColorType` and :py:class:`AlphaType` supported by raster
        surface; rowBytes is large enough to contain info width pixels of
        :py:class:`ColorType`, or is zero.

        If rowBytes is zero, a suitable value will be chosen internally.

        :imageInfo: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`, of raster surface;
            width and height must be greater than zero
        :rowBytes: interval from one :py:class:`Surface` row to the
            next; may be zero
        :skia.SurfaceProps surfaceProps: LCD striping orientation and
            setting for device independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def MakeRasterDirect(
        info: ImageInfo,
        pixels: typing_extensions.Buffer,
        rowBytes: int = 0,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Allocates raster :py:class:`Surface`.

        :py:class:`Canvas` returned by :py:class:`Surface` draws directly into
        pixels.

        :py:class:`Surface` is returned if all parameters are valid. Valid
        parameters include: info dimensions are greater than zero; info contains
        :py:class:`ColorType` and :py:class:`AlphaType` supported by raster
        surface; pixels is not nullptr; rowBytes is large enough to contain info
        width pixels of :py:class:`ColorType`.

        Pixel buffer size should be info height times computed rowBytes. Pixels
        are not initialized. To access pixels after drawing, peekPixels() or
        readPixels().

        :param skia.ImageInfo imageInfo: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`, of raster surface;
            width and height must be greater than zero
        :param Union[bytes,bytearray,memoryview] pixels: pointer to destination
            pixels buffer
        :param rowBytes: interval from one :py:class:`Surface` row to the next
        :param surfaceProps: LCD striping orientation and setting for device
            independent fonts; may be nullptr

        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def MakeRasterN32Premul(
        width: int,
        height: int,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Allocates raster :py:class:`Surface`.

        :py:class:`Canvas` returned by :py:class:`Surface` draws directly into
        pixels. Allocates and zeroes pixel memory. Pixel memory size is height
        times width times four. Pixel memory is deleted when :py:class:`Surface`
        is deleted.

        Internally, sets :py:class:`ImageInfo` to width, height, native color
        type, and :py:attr:`AlphaType.kPremul`.

        :py:class:`Surface` is returned if width and height are greater than
        zero.

        Use to create :py:class:`Surface` that matches :py:class:`PMColor`, the
        native pixel arrangement on the platform. :py:class:`Surface` drawn to
        output device skips converting its pixel format.

        :param int width: pixel column count; must be greater than zero
        :param int height: pixel row count; must be greater than zero
        :param skia.SurfaceProps surfaceProps: LCD striping orientation and
            setting for device independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    @typing.overload
    def MakeRenderTarget(
        context: GrRecordingContext,
        budgeted: Budgeted,
        imageInfo: ImageInfo,
        sampleCount: int = 0,
        surfaceOrigin: GrSurfaceOrigin = ...,
        surfaceProps: SurfaceProps | None = None,
        shouldCreateWithMips: bool = False,
        isProtected: bool = False,
    ) -> Surface:
        """
        Returns :py:class:`Surface` on GPU indicated by context.

        Allocates memory for pixels, based on the width, height, and
        :py:class:`ColorType` in :py:class:`ImageInfo`. budgeted selects whether
        allocation for pixels is tracked by context. imageInfo describes the
        pixel format in :py:class:`ColorType`, and transparency in
        :py:class:`AlphaType`, and color matching in :py:class:`ColorSpace`.

        sampleCount requests the number of samples per pixel. Pass zero to
        disable multi-sample anti-aliasing. The request is rounded up to the
        next supported count, or rounded down if it is larger than the maximum
        supported count.

        surfaceOrigin pins either the top-left or the bottom-left corner to the
        origin.

        shouldCreateWithMips hints that :py:class:`Image` returned by
        makeImageSnapshot() is mip map.

        If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.

        :param skia.GrContext context: GPU context
        :param skia.ImageInfo imageInfo: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`; width, or height, or
            both, may be zero
        :param int sampleCount: samples per pixel, or 0 to disable full scene
            anti-aliasing
        :param skia.GrSurfaceOrigin surfaceOrigin: kTopLeft or kBottomLeft
        :param skia.SurfaceProps surfaceProps: LCD striping orientation and
            setting for device independent fonts; may be nullptr
        :param shouldCreateWithMips: hint that :py:class:`Surface` will host mip
            map images
        :param isProtected: protected-ness
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    @typing.overload
    def MakeRenderTarget(
        context: GrRecordingContext,
        budgeted: Budgeted,
        imageInfo: ImageInfo,
        sampleCount: int,
        surfaceProps: SurfaceProps | None = None,
    ) -> Surface:
        """
        Returns :py:class:`Surface` on GPU indicated by context.

        Allocates memory for pixels, based on the width, height, and
        :py:class:`ColorType` in :py:class:`ImageInfo`. budgeted selects whether
        allocation for pixels is tracked by context. imageInfo describes the
        pixel format in :py:class:`ColorType`, and transparency in
        :py:class:`AlphaType`, and color matching in :py:class:`ColorSpace`.

        sampleCount requests the number of samples per pixel. Pass zero to
        disable multi-sample anti-aliasing. The request is rounded up to the
        next supported count, or rounded down if it is larger than the maximum
        supported count.

        :py:class:`Surface` bottom-left corner is pinned to the origin.

        :context: GPU context
        :imageInfo:   width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`; width, or height, or
            both, may be zero
        :sampleCount: samples per pixel, or 0 to disable full scene
            anti-aliasing
        :surfaceProps:    LCD striping orientation and setting for device
            independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    @typing.overload
    def MakeRenderTarget(
        context: GrRecordingContext,
        budgeted: Budgeted,
        imageInfo: ImageInfo,
    ) -> Surface:
        """
        Returns :py:class:`Surface` on GPU indicated by context.

        Allocates memory for pixels, based on the width, height, and
        :py:class:`ColorType` in :py:class:`ImageInfo`. budgeted selects whether
        allocation for pixels is tracked by context. imageInfo describes the
        pixel format in :py:class:`ColorType`, and transparency in
        :py:class:`AlphaType`, and color matching in :py:class:`ColorSpace`.

        :py:class:`Surface` bottom-left corner is pinned to the origin.

        :context: GPU context
        :imageInfo:   width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`; width, or height, or
            both, may be zero
        """
    @staticmethod
    @typing.overload
    def MakeRenderTarget(
        context: GrRecordingContext,
        characterization: SurfaceCharacterization,
        budgeted: Budgeted,
    ) -> Surface:
        """
        Returns :py:class:`Surface` on GPU indicated by context that is
        compatible with the provided characterization.

        budgeted selects whether allocation for pixels is tracked by context.

        :context: GPU context
        :characterization: description of the desired :py:class:`Surface`
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def Raster(*args, **kwargs):
        """
        MakeRaster(imageInfo: skia.ImageInfo, rowBytes: int = 0, surfaceProps: skia.SurfaceProps = None) -> skia.Surface


                Allocates raster :py:class:`Surface`.

                :py:class:`Canvas` returned by :py:class:`Surface` draws directly into
                pixels. Allocates and zeroes pixel memory. Pixel memory size is
                imageInfo.height() times rowBytes, or times imageInfo.minRowBytes() if
                rowBytes is zero. Pixel memory is deleted when :py:class:`Surface` is
                deleted.

                :py:class:`Surface` is returned if all parameters are valid. Valid
                parameters include: info dimensions are greater than zero; info contains
                :py:class:`ColorType` and :py:class:`AlphaType` supported by raster
                surface; rowBytes is large enough to contain info width pixels of
                :py:class:`ColorType`, or is zero.

                If rowBytes is zero, a suitable value will be chosen internally.

                :imageInfo: width, height, :py:class:`ColorType`,
                    :py:class:`AlphaType`, :py:class:`ColorSpace`, of raster surface;
                    width and height must be greater than zero
                :rowBytes: interval from one :py:class:`Surface` row to the
                    next; may be zero
                :skia.SurfaceProps surfaceProps: LCD striping orientation and
                    setting for device independent fonts; may be nullptr
                :return: :py:class:`Surface` if all parameters are valid; otherwise,
                    nullptr

        """
    @staticmethod
    def WrapBackendRenderTarget(
        context: GrRecordingContext,
        backendRenderTarget: GrBackendRenderTarget,
        origin: GrSurfaceOrigin,
        colorType: ColorType,
        colorSpace: ColorSpace,
        surfaceProps: SurfaceProps | None = None,
        releaseProc: ... = None,
        releaseContext: capsule | None = None,
    ) -> Surface:
        """
        Wraps a GPU-backed buffer into :py:class:`Surface`.

        Caller must ensure backendRenderTarget is valid for the lifetime of
        returned :py:class:`Surface`.

        :py:class:`Surface` is returned if all parameters are valid.
        backendRenderTarget is valid if its pixel configuration agrees with
        colorSpace and context; for instance, if backendRenderTarget has an sRGB
        configuration, then context must support sRGB, and colorSpace must be
        present. Further, backendRenderTarget width and height must not exceed
        context capabilities, and the context must be able to support back-end
        render targets.

        Upon success releaseProc is called when it is safe to delete the render
        target in the backend API (accounting only for use of the render target
        by this surface). If :py:class:`Surface` creation fails releaseProc is
        called before this function returns.

        If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.

        :param context: GPU context
        :param backendRenderTarget: GPU intermediate memory buffer
        :param colorSpace:  range of colors
        :param surfaceProps:    LCD striping orientation and setting for device
            independent fonts; may be nullptr
        :return: :py:class:`Surface` if all parameters are valid; otherwise,
            nullptr
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __buffer__(self, flags):
        """
        Return a buffer object that exposes the underlying memory of the object.
        """
    def __enter__(self) -> Canvas: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: int,
        height: int,
        surfaceProps: SurfaceProps | None = None,
    ) -> None:
        """
        See :py:meth:`~MakeRasterN32Premul`
        """
    @typing.overload
    def __init__(
        self,
        array: numpy.ndarray,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
        surfaceProps: SurfaceProps | None = None,
    ) -> None:
        """
        Create a raster surface on numpy array.

        Input array must have compatible shape with the given color type.

        Do not destroy numpy array while using this surface.

        :array: numpy ndarray of shape=(height, width, channels) and appropriate
            dtype. Must have non-zero width and height, and the valid number of
            channels for the specified color type.
        :colorType: color type of the array
        :alphaType: alpha type of the array
        :colorSpace: range of colors; may be nullptr
        """
    def __release_buffer__(self, buffer):
        """
        Release the buffer object that exposes the underlying memory of the object.
        """
    def asyncRescaleAndReadPixels(
        self,
        info: ImageInfo,
        srcRect: IRect,
        rescaleGamma: Surface.RescaleGamma,
        callback: typing.Callable,
    ) -> None:
        """
        Makes surface pixel data available to caller, possibly asynchronously.

        It can also rescale the surface pixels.

        Currently asynchronous reads are only supported on the GPU backend and
        only when the underlying 3D API supports transfer buffers and CPU/GPU
        synchronization primitives. In all other cases this operates
        synchronously.

        Data is read from the source sub-rectangle, is optionally converted to a
        linear gamma, is rescaled to the size indicated by 'info', is then
        converted to the color space, color type, and alpha type of 'info'. A
        'srcRect' that is not contained by the bounds of the surface causes
        failure.

        When the pixel data is ready the caller's callback function is called
        with a AsyncReadResult containing pixel data in the requested color
        type, alpha type, and color space. The AsyncReadResult will have
        count() == 1. Upon failure the callback is called with nullptr for
        AsyncReadResult. For a GPU surface this flushes work but a submit must
        occur to guarantee a finite time before the callback is called.

        The data is valid for the lifetime of AsyncReadResult with the exception
        that if the :py:class:`Surface` is GPU-backed the data is immediately
        invalidated if the GrContext is abandoned or destroyed.

        :param info:    info of the requested pixels
        :param srcRect: subrectangle of surface to read
        :param rescaleGamma:    controls whether rescaling is done in the
            surface's gamma or whether the source data is transformed to a
            linear gamma before rescaling.
        :param rescaleQuality:  controls the quality (and cost) of the rescaling
        :param callback: function to call with result of the read.  The callback
            takes one argument of :py:class:`Surface.AsyncReadResult`
        """
    def characterize(self, characterization: SurfaceCharacterization) -> bool:
        """
        Initializes :py:class:`SurfaceCharacterization` that can be used to
        perform GPU back-end processing in a separate thread.

        Typically this is used to divide drawing into multiple tiles.
        :py:class:`DeferredDisplayListRecorder` records the drawing commands for
        each tile.

        Return true if :py:class:`Surface` supports characterization. raster
        surface returns false.

        :param skia.SurfaceCharacterization characterization: properties for
            parallel drawing
        :return: true if supported
        """
    def draw(
        self,
        canvas: Canvas,
        x: float,
        y: float,
        paint: Paint | None = None,
    ) -> None:
        """
        Draws :py:class:`Surface` contents to canvas, with its top-left corner
        at (x, y).

        If :py:class:`Paint` paint is not nullptr, apply
        :py:class:`ColorFilter`, alpha, :py:class:`ImageFilter`,
        :py:class:`BlendMode`, and :py:class:`DrawLooper`.

        :canvas: :py:class:`Canvas` drawn into
        :x: horizontal offset in :py:class:`Canvas`
        :y: vertical offset in :py:class:`Canvas`
        :paint: :py:class:`Paint` containing :py:class:`BlendMode`,
            :py:class:`ColorFilter`, :py:class:`ImageFilter`, and so on; or
            nullptr
        """
    @typing.overload
    def flush(
        self,
        access: Surface.BackendSurfaceAccess,
        info: GrFlushInfo,
    ) -> GrSemaphoresSubmitted:
        """
        Issues pending :py:class:`Surface` commands to the GPU-backed API
        objects and resolves any :py:class:`Surface` MSAA. A call to
        :py:meth:`GrContext.submit` is always required to ensure work
        is actually sent to the gpu. Some specific API details:

        :GL: Commands are actually sent to the driver, but glFlush is never
            called. Thus some sync objects from the flush will not be valid
            until a submission occurs.

        :Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs
            corresponding command buffer or encoder objects. However, these
            objects are not sent to the gpu until a submission occurs.

        The work that is submitted to the GPU will be dependent on the
        :py:class:`BackendSurfaceAccess` that is passed in.

        If :py:attr:`BackendSurfaceAccess.kNoAccess` is passed in all commands
        will be issued to the GPU.

        If :py:attr:`BackendSurfaceAccess.kPresent` is passed in and the backend
        API is not Vulkan, it is treated the same as kNoAccess. If the backend
        API is Vulkan, the VkImage that backs the :py:class:`Surface` will be
        transferred back to its original queue. If the :py:class:`Surface` was
        created by wrapping a VkImage, the queue will be set to the queue which
        was originally passed in on the GrVkImageInfo. Additionally, if the
        original queue was not external or foreign the layout of the VkImage
        will be set to VK_IMAGE_LAYOUT_PRESENT_SRC_KHR.

        The :py:class:`GrFlushInfo` describes additional options to flush.
        Please see documentation at :py:class:`GrFlushInfo` for more info.

        If the return is :py:attr:`GrSemaphoresSubmitted.kYes`, only initialized
        :py:class:`GrBackendSemaphores` will be submitted to the gpu during the
        next submit call (it is possible Skia failed to create a subset of the
        semaphores). The client should not wait on these semaphores until after
        submit has been called, but must keep them alive until then. If a submit
        flag was passed in with the flush these valid semaphores can we waited
        on immediately. If this call returns
        :py:attr:`GrSemaphoresSubmitted.kNo`, the GPU backend will not submit
        any semaphores to be signaled on the GPU. Thus the client should not
        have the GPU wait on any of the semaphores passed in with the
        :py:class:`GrFlushInfo`. Regardless of whether semaphores were submitted
        to the GPU or not, the client is still responsible for deleting any
        initialized semaphores. Regardleess of semaphore submission the context
        will still be flushed. It should be emphasized that a return value of
        :py:attr:`GrSemaphoresSubmitted.kNo` does not mean the flush did not
        happen. It simply means there were no semaphores submitted to the GPU. A
        caller should only take this as a failure if they passed in semaphores
        to be submitted.

        Pending surface commands are flushed regardless of the return result.

        :param access:  type of access the call will do on the backend object
            after flush
        :param info:    flush options
        """
    @typing.overload
    def flush(self, info: GrFlushInfo, newState: ... = None) -> GrSemaphoresSubmitted:
        """
        Issues pending :py:class:`Surface` commands to the GPU-backed API
        objects and resolves any :py:class:`Surface` MSAA.

        A call to :py:meth:`GrContext.submit` is always required to ensure work
        is ctually sent to the gpu. Some specific API details:

        :GL: Commands are actually sent to the driver, but glFlush is never
            called. Thus some sync objects from the flush will not be valid
            until a submission occurs.

        :Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs
            corresponding command buffer or encoder objects. However, these
            objects are not sent to the gpu until a submission occurs.

        The GrFlushInfo describes additional options to flush. Please see
        documentation at GrFlushInfo for more info.

        If a GrBackendSurfaceMutableState is passed in, at the end of the flush
        we will transition the surface to be in the state requested by the
        GrBackendSurfaceMutableState. If the surface (or :py:class:`Image` or
        GrBackendSurface wrapping the same backend object) is used again after
        this flush the state may be changed and no longer match what is
        requested here. This is often used if the surface will be used for
        presenting or external use and the client wants backend object to be
        prepped for that use. A finishedProc or semaphore on the GrFlushInfo
        will also include the work for any requested state change.

        If the return is GrSemaphoresSubmitted::kYes, only initialized
        GrBackendSemaphores will be submitted to the gpu during the next submit
        call (it is possible Skia failed to create a subset of the semaphores).
        The client should not wait on these semaphores until after submit has
        been called, but must keep them alive until then. If a submit flag was
        passed in with the flush these valid semaphores can we waited on
        immediately. If this call returns GrSemaphoresSubmitted::kNo, the GPU
        backend will not submit any semaphores to be signaled on the GPU. Thus
        the client should not have the GPU wait on any of the semaphores passed
        in with the GrFlushInfo. Regardless of whether semaphores were submitted
        to the GPU or not, the client is still responsible for deleting any
        initialized semaphores. Regardleess of semaphore submission the context
        will still be flushed. It should be emphasized that a return value of
        GrSemaphoresSubmitted::kNo does not mean the flush did not happen. It
        simply means there were no semaphores submitted to the GPU. A caller
        should only take this as a failure if they passed in semaphores to be
        submitted.

        Pending surface commands are flushed regardless of the return result.

        :param info: flush options
        :param newState: optional state change request after flush
        """
    def flushAndSubmit(self, sync: GrSyncCpu = ...) -> None:
        """
        Call to ensure all reads/writes of the surface have been issued to the
        underlying 3D API.

        Skia will correctly order its own draws and pixel operations. This must
        to be used to ensure correct ordering when the surface backing store is
        accessed outside Skia (e.g. direct use of the 3D API or a windowing
        system). :py:class:`GrContext` has additional flush and submit methods
        that apply to all surfaces and images created from a
        :py:class:`GrContext`. This is equivalent to calling :py:meth:`flush`
        with a default :py:class:`GrFlushInfo` followed by
        :py:meth:`GrContext.submit`.
        """
    def generationID(self) -> int:
        """
        Returns unique value identifying the content of :py:class:`Surface`.

        Returned value changes each time the content changes. Content is changed
        by drawing, or by calling :py:meth:`notifyContentWillChange`.

        :return: unique content identifier
        """
    def getBackendRenderTarget(
        self,
        backendHandleAccess: Surface.BackendHandleAccess,
    ) -> GrBackendRenderTarget:
        """
        Retrieves the back-end render target.

        If :py:class:`Surface` has no back-end render target, an invalid object
        is returned. Call :py:meth:`GrBackendRenderTarget.isValid` to determine
        if the result is valid.

        The returned :py:class:`GrBackendRenderTarget` should be discarded if
        the :py:class:`Surface` is drawn to or deleted.

        :return: GPU render target reference; invalid on failure
        """
    def getBackendTexture(
        self,
        backendHandleAccess: Surface.BackendHandleAccess,
    ) -> GrBackendTexture:
        """
        Retrieves the back-end texture.

        If :py:class:`Surface` has no back-end texture, an invalid object is
        returned. Call :py:meth:`GrBackendTexture.isValid` to determine if the
        result is valid.

        The returned :py:class:`GrBackendTexture` should be discarded if the
        :py:class:`Surface` is drawn to or deleted.

        :return: GPU texture reference; invalid on failure
        """
    def getCanvas(self) -> Canvas:
        """
        Returns :py:class:`Canvas` that draws into :py:class:`Surface`.

        Subsequent calls return the same :py:class:`Canvas`. :py:class:`Canvas`
        returned is managed and owned by :py:class:`Surface`, and is deleted
        when :py:class:`Surface` is deleted.

        :return: drawing :py:class:`Canvas` for :py:class:`Surface`
        """
    def height(self) -> int:
        """
        Returns pixel row count; may be zero or greater.

        :return: number of pixel rows
        """
    def imageInfo(self) -> ImageInfo:
        """
        Returns an :py:class:`ImageInfo` describing the surface.
        """
    def isCompatible(self, characterization: SurfaceCharacterization) -> bool:
        """
        Is this surface compatible with the provided characterization?

        This method can be used to determine if an existing :py:class:`Surface`
        is a viable destination for an :py:class:`DeferredDisplayList`.

        :param skia.SurfaceCharacterization characterization: The
            characterization for which a compatibility check is desired
        :return: true if this surface is compatible with the characterization;
            false otherwise
        """
    @typing.overload
    def makeImageSnapshot(self) -> Image:
        """
        Returns :py:class:`Image` capturing :py:class:`Surface` contents.

        Subsequent drawing to :py:class:`Surface` contents are not captured.
        :py:class:`Image` allocation is accounted for if :py:class:`Surface` was
        created with :py:attr:`Budgeted.kYes`.

        :return: :py:class:`Image` initialized with :py:class:`Surface` contents
        """
    @typing.overload
    def makeImageSnapshot(self, bounds: IRect) -> Image:
        """
        Like the no-parameter version, this returns an image of the current
        surface contents.

        This variant takes a rectangle specifying the subset of the surface that
        is of interest. These bounds will be sanitized before being used.

        - If bounds extends beyond the surface, it will be trimmed to just the
            intersection of it and the surface.
        - If bounds does not intersect the surface, then this returns nullptr.
        - If bounds == the surface, then this is the same as calling the
            no-parameter variant.
        """
    @typing.overload
    def makeSurface(self, imageInfo: ImageInfo) -> Surface:
        """
        Returns a compatible :py:class:`Surface`, or nullptr.

        Returned :py:class:`Surface` contains the same raster, GPU, or null
        properties as the original. Returned :py:class:`Surface` does not share
        the same pixels.

        Returns nullptr if imageInfo width or height are zero, or if imageInfo
        is incompatible with :py:class:`Surface`.

        :param skia.ImageInfo imageInfo: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`, of
            :py:class:`Surface`; width and height must be greater than zero
        :return: compatible :py:class:`Surface` or nullptr
        """
    @typing.overload
    def makeSurface(self, width: int, height: int) -> Surface:
        """
        Calls :py:meth:`makeSurface()` with the same ImageInfo as this surface,
        but with the specified width and height.
        """
    def notifyContentWillChange(self, mode: Surface.ContentChangeMode) -> None:
        """
        Notifies that :py:class:`Surface` contents will be changed by code
        outside of Skia.

        Subsequent calls to :py:meth:`generationID` return a different value.
        """
    def peekPixels(self, pixmap: Pixmap) -> bool:
        """
        Copies :py:class:`Surface` pixel address, row bytes, and
        :py:class:`ImageInfo` to :py:class:`Pixmap`, if address is available,
        and returns true.

        If pixel address is not available, return false and leave
        :py:class:`Pixmap` unchanged.

        pixmap contents become invalid on any future change to
        :py:class:`Surface`.

        :param skia.Pixmap pixmap: storage for pixel state if pixels are
            readable; otherwise, ignored
        :return: true if :py:class:`Surface` has direct access to pixels
        """
    def props(self) -> SurfaceProps:
        """
        Returns :py:class:`SurfaceProps` for surface.

        :return: LCD striping orientation and setting for device independent
            fonts
        """
    @typing.overload
    def readPixels(self, dst: Pixmap, srcX: int = 0, srcY: int = 0) -> bool:
        """
        Copies :py:class:`Rect` of pixels to dst.

        Source :py:class:`Rect` corners are (srcX, srcY) and :py:class:`Surface`
        (width(), height()). Destination :py:class:`Rect` corners are (0, 0) and
        (dst.width(), dst.height()). Copies each readable pixel intersecting
        both rectangles, without scaling, converting to dst.colorType() and
        dst.alphaType() if required.

        Pixels are readable when :py:class:`Surface` is raster, or backed by a
        GPU.

        The destination pixel storage must be allocated by the caller.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. dst contents outside :py:class:`Rect`
        intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        destination.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Pixmap` pixels could not be allocated.
        - dst.rowBytes() is too small to contain one row of pixels.

        :dst: storage for pixels copied from :py:class:`Surface`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        """
    @typing.overload
    def readPixels(
        self,
        dstInfo: ImageInfo,
        dstPixels: typing_extensions.Buffer,
        dstRowBytes: int = 0,
        srcX: int = 0,
        srcY: int = 0,
    ) -> bool:
        """
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into array.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and :py:class:`Surface`
        (width(), height()). Destination :py:class:`Rect` corners are (0, 0) and
        (array.shape[1], array.shape[0]). Copies each readable pixel
        intersecting both rectangles, without scaling, converting to
        :py:attr:`ColorType.kN32` and :py:attr:`AlphaType.kPremul` if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU.

        The destination pixel storage must be allocated by the caller.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. array contents outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        destination.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Surface` pixels could not be converted to
            :py:attr:`ColorType.kN32` or :py:attr:`AlphaType.kPremul`.

        :dstInfo: width, height, :py:class:`ColorType`, and
            :py:class:`AlphaType` of dstPixels
        :dstPixels: storage for pixels; dstInfo.height() times dstRowBytes, or
            larger
        :dstRowBytes: size of one destination row; dstInfo.width() times pixel
            size, or larger. Ignored when dstPixels has more than one-dimension.
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        """
    @typing.overload
    def readPixels(self, dst: Bitmap, srcX: int, srcY: int) -> bool:
        """
        Copies :py:class:`Rect` of pixels from :py:class:`Surface` into bitmap.

        Source :py:class:`Rect` corners are (srcX, srcY) and :py:class:`Surface`
        (width(), height()). Destination :py:class:`Rect` corners are (0, 0) and
        (bitmap.width(), bitmap.height()). Copies each readable pixel
        intersecting both rectangles, without scaling, converting to
        bitmap.colorType() and bitmap.alphaType() if required.

        Pixels are readable when :py:class:`Surface` is raster, or backed by a
        GPU.

        The destination pixel storage must be allocated by the caller.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. dst contents outside :py:class:`Rect`
        intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        destination.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Surface` pixels could not be converted to dst.colorType()
            or dst.alphaType().
        - dst pixels could not be allocated.
        - dst.rowBytes() is too small to contain one row of pixels.

        :dst: storage for pixels copied from :py:class:`Surface`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        """
    def recordingContext(self) -> GrRecordingContext:
        """
        Returns the recording context being used by the :py:class:`Surface`.

        :return: GPU context, if available; nullptr otherwise
        """
    def replaceBackendTexture(
        self,
        backendTexture: GrBackendTexture,
        origin: GrSurfaceOrigin,
        mode: Surface.ContentChangeMode = ...,
    ) -> bool:
        """
        If the surface was made via :py:meth:`MakeFromBackendTexture` then it's
        backing texture may be substituted with a different texture.

        The contents of the previous backing texture are copied into the new
        texture. :py:class:`Canvas` state is preserved. The original sample
        count is used. The :py:class:`GrBackendFormat` and dimensions of
        replacement texture must match that of the original.

        :param backendTexture:  the new backing texture for the surface
        :param mode:    Retain or discard current Content
        """
    def toarray(
        self,
        srcX: int = 0,
        srcY: int = 0,
        colorType: ColorType = ...,
        alphaType: AlphaType = ...,
        colorSpace: ColorSpace | None = None,
    ) -> numpy.ndarray:
        """
        Exports a ``numpy.ndarray``.

        :param srcX: offset into readable pixels on x-axis; may be negative
        :param srcY: offset into readable pixels on y-axis; may be negative
        :param colorType: target :py:class:`ColorType`
        :param alphaType: target :py:class:`AlphaType`
        :param colorSpace: target :py:class:`ColorSpace`
        :return: numpy.ndarray
        """
    def width(self) -> int:
        """
        Returns pixel count in each row; may be zero or greater.

        :return: number of pixel columns
        """
    @typing.overload
    def writePixels(self, src: Pixmap, dstX: int = 0, dstY: int = 0) -> None:
        """
        Copies :py:class:`Rect` of pixels from the src :py:class:`Pixmap` to the
        :py:class:`Surface`.

        Source :py:class:`Rect` corners are (0, 0) and (src.width(),
        src.height()). Destination :py:class:`Rect` corners are (dstX, dstY) and
        (dstX + Surface width(), dstY + Surface height()).

        Copies each readable pixel intersecting both rectangles, without
        scaling, converting to :py:class:`Surface` colorType() and
        :py:class:`Surface` alphaType() if required.

        :src: storage for pixels to copy to :py:class:`Surface`
        :dstX: x-axis position relative to :py:class:`Surface` to begin copy;
            may be negative
        :dstY: y-axis position relative to :py:class:`Surface` to begin copy;
            may be negative
        """
    @typing.overload
    def writePixels(self, src: Bitmap, dstX: int = 0, dstY: int = 0) -> None:
        """
        Copies :py:class:`Rect` of pixels from the src :py:class:`Bitmap` to the
        :py:class:`Surface`.

        Source :py:class:`Rect` corners are (0, 0) and (src.width(),
        src.height()). Destination :py:class:`Rect` corners are (dstX, dstY) and
        (dstX + Surface width(), dstY + Surface height()).

        Copies each readable pixel intersecting both rectangles, without
        scaling, converting to :py:class:`Surface` colorType() and
        :py:class:`Surface` alphaType() if required.

        :src: storage for pixels to copy to :py:class:`Surface`
        :dstX: x-axis position relative to :py:class:`Surface` to begin copy;
            may be negative
        :dstY: y-axis position relative to :py:class:`Surface` to begin copy;
            may be negative
        """

class SurfaceCharacterization:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: SurfaceCharacterization) -> bool: ...
    def __init__(self) -> None: ...
    def __ne__(self, arg0: SurfaceCharacterization) -> bool: ...
    def cacheMaxResourceBytes(self) -> int: ...
    def colorSpace(self) -> ColorSpace: ...
    def createBackendFormat(
        self,
        colorType: ColorType,
        backendFormat: GrBackendFormat,
    ) -> SurfaceCharacterization: ...
    def createColorSpace(self, cs: ColorSpace) -> SurfaceCharacterization: ...
    def createFBO0(self, usesGLFBO0: bool) -> SurfaceCharacterization: ...
    def createResized(self, width: int, height: int) -> SurfaceCharacterization: ...
    def height(self) -> int: ...
    def isMipMapped(self) -> bool: ...
    def isTextureable(self) -> bool: ...
    def isValid(self) -> bool: ...
    def refColorSpace(self) -> ColorSpace: ...
    def surfaceProps(self) -> SurfaceProps: ...
    def usesGLFBO0(self) -> bool: ...
    def vulkanSecondaryCBCompatible(self) -> bool: ...
    def width(self) -> int: ...

class SurfaceProps:
    """

    Describes properties and constraints of a given :py:class:`Surface`.

    The rendering engine can parse these during drawing, and can sometimes
    optimize its performance (e.g. disabling an expensive feature).

    """
    class Flags:
        """
        Members:

          kUseDeviceIndependentFonts_Flag

          kDynamicMSAA_Flag

          kAlwaysDither_Flag
        """

        __members__: typing.ClassVar[
            dict[str, SurfaceProps.Flags]
        ]  # value = {'kUseDeviceIndependentFonts_Flag': <Flags.kUseDeviceIndependentFonts_Flag: 1>, 'kDynamicMSAA_Flag': <Flags.kDynamicMSAA_Flag: 2>, 'kAlwaysDither_Flag': <Flags.kAlwaysDither_Flag: 4>}
        kAlwaysDither_Flag: typing.ClassVar[
            SurfaceProps.Flags
        ]  # value = <Flags.kAlwaysDither_Flag: 4>
        kDynamicMSAA_Flag: typing.ClassVar[
            SurfaceProps.Flags
        ]  # value = <Flags.kDynamicMSAA_Flag: 2>
        kUseDeviceIndependentFonts_Flag: typing.ClassVar[
            SurfaceProps.Flags
        ]  # value = <Flags.kUseDeviceIndependentFonts_Flag: 1>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: object) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kAlwaysDither_Flag: typing.ClassVar[
        SurfaceProps.Flags
    ]  # value = <Flags.kAlwaysDither_Flag: 4>
    kDynamicMSAA_Flag: typing.ClassVar[
        SurfaceProps.Flags
    ]  # value = <Flags.kDynamicMSAA_Flag: 2>
    kUseDeviceIndependentFonts_Flag: typing.ClassVar[
        SurfaceProps.Flags
    ]  # value = <Flags.kUseDeviceIndependentFonts_Flag: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: SurfaceProps) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, flags: int, geometry: PixelGeometry) -> None: ...
    @typing.overload
    def __init__(self, props: SurfaceProps) -> None: ...
    def __ne__(self, arg0: SurfaceProps) -> bool: ...
    def flags(self) -> int: ...
    def isUseDeviceIndependentFonts(self) -> bool: ...
    def pixelGeometry(self) -> PixelGeometry: ...

class TableColorFilter:
    @staticmethod
    def Make(table: list[int]) -> ColorFilter:
        """
        Create a table colorfilter, copying the table into the filter, and
        applying it to all 4 components.

        a' = table[a]; r' = table[r]; g' = table[g]; b' = table[b]; Compoents
        are operated on in unpremultiplied space. If the incomming colors are
        premultiplied, they are temporarily unpremultiplied, then the table is
        applied, and then the result is remultiplied.
        """
    @staticmethod
    def MakeARGB(
        tableA: typing.Any,
        tableR: typing.Any,
        tableG: typing.Any,
        tableB: typing.Any,
    ) -> ColorFilter:
        """
        Create a table colorfilter, with a different table for each component
        [A, R, G, B].

        If a given table is NULL, then it is treated as identity, with the
        component left unchanged. If a table is not null, then its contents are
        copied into the filter.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class TableMaskFilter:
    """

    Applies a table lookup on each of the alpha values in the mask.

    Helper methods create some common tables (e.g. gamma, clipping)

    """
    @staticmethod
    def Create(table: list[int]) -> MaskFilter: ...
    @staticmethod
    def CreateClip(min: int, max: int) -> MaskFilter: ...
    @staticmethod
    def CreateGamma(gamma: float) -> MaskFilter: ...
    @staticmethod
    def MakeClipTable(min: int, max: int) -> typing.Any:
        """
        Utility that creates a clipping table: clamps values below min to 0 and
        above max to 255, and rescales the remaining into 0..255.

        :return: clipping table
        :rtype: List[int]
        """
    @staticmethod
    def MakeGammaTable(gamma: float) -> typing.Any:
        """
        Utility that sets the gamma table.

        :return: gamma table
        :rtype: List[int]
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class TextBlob:
    """

    :py:class:`TextBlob` combines multiple text runs into an immutable
    container.

    Each text run consists of glyphs, :py:class:`Paint`, and position. Only
    parts of :py:class:`Paint` related to fonts and text rendering are used by
    run.

    Example::

        textblob = skia.TextBlob("text", skia.Font())
        for run in textblob:
            print(run.fGlyphIndices)

    """
    class Iter:
        """

        Iterator for :py:class:`~skia.TextBlob.Iter.Run`.

        Example::

            run = skia.TextBlob.Iter.Run()
            it = skia.TextBlob.Iter(textblob)
            while it.next(run):
                print(run)

            for run in textblob():
                print(run)

        """
        class Run:
            @staticmethod
            def _pybind11_conduit_v1_(*args, **kwargs): ...
            def __init__(self) -> None: ...
            @property
            def fGlyphCount(self) -> int: ...
            @property
            def fGlyphIndices(self) -> list[int]: ...
            @property
            def fTypeface(self) -> Typeface: ...

        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self, arg0: TextBlob) -> None: ...
        def __next__(self) -> TextBlob.Iter.Run: ...
        def next(self, run: TextBlob.Iter.Run) -> bool: ...

    @staticmethod
    def Deserialize(data: typing_extensions.Buffer) -> TextBlob:
        """
        Recreates :py:class:`TextBlob` that was serialized into data.

        Returns constructed :py:class:`TextBlob` if successful; otherwise,
        returns nullptr. Fails if size is smaller than required data length, or
        if data does not permit constructing valid :py:class:`TextBlob`.

        procs.fTypefaceProc permits supplying a custom function to decode
        :py:class:`Typeface`. If procs.fTypefaceProc is nullptr, default
        decoding is used. procs.fTypefaceCtx may be used to provide user context
        to procs.fTypefaceProc; procs.fTypefaceProc is called with a pointer to
        :py:class:`Typeface` data, data byte length, and user context.

        :param Union[bytes,bytearray,memoryview] data: serial data
        :return: :py:class:`TextBlob` constructed from data in memory
        """
    @staticmethod
    def MakeFromPosText(
        text: str,
        pos: list[Point],
        font: Font,
        encoding: TextEncoding = ...,
    ) -> TextBlob:
        """
        Returns a textblob built from a single run of text with x-positions and
        a single y value.

        This is equivalent to using :py:class:`TextBlobBuilder` and calling
        :py:meth:`TextBlobBuilder.allocRunPosH`.

        :param str text: character code points or glyphs drawn (based on
            encoding)
        :param List[skia.Point] pos: array of positions, must contain values for
            all of the character points.
        :param skia.Font font: :py:class:`Font` used for this run
        :param skia.TextEncoding encoding: specifies the encoding of the text
            array.
        :return: new textblob or nullptr
        """
    @staticmethod
    def MakeFromPosTextH(
        text: str,
        xpos: typing.Iterable,
        constY: float,
        font: Font,
        encoding: TextEncoding = ...,
    ) -> TextBlob:
        """
        Returns a textblob built from a single run of text with x-positions and
        a single y value.

        This is equivalent to using :py:class:`TextBlobBuilder` and calling
        :py:meth:`TextBlobBuilder.allocRunPosH`.

        :param str text: character code points or glyphs drawn (based on
            encoding)
        :param List[float] xpos: array of x-positions, must contain values for
            all of the character points.
        :param float constY: shared y-position for each character point, to be
            paired with each xpos.
        :param skia.Font font: :py:class:`Font` used for this run
        :param skia.TextEncoding encoding: specifies the encoding of the text
            array.
        :return: new textblob or nullptr
        """
    @staticmethod
    def MakeFromRSXform(
        text: str,
        xform: list[RSXform],
        font: Font,
        encoding: TextEncoding = ...,
    ) -> TextBlob: ...
    @staticmethod
    def MakeFromShapedText(
        utf8text: str,
        font: Font,
        leftToRight: bool = True,
    ) -> TextBlob:
        """
        Creates :py:class:`TextBlob` in a single run, with shaping, for a text-run direction.

        :param str utf8text: character code points drawn
        :param skia.Font font: text size, typeface, text scale, and so on, used
            to draw
        :param leftToRight bool: text-run direction
        :return: :py:class:`TextBlob` constructed from one run
        """
    @staticmethod
    def MakeFromString(
        string: str,
        font: Font,
        encoding: TextEncoding = ...,
    ) -> TextBlob:
        """
        Creates :py:class:`TextBlob` with a single run.

        string meaning depends on :py:class:`TextEncoding`; by default, string
        is encoded as UTF-8.

        font contains attributes used to define the run text.

        When encoding is :py:attr:`TextEncoding.kUTF8`,
        :py:attr:`TextEncoding.kUTF16`, or :py:attr:`TextEncoding.kUTF32`, this
        function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        :param str string: character code points or glyphs drawn
        :param skia.Font font: text size, typeface, text scale, and so on, used
            to draw
        :param skia.TextEncoding encoding: text encoding used in the text array
        :return: :py:class:`TextBlob` constructed from one run
        """
    @staticmethod
    def MakeFromText(text: str, font: Font, encoding: TextEncoding = ...) -> TextBlob:
        """
        Creates :py:class:`TextBlob` with a single run.

        font contains attributes used to define the run text.

        When encoding is :py:attr:`TextEncoding.kUTF8`,
        :py:attr:`TextEncoding.kUTF16`, or :py:attr:`TextEncoding.kUTF32`, this
        function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        :param str text: character code points or glyphs drawn
        :param skia.Font font: text size, typeface, text scale, and so on, used
            to draw
        :param skia.TextEncoding encoding: text encoding used in the text array
        :return: :py:class:`TextBlob` constructed from one run
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(
        self,
        text: str,
        font: Font,
        positions: typing.Any = None,
        encoding: TextEncoding = ...,
    ) -> None:
        """
        Creates :py:class:`TextBlob` with a single run.

        `font` contains attributes used to define the run text.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        :param str text: character code points or glyphs drawn
        :param skia.Font font: text size, typeface, text scale, and so on, used
            to draw
        :param List[skia.Point] positions: array of positions, must contain
            values for all of the character points.
        :param skia.TextEncoding encoding: text encoding used in the text array
        """
    def __iter__(self) -> TextBlob.Iter: ...
    def bounds(self) -> Rect:
        """
        Returns conservative bounding box.

        Uses :py:class:`Paint` associated with each glyph to determine glyph
        bounds, and unions all bounds. Returned bounds may be larger than the
        bounds of all glyphs in runs.

        :return: conservative bounding box
        """
    def deref(self) -> None: ...
    def getIntercepts(
        self,
        bounds: typing.Iterable,
        paint: Paint | None = None,
    ) -> list[float]:
        """
        Returns the number of intervals that intersect bounds.

        bounds describes a pair of lines parallel to the text advance. The
        return count is zero or a multiple of two, and is at most twice the
        number of glyphs in the the blob.

        Pass nullptr for intervals to determine the size of the interval array.

        Runs within the blob that contain :py:class:`RSXform` are ignored when
        computing intercepts.

        :param List[skia.Scalar] bounds: lower and upper line parallel to the
            advance
        :param skia.Paint paint: specifies stroking, :py:class:`PathEffect` that
            affects the result; may be nullptr
        :return: intersections; may be empty
        """
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def serialize(self) -> Data:
        """
        Returns storage containing :py:class:`Data` describing
        :py:class:`TextBlob`, using optional custom encoders.

        procs.fTypefaceProc permits supplying a custom function to encode
        :py:class:`Typeface`. If procs.fTypefaceProc is nullptr, default
        encoding is used. procs.fTypefaceCtx may be used to provide user context
        to procs.fTypefaceProc; procs.fTypefaceProc is called with a pointer to
        :py:class:`Typeface` and user context.

        :return: storage containing serialized :py:class:`TextBlob`
        """
    def unique(self) -> bool: ...
    def uniqueID(self) -> int:
        """
        Returns a non-zero value unique among all text blobs.

        :return: identifier for :py:class:`TextBlob`
        """
    def unref(self) -> None: ...

class TextBlobBuilder:
    """

    Helper class for constructing :py:class:`TextBlob`.

    """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None:
        """
        Constructs empty :py:class:`TextBlobBuilder`.
        """
    def allocRun(
        self,
        text: str,
        font: Font,
        x: float,
        y: float,
        bounds: Rect | None = None,
        encoding: TextEncoding = ...,
    ) -> None:
        """
        Sets a new run with glyphs.

        Glyphs share metrics in font.

        Glyphs are positioned on a baseline at (x, y), using font metrics to
        determine their relative placement.

        bounds defines an optional bounding box, used to suppress drawing when
        :py:class:`TextBlob` bounds does not intersect :py:class:`Surface`
        bounds. If bounds is nullptr, :py:class:`TextBlob` bounds is computed
        from (x, y) and RunBuffer::glyphs metrics.

        :param skia.Font font: :py:class:`Font` used for this run
        :param str text: text for the run
        :param float x: horizontal offset within the blob
        :param float y: vertical offset within the blob
        :param skia.Rect bounds: optional run bounding box
        :param skia.TextEncoding encoding: specifies the encoding of the text
            array
        """
    def allocRunPos(
        self,
        font: Font,
        glyphs: list[int],
        positions: typing.Iterable,
        bounds: Rect | None = None,
    ) -> None:
        """
        Sets a new run with glyphs and :py:class:`Point` positions.

        Glyphs share metrics in font.

        Glyphs are positioned using :py:class:`Point`, using two scalar values
        for each :py:class:`Point`.

        bounds defines an optional bounding box, used to suppress drawing when
        :py:class:`TextBlob` bounds does not intersect :py:class:`Surface`
        bounds. If bounds is nullptr, :py:class:`TextBlob` bounds is computed
        from RunBuffer::pos and RunBuffer::glyphs metrics.

        :param skia.Font font: :py:class:`Font` used for this run
        :param List[int] glyphs: array of glyph IDs
        :param List[skia.Point] positions: offsets within the blob
        :param skia.Rect bounds: optional run bounding box
        """
    def allocRunPosH(
        self,
        font: Font,
        glyphs: list[int],
        xpos: typing.Iterable,
        y: float,
        bounds: Rect | None = None,
    ) -> None:
        """
        Sets a new run with glyphs and positions along baseline.

        Glyphs share metrics in font.

        Glyphs are positioned on a baseline at y, using x-axis positions.

        bounds defines an optional bounding box, used to suppress drawing when
        :py:class:`TextBlob` bounds does not intersect :py:class:`Surface`
        bounds. If bounds is nullptr, :py:class:`TextBlob` bounds is computed
        from y, RunBuffer::pos, and RunBuffer::glyphs metrics.

        :param skia.Font font: :py:class:`Font` used for this run
        :param List[int] glyphs: array of glyph IDs
        :param List[float] xpos: horizontal offsets within the blob
        :param float y: vertical offset within the blob
        :param skia.Rect bounds: optional run bounding box
        """
    def allocRunRSXform(
        self,
        font: Font,
        glyphs: list[int],
        xforms: list[RSXform],
    ) -> None: ...
    def make(self) -> TextBlob:
        """
        Returns :py:class:`TextBlob` built from runs of glyphs added by builder.

        Returned :py:class:`TextBlob` is immutable; it may be copied, but its
        contents may not be altered. Returns nullptr if no runs of glyphs were
        added by builder.

        Resets :py:class:`TextBlobBuilder` to its initial empty state, allowing
        it to be reused to build a new set of runs.

        :return: :py:class:`TextBlob` or nullptr
        """

class TextEncoding:
    """
    Members:

      kUTF8

      kUTF16

      kUTF32

      kGlyphID
    """

    __members__: typing.ClassVar[
        dict[str, TextEncoding]
    ]  # value = {'kUTF8': <TextEncoding.kUTF8: 0>, 'kUTF16': <TextEncoding.kUTF16: 1>, 'kUTF32': <TextEncoding.kUTF32: 2>, 'kGlyphID': <TextEncoding.kGlyphID: 3>}
    kGlyphID: typing.ClassVar[TextEncoding]  # value = <TextEncoding.kGlyphID: 3>
    kUTF16: typing.ClassVar[TextEncoding]  # value = <TextEncoding.kUTF16: 1>
    kUTF32: typing.ClassVar[TextEncoding]  # value = <TextEncoding.kUTF32: 2>
    kUTF8: typing.ClassVar[TextEncoding]  # value = <TextEncoding.kUTF8: 0>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TileMode:
    """
    Members:

      kClamp : Replicate the edge color if the shader draws outside of its original bounds.

      kRepeat : Repeat the shader's image horizontally and vertically.

      kMirror : Repeat the shader's image horizontally and vertically, alternating mirror images so that adjacent images always seam.

      kDecal : Only draw within the original domain, return transparent-black everywhere else.

      kLastTileMode :
    """

    __members__: typing.ClassVar[
        dict[str, TileMode]
    ]  # value = {'kClamp': <TileMode.kClamp: 0>, 'kRepeat': <TileMode.kRepeat: 1>, 'kMirror': <TileMode.kMirror: 2>, 'kDecal': <TileMode.kDecal: 3>, 'kLastTileMode': <TileMode.kDecal: 3>}
    kClamp: typing.ClassVar[TileMode]  # value = <TileMode.kClamp: 0>
    kDecal: typing.ClassVar[TileMode]  # value = <TileMode.kDecal: 3>
    kLastTileMode: typing.ClassVar[TileMode]  # value = <TileMode.kDecal: 3>
    kMirror: typing.ClassVar[TileMode]  # value = <TileMode.kMirror: 2>
    kRepeat: typing.ClassVar[TileMode]  # value = <TileMode.kRepeat: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TrimPathEffect:
    class Mode:
        """
        Members:

          kNormal

          kInverted
        """

        __members__: typing.ClassVar[
            dict[str, TrimPathEffect.Mode]
        ]  # value = {'kNormal': <Mode.kNormal: 0>, 'kInverted': <Mode.kInverted: 1>}
        kInverted: typing.ClassVar[TrimPathEffect.Mode]  # value = <Mode.kInverted: 1>
        kNormal: typing.ClassVar[TrimPathEffect.Mode]  # value = <Mode.kNormal: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kInverted: typing.ClassVar[TrimPathEffect.Mode]  # value = <Mode.kInverted: 1>
    kNormal: typing.ClassVar[TrimPathEffect.Mode]  # value = <Mode.kNormal: 0>
    @staticmethod
    def Make(
        startT: float,
        stopT: float,
        mode: TrimPathEffect.Mode = ...,
    ) -> PathEffect:
        """
        Take start and stop "t" values (values between 0...1), and return a path
        that is that subset of the original path.

        e.g. Make(0.5, 1.0) > return the 2nd half of the path Make(0.33333,
        0.66667) > return the middle third of the path

        The trim values apply to the entire path, so if it contains several
        contours, all of them are including in the calculation.

        startT and stopT must be 0..1 inclusive. If they are outside of that
        interval, they will be pinned to the nearest legal value. If either is
        NaN, null will be returned.

        Note: for Mode::kNormal, this will return one (logical) segment (even if
        it is spread across multiple contours). For Mode::kInverted, this will
        return 2 logical segments: stopT..1 and 0...startT, in this order.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...

class Typeface(RefCnt):
    """

    The :py:class:`Typeface` class specifies the typeface and intrinsic style of
    a font.

    This is used in the paint, along with optionally algorithmic settings like
    textSize, textSkewX, textScaleX, kFakeBoldText_Mask, to specify how text
    appears when drawn (and measured).

    Typeface objects are immutable, and so they can be shared between threads.


    Example::

        typeface = skia.Typeface()
        typeface = skia.Typeface("Arial")
        typeface = skia.Typeface("Arial", skia.FontStyle.Bold())


    """
    class SerializeBehavior:
        """

            A typeface can serialize just a descriptor (names, etc.), or it can also
            include the actual font data (which can be large).

            This enum controls how serialize() decides what to serialize.


        Members:

          kDoIncludeData

          kDontIncludeData

          kIncludeDataIfLocal
        """

        __members__: typing.ClassVar[
            dict[str, Typeface.SerializeBehavior]
        ]  # value = {'kDoIncludeData': <SerializeBehavior.kDoIncludeData: 0>, 'kDontIncludeData': <SerializeBehavior.kDontIncludeData: 1>, 'kIncludeDataIfLocal': <SerializeBehavior.kIncludeDataIfLocal: 2>}
        kDoIncludeData: typing.ClassVar[
            Typeface.SerializeBehavior
        ]  # value = <SerializeBehavior.kDoIncludeData: 0>
        kDontIncludeData: typing.ClassVar[
            Typeface.SerializeBehavior
        ]  # value = <SerializeBehavior.kDontIncludeData: 1>
        kIncludeDataIfLocal: typing.ClassVar[
            Typeface.SerializeBehavior
        ]  # value = <SerializeBehavior.kIncludeDataIfLocal: 2>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    kDoIncludeData: typing.ClassVar[
        Typeface.SerializeBehavior
    ]  # value = <SerializeBehavior.kDoIncludeData: 0>
    kDontIncludeData: typing.ClassVar[
        Typeface.SerializeBehavior
    ]  # value = <SerializeBehavior.kDontIncludeData: 1>
    kIncludeDataIfLocal: typing.ClassVar[
        Typeface.SerializeBehavior
    ]  # value = <SerializeBehavior.kIncludeDataIfLocal: 2>
    @staticmethod
    def MakeDefault() -> Typeface:
        """
        Returns the default normal typeface, which is never nullptr.
        """
    @staticmethod
    def MakeDeserialize(dats: Data, lastResortMgr: FontMgr) -> Typeface:
        """
        Given the data previously written by :py:meth:`serialize`, return a new
        instance of a typeface referring to the same font.

        If that font is not available, return nullptr.
        """
    @staticmethod
    def MakeEmpty() -> Typeface:
        """
        Returns a non-null typeface which contains no glyphs.
        """
    @staticmethod
    def MakeFromData(data: Data, index: int = 0) -> Typeface:
        """
        Return a new typeface given a :py:class:`Data`.

        If the data is null, or is not a valid font file, returns nullptr.

        Use :py:meth:`MakeDeserialize` for the result of :py:meth:`serialize`.
        """
    @staticmethod
    def MakeFromFile(path: str, index: int = 0) -> Typeface:
        """
        Return a new typeface given a file.

        If the file does not exist, or is not a valid font file, returns
        nullptr.
        """
    @staticmethod
    def MakeFromName(
        familyName: typing.Any,
        fontStyle: FontStyle | None = None,
    ) -> Typeface:
        """
        Creates a new reference to the typeface that most closely matches the
        requested familyName and fontStyle.

        This method allows extended font face specifiers as in the
        :py:class:`FontStyle` type. Will never return null.

        :param str familyName: May be NULL. The name of the font family.
        :param skia.FontStyle fontStyle: The style of the typeface.
        :return: reference to the closest-matching typeface.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def Equal(self, other: Typeface) -> bool:
        """
        Returns true if the two typefaces reference the same underlying font,
        handling either being null (treating null as the default font)
        """
    def __eq__(self, arg0: Typeface) -> bool: ...
    @typing.overload
    def __init__(self) -> None:
        """
        Returns the default normal typeface.
        """
    @typing.overload
    def __init__(
        self,
        familyName: typing.Any,
        fontStyle: FontStyle | None = None,
    ) -> None:
        """
        Creates a new reference to the typeface that most closely matches the
        requested familyName and fontStyle.

        This method allows extended font face specifiers as in the
        :py:class:`FontStyle` type. Will never return null.

        :param str familyName: May be NULL. The name of the font family.
        :param skia.FontStyle fontStyle: The style of the typeface.
        :return: reference to the closest-matching typeface.
        """
    def copyTableData(self, tag: int) -> Data:
        """
        Return an immutable copy of the requested font table, or nullptr if that
        table was not found.

        This can sometimes be faster than calling :py:meth:`getTableData` twice:
        once to find the length, and then again to copy the data.

        :param tag: The table tag whose contents are to be copied
        :return: an immutable copy of the table's data, or nullptr.
        """
    def countGlyphs(self) -> int:
        """
        Return the number of glyphs in the typeface.
        """
    def countTables(self) -> int:
        """
        Return the number of tables in the font.
        """
    def fontStyle(self) -> FontStyle:
        """
        Returns the typeface's intrinsic style attributes.
        """
    def getBounds(self) -> Rect:
        """
        Return a rectangle (scaled to 1-pt) that represents the union of the
        bounds of all of the glyphs, but each one positioned at (0,).

        This may be conservatively large, and will not take into account any
        hinting or other size-specific adjustments.
        """
    def getFamilyName(self) -> str:
        """
        Return the family name for this typeface.

        It will always be returned encoded as UTF8, but the language of the name
        is whatever the host platform chooses.
        """
    def getFamilyNames(self) -> list:
        """
        Returns a list of (family name, language) pairs specified by the font.
        """
    def getKerningPairAdjustments(self, glyphs: list[int]) -> typing.Any:
        """
        Given a run of glyphs, return the associated horizontal adjustments.

        Adjustments are in "design units", which are integers relative to the
        typeface's units per em (see getUnitsPerEm).

        Some typefaces are known to never support kerning. If the typeface does
        not support kerning, then this method will return None (no kerning) for
        all possible glyph runs.
        """
    def getPostScriptName(self) -> str:
        """
        Return the PostScript name for this typeface.
        Value may change based on variation parameters.
        Returns false if no PostScript name is available.
        """
    def getTableData(self, tag: int) -> bytes:
        """
        Returns the contents of a table.

        Note that the contents of the table will be in their native endian order
        (which for most truetype tables is big endian). If the table tag is not
        found, or there is an error copying the data, then 0 is returned. If
        this happens, it is possible that some or all of the memory pointed to
        by data may have been written to, even though an error has occured.

        :param int tag: The table tag whose contents are to be copied.
        :return: table contents
        """
    def getTableSize(self, tag: int) -> int:
        """
        Given a table tag, return the size of its contents, or 0 if not present.
        """
    def getTableTags(self) -> list[int]:
        """
        Returns the list of table tags in the font.
        """
    def getUnitsPerEm(self) -> int:
        """
        Return the units-per-em value for this typeface, or zero if there is an
        error.
        """
    def getVariationDesignParameters(self) -> list[FontParameters.Variation.Axis]:
        """
        Returns the design variation parameters.

        :return: List of axes.
        :rtype: List[skia.FontParameters.Variation.Axis]
        """
    def getVariationDesignPosition(self) -> FontArguments.VariationPosition.Coordinates:
        """
        Returns the design variation coordinates.

        :param int coordinateCount: the maximum number of entries to get.
        :return: list of coordinates
        :rtype: List[skia.FontArguments.VariationPosition.Coordinate]
        """
    def isBold(self) -> bool:
        """
        Returns true if style() has the kBold bit set.
        """
    def isFixedPitch(self) -> bool:
        """
        Returns true if the typeface claims to be fixed-pitch.
        """
    def isItalic(self) -> bool:
        """
        Returns true if style() has the kItalic bit set.
        """
    def makeClone(self, fontArguments: FontArguments) -> Typeface:
        """
        Return a new typeface based on this typeface but parameterized as
        specified in the :py:class:`FontArguments`.

        If the :py:class:`FontArguments` does not supply an argument for a
        parameter in the font then the value from this typeface will be used as
        the value for that argument. If the cloned typeface would be exaclty the
        same as this typeface then this typeface may be ref'ed and returned. May
        return nullptr on failure.
        """
    def serialize(self, behavior: Typeface.SerializeBehavior = ...) -> Data:
        """
        Returns a unique signature to a stream, sufficient to reconstruct a
        typeface referencing the same font when Deserialize is called.
        """
    def unicharToGlyph(self, unichar: int) -> int:
        """
        Return the glyphID that corresponds to the specified unicode code-point
        (in UTF32 encoding).

        If the unichar is not supported, returns 0.

        This is a short-cut for calling :py:meth:`unicharsToGlyphs`.
        """
    def unicharsToGlyphs(self, chars: list[int]) -> list[int]:
        """
        Given an array of UTF32 character codes, return their corresponding
        glyph IDs.

        :param List[int] chars: the array of UTF32 chars.
        :return: the corresponding glyph IDs for each character.
        """
    def uniqueID(self) -> int:
        """
        Return a 32bit value for this typeface, unique for the underlying font
        data.

        Will never return 0.
        """

class Unicode(RefCnt):
    @staticmethod
    def ICU_Make() -> Unicode: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...

class V3:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...
    @typing.overload
    def __init__(self, v3: tuple) -> None: ...

class V4:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...
    @typing.overload
    def __init__(self, v4: tuple) -> None: ...

class VectorRuntimeEffectChildPtr:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> VectorRuntimeEffectChildPtr:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> RuntimeEffectChildPtr: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: VectorRuntimeEffectChildPtr) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[RuntimeEffectChildPtr]: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: RuntimeEffectChildPtr) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: VectorRuntimeEffectChildPtr) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: RuntimeEffectChildPtr) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: VectorRuntimeEffectChildPtr) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: RuntimeEffectChildPtr) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> RuntimeEffectChildPtr:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> RuntimeEffectChildPtr:
        """
        Remove and return the item at index ``i``
        """

class Vertices:
    """

    An immutable set of vertex data that can be used with
    :py:meth:`Canvas.drawVertices`.

    """
    class VertexMode:
        """
        Members:

          kTriangles_VertexMode

          kTriangleStrip_VertexMode

          kTriangleFan_VertexMode

          kLast_VertexMode
        """

        __members__: typing.ClassVar[
            dict[str, Vertices.VertexMode]
        ]  # value = {'kTriangles_VertexMode': <VertexMode.kTriangles_VertexMode: 0>, 'kTriangleStrip_VertexMode': <VertexMode.kTriangleStrip_VertexMode: 1>, 'kTriangleFan_VertexMode': <VertexMode.kTriangleFan_VertexMode: 2>, 'kLast_VertexMode': <VertexMode.kTriangleFan_VertexMode: 2>}
        kLast_VertexMode: typing.ClassVar[
            Vertices.VertexMode
        ]  # value = <VertexMode.kTriangleFan_VertexMode: 2>
        kTriangleFan_VertexMode: typing.ClassVar[
            Vertices.VertexMode
        ]  # value = <VertexMode.kTriangleFan_VertexMode: 2>
        kTriangleStrip_VertexMode: typing.ClassVar[
            Vertices.VertexMode
        ]  # value = <VertexMode.kTriangleStrip_VertexMode: 1>
        kTriangles_VertexMode: typing.ClassVar[
            Vertices.VertexMode
        ]  # value = <VertexMode.kTriangles_VertexMode: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    kLast_VertexMode: typing.ClassVar[
        Vertices.VertexMode
    ]  # value = <VertexMode.kTriangleFan_VertexMode: 2>
    kTriangleFan_VertexMode: typing.ClassVar[
        Vertices.VertexMode
    ]  # value = <VertexMode.kTriangleFan_VertexMode: 2>
    kTriangleStrip_VertexMode: typing.ClassVar[
        Vertices.VertexMode
    ]  # value = <VertexMode.kTriangleStrip_VertexMode: 1>
    kTriangles_VertexMode: typing.ClassVar[
        Vertices.VertexMode
    ]  # value = <VertexMode.kTriangles_VertexMode: 0>
    @staticmethod
    def MakeCopy(
        mode: Vertices.VertexMode,
        positions: list[Point],
        texs: typing.Any = None,
        colors: typing.Any = None,
        indices: typing.Any = None,
    ) -> Vertices:
        """
        Create a vertices by copying the specified arrays.

        :param skia.Vertices.VertexMode mode: vertex mode
        :param List[skia.Point] positions: List of points
        :param List[skia.Point] texs: List of texs; may be None
        :param List[int] colors: List of colors; may be None
        :param List[int] indices: Optional list of indices; may be None
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(
        self,
        mode: Vertices.VertexMode,
        positions: list[Point],
        texs: typing.Any = None,
        colors: typing.Any = None,
        indices: typing.Any = None,
    ) -> None:
        """
        Create a vertices by copying the specified arrays.

        :param skia.Vertices.VertexMode mode: vertex mode
        :param List[skia.Point] positions: List of points
        :param List[skia.Point] texs: List of texs; may be None
        :param List[int] colors: List of colors; may be None
        :param List[int] indices: Optional list of indices; may be None
        """
    def approximateSize(self) -> int: ...
    def bounds(self) -> Rect: ...
    def deref(self) -> None: ...
    def ref(self) -> None: ...
    def refCntGreaterThan(self, count: int) -> bool: ...
    def unique(self) -> bool: ...
    def uniqueID(self) -> int: ...
    def unref(self) -> None: ...

class VkFormat:
    """
    Members:
    """

    __members__: typing.ClassVar[dict] = {}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VkImageLayout:
    """
    Members:
    """

    __members__: typing.ClassVar[dict] = {}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class WStream:
    """

    .. rubric:: Subclasses

    .. autosummary::
        :nosignatures:

        ~FILEWStream
        ~DynamicMemoryWStream

    """
    @staticmethod
    def SizeOfPackedUInt(value: int) -> int: ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def bytesWritten(self) -> int: ...
    def flush(self) -> None:
        """
        Reimplemented in :py:class:`FILEWStream`, and :py:class:`NullWStream`.
        """
    def newline(self) -> bool: ...
    def write(self, buffer: typing_extensions.Buffer) -> bool:
        """
        Called to write bytes to a :py:class:`WStream`.

        Returns true on success

        :param buffer:  the address of at least size bytes to be written to the
            stream
        :param size:    The number of bytes in buffer to write to the stream
        :return: true on success

        Implemented in :py:class:`DynamicMemoryWStream`,
            :py:class:`FILEWStream`, and :py:class:`NullWStream`.
        """
    def write16(self, value: int) -> bool: ...
    def write32(self, value: int) -> bool: ...
    def write8(self, value: int) -> bool: ...
    def writeBigDecAsText(self, value: int, minDigits: int = 0) -> bool: ...
    def writeBool(self, value: bool) -> bool: ...
    def writeDecAsText(self, value: int) -> bool: ...
    def writeHexAsText(self, value: int, minDigits: int = 0) -> bool: ...
    def writePackedUInt(self, value: int) -> bool: ...
    def writeScalar(self, value: float) -> bool: ...
    def writeScalarAsText(self, value: float) -> bool: ...
    def writeStream(self, input: Stream, length: int) -> bool: ...
    def writeText(self, text: str) -> bool: ...

class YUVAInfo:
    """

    Specifies the structure of planes for a YUV image with optional alpha. The
    actual planar data is not part of this structure and depending on usage is
    in external textures or pixmaps.

    """
    class PlaneConfig:
        """

            Specifies how YUV (and optionally A) are divided among planes. Planes are separated by
            underscores in the enum value names. Within each plane the pixmap/texture channels are
            mapped to the YUVA channels in the order specified, e.g. for kY_UV Y is in channel 0 of plane
            0, U is in channel 0 of plane 1, and V is in channel 1 of plane 1. Channel ordering
            within a pixmap/texture given the channels it contains:
            A:                       0:A
            Luminance/Gray:          0:Gray
            Luminance/Gray + Alpha:  0:Gray, 1:A
            RG                       0:R,    1:G
            RGB                      0:R,    1:G, 2:B
            RGBA                     0:R,    1:G, 2:B, 3:A


        Members:

          kUnknown :

          kY_U_V : Plane 0: Y, Plane 1: U,  Plane 2: V

          kY_V_U : < Plane 0: Y, Plane 1: V,  Plane 2: U

          kY_UV : Plane 0: Y, Plane 1: UV

          kY_VU : Plane 0: Y, Plane 1: VU

          kYUV : Plane 0: YUV

          kUYV : Plane 0: UYV

          kY_U_V_A : Plane 0: Y, Plane 1: U,  Plane 2: V, Plane 3: A

          kY_V_U_A : Plane 0: Y, Plane 1: V,  Plane 2: U, Plane 3: A

          kY_UV_A : Plane 0: Y, Plane 1: UV, Plane 2: A

          kY_VU_A : Plane 0: Y, Plane 1: VU, Plane 2: A

          kYUVA : Plane 0: YUVA

          kUYVA : Plane 0: UYVA
        """

        __members__: typing.ClassVar[
            dict[str, YUVAInfo.PlaneConfig]
        ]  # value = {'kUnknown': <PlaneConfig.kUnknown: 0>, 'kY_U_V': <PlaneConfig.kY_U_V: 1>, 'kY_V_U': <PlaneConfig.kY_V_U: 2>, 'kY_UV': <PlaneConfig.kY_UV: 3>, 'kY_VU': <PlaneConfig.kY_VU: 4>, 'kYUV': <PlaneConfig.kYUV: 5>, 'kUYV': <PlaneConfig.kUYV: 6>, 'kY_U_V_A': <PlaneConfig.kY_U_V_A: 7>, 'kY_V_U_A': <PlaneConfig.kY_V_U_A: 8>, 'kY_UV_A': <PlaneConfig.kY_UV_A: 9>, 'kY_VU_A': <PlaneConfig.kY_VU_A: 10>, 'kYUVA': <PlaneConfig.kYUVA: 11>, 'kUYVA': <PlaneConfig.kUYVA: 12>}
        kUYV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kUYV: 6>
        kUYVA: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kUYVA: 12>
        kUnknown: typing.ClassVar[
            YUVAInfo.PlaneConfig
        ]  # value = <PlaneConfig.kUnknown: 0>
        kYUV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kYUV: 5>
        kYUVA: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kYUVA: 11>
        kY_UV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_UV: 3>
        kY_UV_A: typing.ClassVar[
            YUVAInfo.PlaneConfig
        ]  # value = <PlaneConfig.kY_UV_A: 9>
        kY_U_V: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_U_V: 1>
        kY_U_V_A: typing.ClassVar[
            YUVAInfo.PlaneConfig
        ]  # value = <PlaneConfig.kY_U_V_A: 7>
        kY_VU: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_VU: 4>
        kY_VU_A: typing.ClassVar[
            YUVAInfo.PlaneConfig
        ]  # value = <PlaneConfig.kY_VU_A: 10>
        kY_V_U: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_V_U: 2>
        kY_V_U_A: typing.ClassVar[
            YUVAInfo.PlaneConfig
        ]  # value = <PlaneConfig.kY_V_U_A: 8>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Siting:
        """

            Describes how subsampled chroma values are sited relative to luma values.

            Currently only centered siting is supported but will expand to support
            additional sitings.


        Members:

          kCentered :
                Subsampled chroma value is sited at the center of the block of
                corresponding luma values.

        """

        __members__: typing.ClassVar[
            dict[str, YUVAInfo.Siting]
        ]  # value = {'kCentered': <Siting.kCentered: 0>}
        kCentered: typing.ClassVar[YUVAInfo.Siting]  # value = <Siting.kCentered: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Subsampling:
        """

            UV subsampling is also specified in the enum value names using J:a:b notation (e.g. 4:2:0 is
            1/2 horizontal and 1/2 vertical resolution for U and V). If alpha is present it is not sub-
            sampled. Note that Subsampling values other than k444 are only valid with PlaneConfig values
            that have U and V in different planes than Y (and A, if present).


        Members:

          kUnknown

          k444

          k422

          k420

          k440

          k411

          k410
        """

        __members__: typing.ClassVar[
            dict[str, YUVAInfo.Subsampling]
        ]  # value = {'kUnknown': <Subsampling.kUnknown: 0>, 'k444': <Subsampling.k444: 1>, 'k422': <Subsampling.k422: 2>, 'k420': <Subsampling.k420: 3>, 'k440': <Subsampling.k440: 4>, 'k411': <Subsampling.k411: 5>, 'k410': <Subsampling.k410: 6>}
        k410: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k410: 6>
        k411: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k411: 5>
        k420: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k420: 3>
        k422: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k422: 2>
        k440: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k440: 4>
        k444: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k444: 1>
        kUnknown: typing.ClassVar[
            YUVAInfo.Subsampling
        ]  # value = <Subsampling.kUnknown: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    __hash__: typing.ClassVar[None] = None
    k410: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k410: 6>
    k411: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k411: 5>
    k420: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k420: 3>
    k422: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k422: 2>
    k440: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k440: 4>
    k444: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.k444: 1>
    kCentered: typing.ClassVar[YUVAInfo.Siting]  # value = <Siting.kCentered: 0>
    kMaxPlanes: typing.ClassVar[int] = 4
    kUYV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kUYV: 6>
    kUYVA: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kUYVA: 12>
    kUnknown: typing.ClassVar[YUVAInfo.Subsampling]  # value = <Subsampling.kUnknown: 0>
    kYUV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kYUV: 5>
    kYUVA: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kYUVA: 11>
    kY_UV: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_UV: 3>
    kY_UV_A: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_UV_A: 9>
    kY_U_V: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_U_V: 1>
    kY_U_V_A: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_U_V_A: 7>
    kY_VU: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_VU: 4>
    kY_VU_A: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_VU_A: 10>
    kY_V_U: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_V_U: 2>
    kY_V_U_A: typing.ClassVar[YUVAInfo.PlaneConfig]  # value = <PlaneConfig.kY_V_U_A: 8>
    @staticmethod
    def HasAlpha(config: YUVAInfo.PlaneConfig) -> bool:
        """
        Does the PlaneConfig have alpha values?
        """
    @staticmethod
    def NumChannelsInPlane(config: YUVAInfo.PlaneConfig, i: int) -> int:
        """
        Number of Y, U, V, A channels in the ith plane for a given PlaneConfig
        (or 0 if i is invalid).
        """
    @staticmethod
    def NumPlanes(config: YUVAInfo.PlaneConfig) -> int:
        """
        Number of planes for a given PlaneConfig.
        """
    @staticmethod
    def PlaneDimensions(
        imageDimensions: ISize,
        config: YUVAInfo.PlaneConfig,
        sampling: YUVAInfo.Subsampling,
        origin: EncodedOrigin,
    ) -> list[ISize]:
        """
        Given image dimensions, a planar configuration, and origin, determine
        the expected size of each plane. Returns a list of expected
        planes.

        The input image dimensions are as displayed (after the planes have
        been transformed to the intended display orientation).
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: YUVAInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        dimensions: ISize,
        config: YUVAInfo.PlaneConfig,
        sampling: YUVAInfo.Subsampling,
        yuvColorSpace: YUVColorSpace,
        origin: EncodedOrigin = ...,
        sittingX: YUVAInfo.Siting = ...,
        sittingY: YUVAInfo.Siting = ...,
    ) -> None:
        """
        'dimensions' should specify the size of the full resolution image (after
        planes have been oriented to how the image is displayed as indicated by
        'origin').
        """
    def __ne__(self, arg0: YUVAInfo) -> bool: ...
    def computeTotalBytes(
        self,
        rowBytes: list[int],
        returnPlaneSizes: bool = False,
    ) -> typing.Any:
        """
        Given a per-plane row bytes, determine size to allocate for all
        planes. Optionally retrieves the per-plane byte sizes if
        returnPlaneSizes is True. If total size overflows will return SIZE_MAX
        and set all planeSizes to SIZE_MAX.
        """
    def dimensions(self) -> ISize:
        """
        Dimensions of the full resolution image (after planes have been oriented
        to how the image is displayed as indicated by fOrigin).
        """
    def hasAlpha(self) -> bool: ...
    def height(self) -> int: ...
    def numChannelsInPlane(self, i: int) -> int: ...
    def numPlanes(self) -> int: ...
    def origin(self) -> EncodedOrigin: ...
    def planeConfig(self) -> YUVAInfo.PlaneConfig: ...
    def planeDimensions(self) -> list[ISize]:
        """
        Returns the number of planes and initializes
        planeDimensions[0]..planeDimensions[<ret>] to the expected dimensions
        for each plane. Dimensions are as stored in memory, before
        transformation to image display space as indicated by origin().
        """
    def sitingX(self) -> YUVAInfo.Siting: ...
    def sitingY(self) -> YUVAInfo.Siting: ...
    def subSampling(self) -> YUVAInfo.Subsampling: ...
    def width(self) -> int: ...
    def yuvColorSpace(self) -> YUVColorSpace: ...

class YUVAPixmapInfo:
    """

    :py:class:`~skia.YUVAInfo` combined with per-plane
    :py:class:`~skia.ColorType` and row bytes. Fully specifies the
    :py:class:`~skia.Pixmaps` for a YUVA image without the actual pixel memory
    and data.

    """
    class DataType:
        """

            Data type for Y, U, V, and possibly A channels independent of how values are
            packed into planes.


        Members:

          kUnorm8 : 8 bit unsigned normalized

          kUnorm16 : 16 bit unsigned normalized

          kFloat16 : 16 bit (half) floating point

          kUnorm10_Unorm2 : 10 bit unorm for Y, U, and V. 2 bit unorm for alpha (if present).

          kLast
        """

        __members__: typing.ClassVar[
            dict[str, YUVAPixmapInfo.DataType]
        ]  # value = {'kUnorm8': <DataType.kUnorm8: 0>, 'kUnorm16': <DataType.kUnorm16: 1>, 'kFloat16': <DataType.kFloat16: 2>, 'kUnorm10_Unorm2': <DataType.kUnorm10_Unorm2: 3>, 'kLast': <DataType.kUnorm10_Unorm2: 3>}
        kFloat16: typing.ClassVar[
            YUVAPixmapInfo.DataType
        ]  # value = <DataType.kFloat16: 2>
        kLast: typing.ClassVar[
            YUVAPixmapInfo.DataType
        ]  # value = <DataType.kUnorm10_Unorm2: 3>
        kUnorm10_Unorm2: typing.ClassVar[
            YUVAPixmapInfo.DataType
        ]  # value = <DataType.kUnorm10_Unorm2: 3>
        kUnorm16: typing.ClassVar[
            YUVAPixmapInfo.DataType
        ]  # value = <DataType.kUnorm16: 1>
        kUnorm8: typing.ClassVar[
            YUVAPixmapInfo.DataType
        ]  # value = <DataType.kUnorm8: 0>
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SupportedDataTypes:
        @staticmethod
        def All() -> YUVAPixmapInfo.SupportedDataTypes:
            """
            All legal combinations of PlanarConfig and DataType are supported.
            """
        @staticmethod
        def _pybind11_conduit_v1_(*args, **kwargs): ...
        def __init__(self) -> None:
            """
            Defaults to nothing supported.
            """
        def enableDataType(
            self,
            dataType: YUVAPixmapInfo.DataType,
            numChannels: int,
        ) -> None:
            """
            Update to add support for pixmaps with numChannel channels where each
            channel is represented as DataType.
            """
        def supported(
            self,
            planarConfig: YUVAInfo.PlaneConfig,
            dataType: YUVAPixmapInfo.DataType,
        ) -> bool:
            """
            Checks whether there is a supported combination of color types for
            planes structured as indicated by PlanarConfig with channel data types
            as indicated by DataType.
            """

    __hash__: typing.ClassVar[None] = None
    kFloat16: typing.ClassVar[YUVAPixmapInfo.DataType]  # value = <DataType.kFloat16: 2>
    kLast: typing.ClassVar[
        YUVAPixmapInfo.DataType
    ]  # value = <DataType.kUnorm10_Unorm2: 3>
    kMaxPlanes: typing.ClassVar[int] = 4
    kUnorm10_Unorm2: typing.ClassVar[
        YUVAPixmapInfo.DataType
    ]  # value = <DataType.kUnorm10_Unorm2: 3>
    kUnorm16: typing.ClassVar[YUVAPixmapInfo.DataType]  # value = <DataType.kUnorm16: 1>
    kUnorm8: typing.ClassVar[YUVAPixmapInfo.DataType]  # value = <DataType.kUnorm8: 0>
    @staticmethod
    def DefaultColorTypeForDataType(
        dataType: YUVAPixmapInfo.DataType,
        numChannels: int,
    ) -> ColorType:
        """
        Gets the default SkColorType to use with numChannels channels, each
        represented as DataType. Returns kUnknown_SkColorType if no such color
        type.
        """
    @staticmethod
    def NumChannelsAndDataType(
        colorType: ColorType,
    ) -> tuple[int, YUVAPixmapInfo.DataType]:
        """
        If the :py:class:`ColorType` is supported for YUVA pixmaps this will
        return the number of YUVA channels that can be stored in a plane of
        this color type and what the DataType is of those channels. If the
        :py:class:`ColorType` is not supported as a YUVA plane the number of
        channels is reported as 0 and the DataType returned should be
        ignored.
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, arg0: YUVAPixmapInfo) -> bool: ...
    @typing.overload
    def __init__(self) -> None:
        """
        Default SkYUVAPixmapInfo is invalid.
        """
    @typing.overload
    def __init__(
        self,
        info: YUVAInfo,
        colorType: list[ColorType],
        rowBytes: typing.Any = None,
    ) -> None:
        """
        Initializes the :py:class:`YUVAPixmapInfo` from a :py:class:`YUVAInfo`
        with per-plane color types and row bytes. This will be invalid if the
        colorTypes aren't compatible with the :py:class:`YUVAInfo` or if a
        rowBytes entry is not valid for the plane dimensions and color type.
        Color type and row byte values beyond the number of planes in
        :py:class:`YUVAInfo` are ignored. All :py:class:`ColorTypes` must have
        the same DataType or this will be invalid.

        If rowBytes is nullptr then ``bpp*width`` is assumed for each plane.
        """
    @typing.overload
    def __init__(
        self,
        info: YUVAInfo,
        dataType: YUVAPixmapInfo.DataType,
        rowBytes: typing.Any = None,
    ) -> None:
        """
        Like above but uses DefaultColorTypeForDataType to determine each
        plane's :py:class:`ColorType`. If rowBytes is nullptr then bpp*width is
        assumed for each plane.
        """
    def __ne__(self, arg0: YUVAPixmapInfo) -> bool: ...
    def computeTotalBytes(self, returnPlaneSizes: bool = False) -> typing.Any:
        """
        Determine size to allocate for all planes. Optionally returns the
        per-plane sizes if returnPlaneSizes is True. If total size overflows
        will return SIZE_MAX and set all planeSizes to SIZE_MAX. Returns 0 and
        fills planesSizes with 0 if this :py:class:`YUVAPixmapInfo` is not
        valid.
        """
    def dataType(self) -> YUVAPixmapInfo.DataType:
        """
        The per-YUV[A] channel data type.
        """
    def initPixmapsFromSingleAllocation(
        self,
        memory: typing_extensions.Buffer,
    ) -> list[Pixmap]:
        """
        Takes an allocation that is assumed to be at least
        :py:meth:`computeTotalBytes` in size and configures the first
        :py:meth:`numPlanes` entries in pixmaps array to point into that
        memory. The remaining entries of pixmaps are default initialized.
        Fails if this :py:class:`YUVAPixmapInfo` not valid.

        :param memory: Buffer that is at least  :py:meth:`computeTotalBytes` in
            size.
        :rtype: List[skia.Pixmap]
        """
    def isSupported(
        self,
        supportedDataTypes: YUVAPixmapInfo.SupportedDataTypes,
    ) -> bool:
        """
        Is this valid and does it use color types allowed by the passed
        :py:class:`SupportedDataTypes`?
        """
    def isValid(self) -> bool:
        """
        Returns true if this has been configured with a non-empty dimensioned
        :py:class:`YUVAInfo` with compatible color types and row bytes.
        """
    def numPlanes(self) -> int:
        """
        The number of :py:class:`Pixmap` planes, 0 if this
        :py:class:`YUVAPixmapInfo` is invalid.
        """
    def planeInfo(self, i: int) -> ImageInfo:
        """
        Image info for the ith plane, or default :py:class:`ImageInfo` if
        ``i >= numPlanes()``
        """
    def rowBytes(self, i: int) -> int:
        """
        Row bytes for the ith plane. Returns zero if ``i >= numPlanes()`` or
        this :py:class:`YUVAPixmapInfo` is invalid.
        """
    def yuvColorSpace(self) -> YUVColorSpace: ...
    def yuvaInfo(self) -> YUVAInfo: ...

class YUVAPixmaps:
    """

    Helper to store :py:class:`Pixmap` planes as described by a
    :py:class:`YUVAPixmapInfo`. Can be responsible for
    allocating/freeing memory for pixmaps or use external memory.

    """
    @staticmethod
    def Allocate(yuvaPixmapInfo: YUVAPixmapInfo) -> YUVAPixmaps:
        """
        Allocate space for pixmaps' pixels in the :py:class:`YUVAPixmaps`.
        """
    @staticmethod
    def FromData(yuvaPixmapInfo: YUVAPixmapInfo, data: Data) -> YUVAPixmaps:
        """
        Use storage in :py:class:`Data` as backing store for pixmaps' pixels.
        :py:class:`Data` is retained by the :py:class:`YUVAPixmaps`.
        """
    @staticmethod
    def FromExternalMemory(
        yuvaPixmapInfo: YUVAPixmapInfo,
        memory: typing_extensions.Buffer,
    ) -> YUVAPixmaps:
        """
        Use passed in memory as backing store for pixmaps' pixels. Caller must
        ensure memory remains allocated while pixmaps are in use. There must be
        at least :py:meth:`YUVAPixmapInfo.computeTotalBytes` allocated starting
        at memory.
        """
    @staticmethod
    def FromExternalPixmaps(yuvaInfo: YUVAInfo, pixmaps: list[Pixmap]) -> YUVAPixmaps:
        """
        Wraps existing :py:class:`Pixmap`. The :py:class:`YUVAPixmaps` will
        have no ownership of the :py:class:`Pixmap`' pixel memory so the
        caller must ensure it remains valid. Will return an invalid
        :py:class:`YUVAPixmaps` if the :py:class:`YUVAInfo` isn't compatible
        with the :py:class:`Pixmap` array (number of planes, plane dimensions,
        sufficient color channels in planes, ...).
        """
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def isValid(self) -> bool:
        """
        Does have initialized pixmaps compatible with its :py:class:`YUVAInfo`.
        """
    def numPlanes(self) -> int:
        """
        Number of pixmap planes or 0 if this :py:class:`YUVAPixmaps` is invalid.
        """
    def plane(self, i: int) -> Pixmap:
        """
        Get the ith :py:class:`Pixmap` plane. :py:class:`Pixmap` will be default
        initialized if i >= numPlanes or this :py:class:`YUVAPixmaps` is
        invalid.
        """
    def planes(self) -> list[Pixmap]:  # FixedSize(4)
        """
        Access the :py:class:`Pixmap` planes. They are default initialized if
        this is not a valid :py:class:`YUVAPixmaps`.
        """
    def yuvaInfo(self) -> YUVAInfo: ...

class YUVColorSpace:
    """
    Members:

      kJPEG_YUVColorSpace : describes full range

      kRec601_YUVColorSpace : describes SDTV range

      kRec709_YUVColorSpace : describes HDTV range

      kBT2020_YUVColorSpace : describes UHDTV range, non-constant-luminance

      kIdentity_YUVColorSpace : maps Y->R, U->G, V->B

      kLastEnum_YUVColorSpace : last valid value
    """

    __members__: typing.ClassVar[
        dict[str, YUVColorSpace]
    ]  # value = {'kJPEG_YUVColorSpace': <YUVColorSpace.kJPEG_YUVColorSpace: 0>, 'kRec601_YUVColorSpace': <YUVColorSpace.kRec601_YUVColorSpace: 1>, 'kRec709_YUVColorSpace': <YUVColorSpace.kRec709_YUVColorSpace: 3>, 'kBT2020_YUVColorSpace': <YUVColorSpace.kBT2020_YUVColorSpace: 5>, 'kIdentity_YUVColorSpace': <YUVColorSpace.kIdentity_YUVColorSpace: 28>, 'kLastEnum_YUVColorSpace': <YUVColorSpace.kIdentity_YUVColorSpace: 28>}
    kBT2020_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kBT2020_YUVColorSpace: 5>
    kIdentity_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kIdentity_YUVColorSpace: 28>
    kJPEG_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kJPEG_YUVColorSpace: 0>
    kLastEnum_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kIdentity_YUVColorSpace: 28>
    kRec601_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kRec601_YUVColorSpace: 1>
    kRec709_YUVColorSpace: typing.ClassVar[
        YUVColorSpace
    ]  # value = <YUVColorSpace.kRec709_YUVColorSpace: 3>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class _AutoDocumentPage:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __enter__(self) -> Canvas: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class gpuBackendApi:
    """

        Possible 3D APIs that may be used by Graphite.


    Members:

      kDawn

      kMetal

      kVulkan

      kMock
    """

    __members__: typing.ClassVar[
        dict[str, gpuBackendApi]
    ]  # value = {'kDawn': <gpuBackendApi.kDawn: 0>, 'kMetal': <gpuBackendApi.kMetal: 1>, 'kVulkan': <gpuBackendApi.kVulkan: 2>, 'kMock': <gpuBackendApi.kMock: 3>}
    kDawn: typing.ClassVar[gpuBackendApi]  # value = <gpuBackendApi.kDawn: 0>
    kMetal: typing.ClassVar[gpuBackendApi]  # value = <gpuBackendApi.kMetal: 1>
    kMock: typing.ClassVar[gpuBackendApi]  # value = <gpuBackendApi.kMock: 3>
    kVulkan: typing.ClassVar[gpuBackendApi]  # value = <gpuBackendApi.kVulkan: 2>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class textlayout_FontCollection(RefCnt):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    @typing.overload
    def setDefaultFontManager(self, fontManager: FontMgr) -> None: ...
    @typing.overload
    def setDefaultFontManager(
        self,
        fontManager: FontMgr,
        defaultFamilyName: str,
    ) -> None: ...
    @typing.overload
    def setDefaultFontManager(
        self,
        fontManager: FontMgr,
        defaultFamilyNames: list[String],
    ) -> None: ...

class textlayout_Paragraph:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def layout(self, width: float) -> None: ...
    def paint(self, canvas: Canvas, x: float, y: float) -> None: ...
    @property
    def AlphabeticBaseline(self) -> float: ...
    @property
    def ExceedMaxLines(self) -> bool: ...
    @property
    def Height(self) -> float: ...
    @property
    def IdeographicBaseline(self) -> float: ...
    @property
    def LongestLine(self) -> float: ...
    @property
    def MaxIntrinsicWidth(self) -> float: ...
    @property
    def MinIntrinsicWidth(self) -> float: ...
    @property
    def Width(self) -> float: ...

class textlayout_ParagraphBuilder:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    @staticmethod
    def make(
        style: textlayout_ParagraphStyle,
        fontCollection: textlayout_FontCollection,
        unicode: Unicode,
    ) -> textlayout_ParagraphBuilder: ...
    def Build(self) -> textlayout_Paragraph: ...
    def __init__(
        self,
        style: textlayout_ParagraphStyle,
        fontCollection: textlayout_FontCollection,
        unicode: Unicode,
    ) -> None: ...
    def addText(self, text: str) -> None: ...
    def pop(self) -> None: ...
    def pushStyle(self, style: textlayout_TextStyle) -> None: ...

class textlayout_ParagraphStyle:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def setTextAlign(self, align: textlayout_TextAlign) -> None: ...
    def setTextStyle(self, textstyle: textlayout_TextStyle) -> None: ...

class textlayout_TextAlign:
    """



    Members:

      kLeft

      kRight

      kCenter

      kJustify

      kStart

      kEnd
    """

    __members__: typing.ClassVar[
        dict[str, textlayout_TextAlign]
    ]  # value = {'kLeft': <textlayout_TextAlign.kLeft: 0>, 'kRight': <textlayout_TextAlign.kRight: 1>, 'kCenter': <textlayout_TextAlign.kCenter: 2>, 'kJustify': <textlayout_TextAlign.kJustify: 3>, 'kStart': <textlayout_TextAlign.kStart: 4>, 'kEnd': <textlayout_TextAlign.kEnd: 5>}
    kCenter: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kCenter: 2>
    kEnd: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kEnd: 5>
    kJustify: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kJustify: 3>
    kLeft: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kLeft: 0>
    kRight: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kRight: 1>
    kStart: typing.ClassVar[
        textlayout_TextAlign
    ]  # value = <textlayout_TextAlign.kStart: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class textlayout_TextDecoration:
    """



    Members:

      kNoDecoration

      kUnderline

      kOverline

      kLineThrough

      kUnderlineOverline

      kUnderlineLineThrough

      kOverlineLineThrough

      kUnderlineOverlineLineThrough
    """

    __members__: typing.ClassVar[
        dict[str, textlayout_TextDecoration]
    ]  # value = {'kNoDecoration': <textlayout_TextDecoration.kNoDecoration: 0>, 'kUnderline': <textlayout_TextDecoration.kUnderline: 1>, 'kOverline': <textlayout_TextDecoration.kOverline: 2>, 'kLineThrough': <textlayout_TextDecoration.kLineThrough: 4>, 'kUnderlineOverline': <textlayout_TextDecoration.kUnderlineOverline: 3>, 'kUnderlineLineThrough': <textlayout_TextDecoration.kUnderlineLineThrough: 5>, 'kOverlineLineThrough': <textlayout_TextDecoration.kOverlineLineThrough: 6>, 'kUnderlineOverlineLineThrough': <textlayout_TextDecoration.kUnderlineOverlineLineThrough: 7>}
    kLineThrough: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kLineThrough: 4>
    kNoDecoration: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kNoDecoration: 0>
    kOverline: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kOverline: 2>
    kOverlineLineThrough: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kOverlineLineThrough: 6>
    kUnderline: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kUnderline: 1>
    kUnderlineLineThrough: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kUnderlineLineThrough: 5>
    kUnderlineOverline: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kUnderlineOverline: 3>
    kUnderlineOverlineLineThrough: typing.ClassVar[
        textlayout_TextDecoration
    ]  # value = <textlayout_TextDecoration.kUnderlineOverlineLineThrough: 7>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class textlayout_TextDecorationMode:
    """



    Members:

      kGaps

      kThrough
    """

    __members__: typing.ClassVar[
        dict[str, textlayout_TextDecorationMode]
    ]  # value = {'kGaps': <textlayout_TextDecorationMode.kGaps: 0>, 'kThrough': <textlayout_TextDecorationMode.kThrough: 1>}
    kGaps: typing.ClassVar[
        textlayout_TextDecorationMode
    ]  # value = <textlayout_TextDecorationMode.kGaps: 0>
    kThrough: typing.ClassVar[
        textlayout_TextDecorationMode
    ]  # value = <textlayout_TextDecorationMode.kThrough: 1>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class textlayout_TextDecorationStyle:
    """



    Members:

      kSolid

      kDouble

      kDotted

      kDashed

      kWavy
    """

    __members__: typing.ClassVar[
        dict[str, textlayout_TextDecorationStyle]
    ]  # value = {'kSolid': <textlayout_TextDecorationStyle.kSolid: 0>, 'kDouble': <textlayout_TextDecorationStyle.kDouble: 1>, 'kDotted': <textlayout_TextDecorationStyle.kDotted: 2>, 'kDashed': <textlayout_TextDecorationStyle.kDashed: 3>, 'kWavy': <textlayout_TextDecorationStyle.kWavy: 4>}
    kDashed: typing.ClassVar[
        textlayout_TextDecorationStyle
    ]  # value = <textlayout_TextDecorationStyle.kDashed: 3>
    kDotted: typing.ClassVar[
        textlayout_TextDecorationStyle
    ]  # value = <textlayout_TextDecorationStyle.kDotted: 2>
    kDouble: typing.ClassVar[
        textlayout_TextDecorationStyle
    ]  # value = <textlayout_TextDecorationStyle.kDouble: 1>
    kSolid: typing.ClassVar[
        textlayout_TextDecorationStyle
    ]  # value = <textlayout_TextDecorationStyle.kSolid: 0>
    kWavy: typing.ClassVar[
        textlayout_TextDecorationStyle
    ]  # value = <textlayout_TextDecorationStyle.kWavy: 4>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class textlayout_TextStyle:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs): ...
    def __init__(self) -> None: ...
    def cloneForPlaceholder(self) -> textlayout_TextStyle: ...
    def setColor(self, color: int) -> None: ...
    def setDecoration(self, decoration: textlayout_TextDecoration) -> None: ...
    def setDecorationColor(self, color: int) -> None: ...
    def setDecorationMode(self, mode: textlayout_TextDecorationMode) -> None: ...
    def setDecorationStyle(self, style: textlayout_TextDecorationStyle) -> None: ...
    def setDecorationThicknessMultiplier(self, m: float) -> None: ...
    def setFontFamilies(self, families: list[String] | list[str]) -> None: ...
    def setFontSize(self, size: float) -> None: ...
    def setFontStyle(self, fontStyle: FontStyle) -> None: ...
    def setForegroundColor(self, paint: Paint) -> None:
        """
        DEPRECATED: prefer `setForegroundPaint`
        """
    def setForegroundPaint(self, paint: Paint) -> None: ...
    def setLocale(self, locale: String | str) -> None: ...

def AlphaTypeIsOpaque(at: AlphaType) -> bool:
    """
    Returns true if :py:class:`AlphaType` equals
    :py:attr:`~skia.AlphaType.kOpaque_AlphaType`.

    :py:attr:`~skia.AlphaType.kOpaque_AlphaType` is a hint that the
    :py:class:`ColorType` is opaque, or that all alpha values are set to their
    1.0 equivalent. If :py:class:`AlphaType` is
    :py:attr:`~skia.AlphaType.kOpaque_AlphaType`, and :py:class:`ColorType` is
    not opaque, then the result of drawing any pixel with a alpha value less
    than 1.0 is undefined.
    """

def AsWinding(path: Path) -> Path:
    """
    Set the result with fill type winding to area equivalent to path.

    Returns true if successful. Does not detect if path contains contours which
    contain self-crossings or cross other contours; in these cases, may return
    true even though result does not fill same area as path.

    Returns if operation was able to produce a result; otherwise, throws a
    runtime error. The result may be the input.

    :param path:  The path typically with fill type set to even odd.
    :return:      The equivalent path with fill type set to winding.
    """

def BlendMode_AsCoeff(
    mode: BlendMode,
    src: BlendModeCoeff,
    dst: BlendModeCoeff,
) -> bool:
    """
    Returns true if 'mode' is a coefficient-based blend mode (<=
    kLastCoeffMode).

    If true is returned, the mode's src and dst coefficient functions are set in
    'src' and 'dst'.
    """

def BlendMode_Name(blendMode: BlendMode) -> str:
    """
    Returns name of blendMode as null-terminated C string.
    """

def Color(r: int, g: int, b: int, a: int = 255) -> int:
    """
    Returns color value from 8-bit component values.

    In Skia, colors are represented as 32-bit ARGB word, where each component
    has 8-bit. Colors can be specified by Python literal or constructed from the
    functions.

    Floating point representation is available via :py:class:`Color4f`.

    Example::

        c = 0xFFFF0000  # ARGB
        c = skia.Color(255, 0, 0)  # RGB
        c = skia.Color(255, 0, 0, 255)  # RGBA
        c = skia.ColorSetRGB(255, 255, 0, 0)  # RGB
        c = skia.ColorSetARGB(255, 255, 0, 0)  # ARGB

    Asserts if SK_DEBUG is defined if a, r, g, or b exceed 255. Since color is
    unpremultiplied, a may be smaller than the largest of r, g, and b.

    :param int r: amount of red, from no red (0) to full red (255)
    :param int g: amount of green, from no green (0) to full green (255)
    :param int b: amount of blue, from no blue (0) to full blue (255)
    :param int a: amount of alpha, from fully transparent (0) to fully opaque
        (255)
    :return: color and alpha, unpremultiplied
    """

def ColorGetA(color: int) -> int:
    """
    Returns alpha byte from color value.
    """

def ColorGetB(color: int) -> int:
    """
    Returns blue component of color, from zero to 255.
    """

def ColorGetG(color: int) -> int:
    """
    Returns green component of color, from zero to 255.
    """

def ColorGetR(color: int) -> int:
    """
    Returns red component of color, from zero to 255.
    """

def ColorSetA(c: int, a: int) -> int:
    """
    Returns unpremultiplied color with red, blue, and green set from c; and
    alpha set from a.

    Alpha component of c is ignored and is replaced by a in result.

    :param int c: packed RGB, eight bits per component
    :param int a: alpha: transparent at zero, fully opaque at 255
    :return: color with transparency
    """

def ColorSetARGB(a: int, r: int, g: int, b: int) -> int:
    """
    Returns color value from 8-bit component values.

    Asserts if SK_DEBUG is defined if a, r, g, or b exceed 255. Since color is
    unpremultiplied, a may be smaller than the largest of r, g, and b.

    :param int a: amount of alpha, from fully transparent (0) to fully opaque
        (255)
    :param int r: amount of red, from no red (0) to full red (255)
    :param int g: amount of green, from no green (0) to full green (255)
    :param int b: amount of blue, from no blue (0) to full blue (255)
    :return: color and alpha, unpremultiplied
    """

def ColorSetRGB(r: int, g: int, b: int) -> int:
    """
    Returns color value from 8-bit component values, with alpha set fully opaque
    to 255.
    """

def ColorToHSV(color: int) -> list[float]:
    """
    Converts ARGB to its HSV components.

    Alpha in ARGB is ignored. hsv[0] contains hsv hue, and is assigned a value
    from zero to less than 360. hsv[1] contains hsv saturation, a value from
    zero to one. hsv[2] contains hsv value, a value from zero to one.

    :param int color: ARGB color to convert
    :return: three element array which holds the resulting HSV components
    """

def ColorTypeBytesPerPixel(ct: ColorType) -> int:
    """
    Returns the number of bytes required to store a pixel, including unused
    padding.

    Returns zero if ct is :py:attr:`~skia.Type.kUnknown_ColorType` or invalid.

    :return: bytes per pixel
    """

def ColorTypeIsAlwaysOpaque(ct: ColorType) -> bool:
    """
    Returns true if :py:class:`ColorType` always decodes alpha to 1.0, making
    the pixel fully opaque.

    If true, :py:class:`ColorType` does not reserve bits to encode alpha.

    :return: true if alpha is always set to 1.0
    """

def ColorTypeValidateAlphaType(
    colorType: ColorType,
    alphaType: AlphaType,
    canonical: AlphaType | None = None,
) -> bool:
    """
    Returns true if canonical can be set to a valid :py:class:`AlphaType` for
    colorType.

    If there is more than one valid canonical :py:class:`AlphaType`, set to
    alphaType, if valid. If true is returned and canonical is not nullptr, store
    valid :py:class:`AlphaType`.

    Returns false only if alphaType is :py:attr:`~skia.Type.kUnknown_AlphaType`,
    color type is not :py:attr:`~skia.ColorType.kUnknown_ColorType`, and
    :py:class:`ColorType` is not always opaque. If false is returned, canonical
    is ignored.

    :param colorType: color type
    :param alphaType: alpha type
    :param canonical: output storage for :py:class:`AlphaType`
    :return: true if valid :py:class:`AlphaType` can be associated with
        colorType
    """

def ComputeIsOpaque(bm: Bitmap) -> bool:
    """
    Returns true if all pixels are opaque.

    :py:class:`ColorType` determines how pixels are encoded, and whether pixel
    describes alpha. Returns true for :py:class:`ColorType` without alpha in
    each pixel; for other :py:class:`ColorType`, returns true if all pixels have
    alpha values equivalent to 1.0 or greater.

    For :py:class:`ColorType` :py:attr:`~ColorType.kRGB_565_ColorType` or
    :py:attr:`~ColorType.kGray_8_ColorType`: always returns true. For
    :py:class:`ColorType` :py:attr:`~ColorType.kAlpha_8_ColorType`,
    :py:attr:`~ColorType.kBGRA_8888_ColorType`,
    :py:attr:`~ColorType.kRGBA_8888_ColorType`: returns true if all pixel alpha
    values are 255. For :py:class:`ColorType`
    :py:attr:`~ColorType.kARGB_4444_ColorType`: returns true if all pixel alpha
    values are 15. For :py:attr:`~ColorType.kRGBA_F16_ColorType`: returns true
    if all pixel alpha values are 1.0 or greater.

    Returns false for :py:attr:`~ColorType.kUnknown_ColorType`.

    :param skia.Bitmap bm: :py:class:`Bitmap` to check
    :return: true if all pixels have opaque values or :py:class:`ColorType` is
        opaque
    """

def EncodedOriginToMatrix(origin: EncodedOrigin, w: int, h: int) -> Matrix:
    """
    Given an encoded origin and the width and height of the source data,
    returns a matrix that transforms the source rectangle with upper left
    corner at [0, 0] and origin to a correctly oriented destination rectangle
    of [0, 0, w, h].
    """

def HSVToColor(hsv: list[float], alpha: int = 255) -> int:
    """
    Converts HSV components to an ARGB color.

    Alpha is passed through unchanged. hsv[0] represents hsv hue, an angle from
    zero to less than 360. hsv[1] represents hsv saturation, and varies from
    zero to one. hsv[2] represents hsv value, and varies from zero to one.

    Out of range hsv values are pinned.

    :param hsv: three element array which holds the input HSV components
    :param alpha: alpha component of the returned ARGB color
    :return: ARGB equivalent to HSV
    """

def MakeNullCanvas() -> Canvas: ...
def Op(one: Path, two: Path, op: PathOp) -> Path:
    """
    Set this path to the result of applying the Op to this path and the
    specified path: this = (this op operand).

    The resulting path will be constructed from non-overlapping contours. The
    curve order is reduced where possible so that cubics may be turned into
    quadratics, and quadratics maybe turned into lines.

    Returns if operation was able to produce a result; otherwise, throws a
    runtime error.

    :param one: The first operand (for difference, the minuend)
    :param two: The second operand (for difference, the subtrahend)
    :param op:  The operator to apply.
    :return:  The product of the operands. The result may be one of the inputs.
    """

def PathFillType_ConvertToNonInverse(ft: PathFillType) -> PathFillType: ...
def PathFillType_IsEvenOdd(ft: PathFillType) -> bool: ...
def PathFillType_IsInverse(ft: PathFillType) -> bool: ...
def PreMultiplyARGB(a: int, r: int, g: int, b: int) -> int:
    """
    Returns a SkPMColor value from unpremultiplied 8-bit component values.

    :param a: amount of alpha, from fully transparent (0) to fully opaque (255)
    :param r: amount of red, from no red (0) to full red (255)
    :param g: amount of green, from no green (0) to full green (255)
    :param b: amount of blue, from no blue (0) to full blue (255)
    :return: premultiplied color
    """

def PreMultiplyColor(c: int) -> int:
    """
    Returns pmcolor closest to color c.

    Multiplies c RGB components by the c alpha, and arranges the bytes to match
    the format of kN32_ColorType.

    :param c: unpremultiplied ARGB color
    :return: premultiplied color
    """

def RGBToHSV(red: int, green: int, blue: int) -> list[float]:
    """
    Converts RGB to its HSV components.

    hsv[0] contains hsv hue, a value from zero to less than 360. hsv[1] contains
    hsv saturation, a value from zero to one. hsv[2] contains hsv value, a value
    from zero to one.

    :param int red:   red component value from zero to 255
    :param int green: green component value from zero to 255
    :param int blue:  blue component value from zero to 255
    :return: three element array which holds the resulting HSV components
    """

def Simplify(path: Path) -> Path:
    """
    Set this path to a set of non-overlapping contours that describe the same
    area as the original path.

    The curve order is reduced where possible so that cubics may be turned into
    quadratics, and quadratics maybe turned into lines.

    Returns if operation was able to produce a result; otherwise, throws a
    runtime error.


    :param path: The path to simplify.
    :return: The simplified path. The result may be the input.
    """

def TightBounds(path: Path) -> Rect:
    """
    Set the resulting rectangle to the tight bounds of the path.

    :param path:  The path measured.
    :return:      The tight bounds of the path.
    """

AlphaOPAQUE: int = 255
AlphaTRANSPARENT: int = 0
ColorBLACK: int = 4278190080
ColorBLUE: int = 4278190335
ColorCYAN: int = 4278255615
ColorDKGRAY: int = 4282664004
ColorGRAY: int = 4287137928
ColorGREEN: int = 4278255360
ColorLTGRAY: int = 4291611852
ColorMAGENTA: int = 4294902015
ColorRED: int = 4294901760
ColorTRANSPARENT: int = 0
ColorWHITE: int = 4294967295
ColorYELLOW: int = 4294967040
ScalarInfinity: float  # value = inf
ScalarNegativeInfinity: float  # value = -inf

# Unicodes: types.SimpleNamespace  # value = namespace(ICU=namespace(Make=<built-in method ICU_Make of PyCapsule object at 0x0000027897242EB0>))
class Unicodes:
    def __init__(self) -> typing.NoReturn: ...
    class ICU:
        def __init__(self) -> typing.NoReturn: ...
        @staticmethod
        def Make() -> Unicode: ...

k2D: GrTextureType  # value = <GrTextureType.k2D: 1>
kA: ColorChannel  # value = <ColorChannel.kA: 3>
kA16_float_ColorType: ColorType  # value = <ColorType.kA16_float_ColorType: 20>
kA16_unorm_ColorType: ColorType  # value = <ColorType.kA16_unorm_ColorType: 22>
kABGR_4444: GrColorType  # value = <GrColorType.kABGR_4444: 4>
kALL_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kALL_GrGLBackendState: 65535>
)
kALPHA8: GrGLFormat  # value = <GrGLFormat.kALPHA8: 3>
kARGB_4444_ColorType: ColorType  # value = <ColorType.kARGB_4444_ColorType: 3>
kASTC: EncodedImageFormat  # value = <EncodedImageFormat.kASTC: 9>
kAllResources: (
    GrPurgeResourceOptions  # value = <GrPurgeResourceOptions.kAllResources: 0>
)
kAlpha_16: GrColorType  # value = <GrColorType.kAlpha_16: 21>
kAlpha_8: GrColorType  # value = <GrColorType.kAlpha_8: 1>
kAlpha_8_ColorType: ColorType  # value = <ColorType.kAlpha_8_ColorType: 1>
kAlpha_8xxx: GrColorType  # value = <GrColorType.kAlpha_8xxx: 25>
kAlpha_ColorChannelFlag: (
    ColorChannelFlag  # value = <ColorChannelFlag.kAlpha_ColorChannelFlag: 8>
)
kAlpha_F16: GrColorType  # value = <GrColorType.kAlpha_F16: 16>
kAlpha_F32xxx: GrColorType  # value = <GrColorType.kAlpha_F32xxx: 26>
kB: ColorChannel  # value = <ColorChannel.kB: 2>
kBGRA8: GrGLFormat  # value = <GrGLFormat.kBGRA8: 6>
kBGRA_1010102_ColorType: ColorType  # value = <ColorType.kBGRA_1010102_ColorType: 8>
kBGRA_8888: GrColorType  # value = <GrColorType.kBGRA_8888: 9>
kBGRA_8888_ColorType: ColorType  # value = <ColorType.kBGRA_8888_ColorType: 6>
kBGR_101010x_ColorType: ColorType  # value = <ColorType.kBGR_101010x_ColorType: 10>
kBGR_565: GrColorType  # value = <GrColorType.kBGR_565: 2>
kBGR_H_PixelGeometry: PixelGeometry  # value = <PixelGeometry.kBGR_H_PixelGeometry: 2>
kBGR_V_PixelGeometry: PixelGeometry  # value = <PixelGeometry.kBGR_V_PixelGeometry: 4>
kBMP: EncodedImageFormat  # value = <EncodedImageFormat.kBMP: 0>
kBT2020_YUVColorSpace: YUVColorSpace  # value = <YUVColorSpace.kBT2020_YUVColorSpace: 5>
kBlend_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kBlend_GrGLBackendState: 8>
)
kBlue_ColorChannelFlag: (
    ColorChannelFlag  # value = <ColorChannelFlag.kBlue_ColorChannelFlag: 4>
)
kBottomLeft_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kBottomLeft_EncodedOrigin: 4>
)
kBottomLeft_GrSurfaceOrigin: (
    GrSurfaceOrigin  # value = <GrSurfaceOrigin.kBottomLeft_GrSurfaceOrigin: 1>
)
kBottomRight_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kBottomRight_EncodedOrigin: 3>
)
kCCW: PathDirection  # value = <PathDirection.kCCW: 1>
kCOMPRESSED_ETC1_RGB8: GrGLFormat  # value = <GrGLFormat.kCOMPRESSED_ETC1_RGB8: 16>
kCOMPRESSED_RGB8_BC1: GrGLFormat  # value = <GrGLFormat.kCOMPRESSED_RGB8_BC1: 18>
kCOMPRESSED_RGB8_ETC2: GrGLFormat  # value = <GrGLFormat.kCOMPRESSED_RGB8_ETC2: 17>
kCOMPRESSED_RGBA8_BC1: GrGLFormat  # value = <GrGLFormat.kCOMPRESSED_RGBA8_BC1: 19>
kCW: PathDirection  # value = <PathDirection.kCW: 0>
kCenter: textlayout_TextAlign  # value = <textlayout_TextAlign.kCenter: 2>
kClamp: TileMode  # value = <TileMode.kClamp: 0>
kClear: BlendMode  # value = <BlendMode.kClear: 0>
kClose: PathVerb  # value = <PathVerb.kClose: 5>
kCoeffCount: BlendModeCoeff  # value = <BlendModeCoeff.kCoeffCount: 10>
kColor: BlendMode  # value = <BlendMode.kColor: 27>
kColorBurn: BlendMode  # value = <BlendMode.kColorBurn: 19>
kColorDodge: BlendMode  # value = <BlendMode.kColorDodge: 18>
kConic: PathVerb  # value = <PathVerb.kConic: 3>
kConic_PathSegmentMask: (
    PathSegmentMask  # value = <PathSegmentMask.kConic_PathSegmentMask: 4>
)
kCubic: PathVerb  # value = <PathVerb.kCubic: 4>
kCubic_PathSegmentMask: (
    PathSegmentMask  # value = <PathSegmentMask.kCubic_PathSegmentMask: 8>
)
kDA: BlendModeCoeff  # value = <BlendModeCoeff.kDA: 8>
kDC: BlendModeCoeff  # value = <BlendModeCoeff.kDC: 4>
kDNG: EncodedImageFormat  # value = <EncodedImageFormat.kDNG: 10>
kDarken: BlendMode  # value = <BlendMode.kDarken: 16>
kDashed: textlayout_TextDecorationStyle  # value = <textlayout_TextDecorationStyle.kDashed: 3>
kDawn: gpuBackendApi  # value = <gpuBackendApi.kDawn: 0>
kDecal: TileMode  # value = <TileMode.kDecal: 3>
kDefault_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kTopLeft_EncodedOrigin: 1>
)
kDifference: ClipOp  # value = <ClipOp.kDifference: 0>
kDifference_PathOp: PathOp  # value = <PathOp.kDifference_PathOp: 0>
kDirect3D: GrBackendApi  # value = <GrBackendApi.kDirect3D: 3>
kDotted: textlayout_TextDecorationStyle  # value = <textlayout_TextDecorationStyle.kDotted: 2>
kDouble: textlayout_TextDecorationStyle  # value = <textlayout_TextDecorationStyle.kDouble: 1>
kDst: BlendMode  # value = <BlendMode.kDst: 2>
kDstATop: BlendMode  # value = <BlendMode.kDstATop: 10>
kDstIn: BlendMode  # value = <BlendMode.kDstIn: 6>
kDstOut: BlendMode  # value = <BlendMode.kDstOut: 8>
kDstOver: BlendMode  # value = <BlendMode.kDstOver: 4>
kEnd: textlayout_TextAlign  # value = <textlayout_TextAlign.kEnd: 5>
kEvenOdd: PathFillType  # value = <PathFillType.kEvenOdd: 1>
kExclusion: BlendMode  # value = <BlendMode.kExclusion: 23>
kExternal: GrTextureType  # value = <GrTextureType.kExternal: 3>
kFixedFunction_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kFixedFunction_GrGLBackendState: 512>
)
kFull: FontHinting  # value = <FontHinting.kFull: 3>
kG: ColorChannel  # value = <ColorChannel.kG: 1>
kGIF: EncodedImageFormat  # value = <EncodedImageFormat.kGIF: 1>
kGaps: textlayout_TextDecorationMode  # value = <textlayout_TextDecorationMode.kGaps: 0>
kGlyphID: TextEncoding  # value = <TextEncoding.kGlyphID: 3>
kGray_8: GrColorType  # value = <GrColorType.kGray_8: 14>
kGray_8_ColorType: ColorType  # value = <ColorType.kGray_8_ColorType: 14>
kGray_8xxx: GrColorType  # value = <GrColorType.kGray_8xxx: 27>
kGray_ColorChannelFlag: (
    ColorChannelFlag  # value = <ColorChannelFlag.kGray_ColorChannelFlag: 16>
)
kGray_F16: GrColorType  # value = <GrColorType.kGray_F16: 33>
kGreen_ColorChannelFlag: (
    ColorChannelFlag  # value = <ColorChannelFlag.kGreen_ColorChannelFlag: 2>
)
kHEIF: EncodedImageFormat  # value = <EncodedImageFormat.kHEIF: 11>
kHardLight: BlendMode  # value = <BlendMode.kHardLight: 20>
kHue: BlendMode  # value = <BlendMode.kHue: 25>
kICO: EncodedImageFormat  # value = <EncodedImageFormat.kICO: 2>
kIDA: BlendModeCoeff  # value = <BlendModeCoeff.kIDA: 9>
kIDC: BlendModeCoeff  # value = <BlendModeCoeff.kIDC: 5>
kISA: BlendModeCoeff  # value = <BlendModeCoeff.kISA: 7>
kISC: BlendModeCoeff  # value = <BlendModeCoeff.kISC: 3>
kIdentity_YUVColorSpace: (
    YUVColorSpace  # value = <YUVColorSpace.kIdentity_YUVColorSpace: 28>
)
kInner_BlurStyle: BlurStyle  # value = <BlurStyle.kInner_BlurStyle: 3>
kIntersect: ClipOp  # value = <ClipOp.kIntersect: 1>
kIntersect_PathOp: PathOp  # value = <PathOp.kIntersect_PathOp: 1>
kInverseEvenOdd: PathFillType  # value = <PathFillType.kInverseEvenOdd: 3>
kInverseWinding: PathFillType  # value = <PathFillType.kInverseWinding: 2>
kJPEG: EncodedImageFormat  # value = <EncodedImageFormat.kJPEG: 3>
kJPEG_YUVColorSpace: YUVColorSpace  # value = <YUVColorSpace.kJPEG_YUVColorSpace: 0>
kJustify: textlayout_TextAlign  # value = <textlayout_TextAlign.kJustify: 3>
kKTX: EncodedImageFormat  # value = <EncodedImageFormat.kKTX: 8>
kLUMINANCE16F: GrGLFormat  # value = <GrGLFormat.kLUMINANCE16F: 24>
kLUMINANCE8: GrGLFormat  # value = <GrGLFormat.kLUMINANCE8: 4>
kLast: ConvergeMode  # value = <ConvergeMode.kXor: 4>
kLastCoeffMode: BlendMode  # value = <BlendMode.kScreen: 14>
kLastEnum: ColorChannel  # value = <ColorChannel.kA: 3>
kLastEnum_AlphaType: AlphaType  # value = <AlphaType.kUnpremul_AlphaType: 3>
kLastEnum_BlurStyle: BlurStyle  # value = <BlurStyle.kInner_BlurStyle: 3>
kLastEnum_YUVColorSpace: (
    YUVColorSpace  # value = <YUVColorSpace.kIdentity_YUVColorSpace: 28>
)
kLastMode: BlendMode  # value = <BlendMode.kLuminosity: 28>
kLastSeparableMode: BlendMode  # value = <BlendMode.kMultiply: 24>
kLastTileMode: TileMode  # value = <TileMode.kDecal: 3>
kLast_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>
)
kLeft: textlayout_TextAlign  # value = <textlayout_TextAlign.kLeft: 0>
kLeftBottom_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kLeftBottom_EncodedOrigin: 8>
)
kLeftTop_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kLeftTop_EncodedOrigin: 5>
)
kLighten: BlendMode  # value = <BlendMode.kLighten: 17>
kLine: PathVerb  # value = <PathVerb.kLine: 1>
kLineThrough: (
    textlayout_TextDecoration  # value = <textlayout_TextDecoration.kLineThrough: 4>
)
kLine_PathSegmentMask: (
    PathSegmentMask  # value = <PathSegmentMask.kLine_PathSegmentMask: 1>
)
kLinear: MipmapMode  # value = <MipmapMode.kLinear: 2>
kLuminosity: BlendMode  # value = <BlendMode.kLuminosity: 28>
kMSAAEnable_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kMSAAEnable_GrGLBackendState: 16>
)
kMetal: gpuBackendApi  # value = <gpuBackendApi.kMetal: 1>
kMirror: TileMode  # value = <TileMode.kMirror: 2>
kMisc_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kMisc_GrGLBackendState: 1024>
)
kMock: gpuBackendApi  # value = <gpuBackendApi.kMock: 3>
kModulate: BlendMode  # value = <BlendMode.kModulate: 13>
kMove: PathVerb  # value = <PathVerb.kMove: 0>
kMultiply: BlendMode  # value = <BlendMode.kMultiply: 24>
kN32_ColorType: ColorType  # value = <ColorType.kBGRA_8888_ColorType: 6>
kNearest: MipmapMode  # value = <MipmapMode.kNearest: 1>
kNo: Budgeted  # value = <Budgeted.kNo: 0>
kNoDecoration: (
    textlayout_TextDecoration  # value = <textlayout_TextDecoration.kNoDecoration: 0>
)
kNone: GrTextureType  # value = <GrTextureType.kNone: 0>
kNormal: FontHinting  # value = <FontHinting.kNormal: 2>
kNormal_BlurStyle: BlurStyle  # value = <BlurStyle.kNormal_BlurStyle: 0>
kOne: BlendModeCoeff  # value = <BlendModeCoeff.kOne: 1>
kOpaque_AlphaType: AlphaType  # value = <AlphaType.kOpaque_AlphaType: 1>
kOpenGL: GrBackendApi  # value = <GrBackendApi.kOpenGL: 0>
kOpenGL_GrBackend: GrBackendApi  # value = <GrBackendApi.kOpenGL: 0>
kOuter_BlurStyle: BlurStyle  # value = <BlurStyle.kOuter_BlurStyle: 2>
kOverlay: BlendMode  # value = <BlendMode.kOverlay: 15>
kOverline: textlayout_TextDecoration  # value = <textlayout_TextDecoration.kOverline: 2>
kOverlineLineThrough: textlayout_TextDecoration  # value = <textlayout_TextDecoration.kOverlineLineThrough: 6>
kPKM: EncodedImageFormat  # value = <EncodedImageFormat.kPKM: 7>
kPNG: EncodedImageFormat  # value = <EncodedImageFormat.kPNG: 4>
kPixelStore_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kPixelStore_GrGLBackendState: 128>
)
kPlus: BlendMode  # value = <BlendMode.kPlus: 12>
kPremul_AlphaType: AlphaType  # value = <AlphaType.kPremul_AlphaType: 2>
kProgram_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kProgram_GrGLBackendState: 256>
)
kQuad: PathVerb  # value = <PathVerb.kQuad: 2>
kQuad_PathSegmentMask: (
    PathSegmentMask  # value = <PathSegmentMask.kQuad_PathSegmentMask: 2>
)
kR: ColorChannel  # value = <ColorChannel.kR: 0>
kR16: GrGLFormat  # value = <GrGLFormat.kR16: 20>
kR16F: GrGLFormat  # value = <GrGLFormat.kR16F: 9>
kR16G16B16A16_unorm_ColorType: (
    ColorType  # value = <ColorType.kR16G16B16A16_unorm_ColorType: 24>
)
kR16G16_float_ColorType: ColorType  # value = <ColorType.kR16G16_float_ColorType: 21>
kR16G16_unorm_ColorType: ColorType  # value = <ColorType.kR16G16_unorm_ColorType: 23>
kR8: GrGLFormat  # value = <GrGLFormat.kR8: 2>
kR8G8_unorm_ColorType: ColorType  # value = <ColorType.kR8G8_unorm_ColorType: 19>
kRG16: GrGLFormat  # value = <GrGLFormat.kRG16: 21>
kRG16F: GrGLFormat  # value = <GrGLFormat.kRG16F: 23>
kRG8: GrGLFormat  # value = <GrGLFormat.kRG8: 12>
kRGB10_A2: GrGLFormat  # value = <GrGLFormat.kRGB10_A2: 13>
kRGB565: GrGLFormat  # value = <GrGLFormat.kRGB565: 7>
kRGB8: GrGLFormat  # value = <GrGLFormat.kRGB8: 10>
kRGBA16: GrGLFormat  # value = <GrGLFormat.kRGBA16: 22>
kRGBA16F: GrGLFormat  # value = <GrGLFormat.kRGBA16F: 8>
kRGBA4: GrGLFormat  # value = <GrGLFormat.kRGBA4: 14>
kRGBA8: GrGLFormat  # value = <GrGLFormat.kRGBA8: 1>
kRGBA_1010102: GrColorType  # value = <GrColorType.kRGBA_1010102: 10>
kRGBA_1010102_ColorType: ColorType  # value = <ColorType.kRGBA_1010102_ColorType: 7>
kRGBA_16161616: GrColorType  # value = <GrColorType.kRGBA_16161616: 24>
kRGBA_8888: GrColorType  # value = <GrColorType.kRGBA_8888: 5>
kRGBA_8888_ColorType: ColorType  # value = <ColorType.kRGBA_8888_ColorType: 4>
kRGBA_8888_SRGB: GrColorType  # value = <GrColorType.kRGBA_8888_SRGB: 6>
kRGBA_ColorChannelFlags: (
    ColorChannelFlag  # value = <ColorChannelFlag.kRGBA_ColorChannelFlags: 15>
)
kRGBA_F16: GrColorType  # value = <GrColorType.kRGBA_F16: 17>
kRGBA_F16Norm_ColorType: ColorType  # value = <ColorType.kRGBA_F16Norm_ColorType: 15>
kRGBA_F16_Clamped: GrColorType  # value = <GrColorType.kRGBA_F16_Clamped: 19>
kRGBA_F16_ColorType: ColorType  # value = <ColorType.kRGBA_F16_ColorType: 16>
kRGBA_F32: GrColorType  # value = <GrColorType.kRGBA_F32: 20>
kRGBA_F32_ColorType: ColorType  # value = <ColorType.kRGBA_F32_ColorType: 18>
kRGB_101010x_ColorType: ColorType  # value = <ColorType.kRGB_101010x_ColorType: 9>
kRGB_565_ColorType: ColorType  # value = <ColorType.kRGB_565_ColorType: 2>
kRGB_888: GrColorType  # value = <GrColorType.kRGB_888: 29>
kRGB_888x: GrColorType  # value = <GrColorType.kRGB_888x: 7>
kRGB_888x_ColorType: ColorType  # value = <ColorType.kRGB_888x_ColorType: 5>
kRGB_ColorChannelFlags: (
    ColorChannelFlag  # value = <ColorChannelFlag.kRGB_ColorChannelFlags: 7>
)
kRGB_H_PixelGeometry: PixelGeometry  # value = <PixelGeometry.kRGB_H_PixelGeometry: 1>
kRGB_V_PixelGeometry: PixelGeometry  # value = <PixelGeometry.kRGB_V_PixelGeometry: 3>
kRG_1616: GrColorType  # value = <GrColorType.kRG_1616: 22>
kRG_88: GrColorType  # value = <GrColorType.kRG_88: 8>
kRG_ColorChannelFlags: (
    ColorChannelFlag  # value = <ColorChannelFlag.kRG_ColorChannelFlags: 3>
)
kRG_F16: GrColorType  # value = <GrColorType.kRG_F16: 23>
kR_16: GrColorType  # value = <GrColorType.kR_16: 31>
kR_8: GrColorType  # value = <GrColorType.kR_8: 30>
kR_F16: GrColorType  # value = <GrColorType.kR_F16: 32>
kRec601_YUVColorSpace: YUVColorSpace  # value = <YUVColorSpace.kRec601_YUVColorSpace: 1>
kRec709_YUVColorSpace: YUVColorSpace  # value = <YUVColorSpace.kRec709_YUVColorSpace: 3>
kRectangle: GrTextureType  # value = <GrTextureType.kRectangle: 2>
kRed_ColorChannelFlag: (
    ColorChannelFlag  # value = <ColorChannelFlag.kRed_ColorChannelFlag: 1>
)
kRenderTarget_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kRenderTarget_GrGLBackendState: 1>
)
kRepeat: TileMode  # value = <TileMode.kRepeat: 1>
kReverseDifference: ConvergeMode  # value = <ConvergeMode.kReverseDifference: 3>
kReverseDifference_PathOp: PathOp  # value = <PathOp.kReverseDifference_PathOp: 4>
kRight: textlayout_TextAlign  # value = <textlayout_TextAlign.kRight: 1>
kRightBottom_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kRightBottom_EncodedOrigin: 7>
)
kRightTop_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kRightTop_EncodedOrigin: 6>
)
kSA: BlendModeCoeff  # value = <BlendModeCoeff.kSA: 6>
kSC: BlendModeCoeff  # value = <BlendModeCoeff.kSC: 2>
kSRGB8_ALPHA8: GrGLFormat  # value = <GrGLFormat.kSRGB8_ALPHA8: 15>
kSaturation: BlendMode  # value = <BlendMode.kSaturation: 26>
kScratchResourcesOnly: (
    GrPurgeResourceOptions  # value = <GrPurgeResourceOptions.kScratchResourcesOnly: 1>
)
kScreen: BlendMode  # value = <BlendMode.kScreen: 14>
kSlight: FontHinting  # value = <FontHinting.kSlight: 1>
kSoftLight: BlendMode  # value = <BlendMode.kSoftLight: 21>
kSolid: (
    textlayout_TextDecorationStyle  # value = <textlayout_TextDecorationStyle.kSolid: 0>
)
kSolid_BlurStyle: BlurStyle  # value = <BlurStyle.kSolid_BlurStyle: 1>
kSrc: BlendMode  # value = <BlendMode.kSrc: 1>
kSrcATop: BlendMode  # value = <BlendMode.kSrcATop: 9>
kSrcIn: BlendMode  # value = <BlendMode.kSrcIn: 5>
kSrcOut: BlendMode  # value = <BlendMode.kSrcOut: 7>
kSrcOver: BlendMode  # value = <BlendMode.kSrcOver: 3>
kStart: textlayout_TextAlign  # value = <textlayout_TextAlign.kStart: 4>
kStencil_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kStencil_GrGLBackendState: 64>
)
kTextureBinding_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kTextureBinding_GrGLBackendState: 2>
)
kThrough: (
    textlayout_TextDecorationMode  # value = <textlayout_TextDecorationMode.kThrough: 1>
)
kTopLeft_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kTopLeft_EncodedOrigin: 1>
)
kTopLeft_GrSurfaceOrigin: (
    GrSurfaceOrigin  # value = <GrSurfaceOrigin.kTopLeft_GrSurfaceOrigin: 0>
)
kTopRight_EncodedOrigin: (
    EncodedOrigin  # value = <EncodedOrigin.kTopRight_EncodedOrigin: 2>
)
kUTF16: TextEncoding  # value = <TextEncoding.kUTF16: 1>
kUTF32: TextEncoding  # value = <TextEncoding.kUTF32: 2>
kUTF8: TextEncoding  # value = <TextEncoding.kUTF8: 0>
kUnderline: (
    textlayout_TextDecoration  # value = <textlayout_TextDecoration.kUnderline: 1>
)
kUnderlineLineThrough: textlayout_TextDecoration  # value = <textlayout_TextDecoration.kUnderlineLineThrough: 5>
kUnderlineOverline: textlayout_TextDecoration  # value = <textlayout_TextDecoration.kUnderlineOverline: 3>
kUnderlineOverlineLineThrough: textlayout_TextDecoration  # value = <textlayout_TextDecoration.kUnderlineOverlineLineThrough: 7>
kUnion: ConvergeMode  # value = <ConvergeMode.kUnion: 0>
kUnion_PathOp: PathOp  # value = <PathOp.kUnion_PathOp: 2>
kUnknown: GrGLFormat  # value = <GrGLFormat.kUnknown: 0>
kUnknown_AlphaType: AlphaType  # value = <AlphaType.kUnknown_AlphaType: 0>
kUnknown_ColorType: ColorType  # value = <ColorType.kUnknown_ColorType: 0>
kUnknown_PixelGeometry: (
    PixelGeometry  # value = <PixelGeometry.kUnknown_PixelGeometry: 0>
)
kUnpremul_AlphaType: AlphaType  # value = <AlphaType.kUnpremul_AlphaType: 3>
kVertex_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kVertex_GrGLBackendState: 32>
)
kView_GrGLBackendState: (
    GrGLBackendState  # value = <GrGLBackendState.kView_GrGLBackendState: 4>
)
kVulkan: gpuBackendApi  # value = <gpuBackendApi.kVulkan: 2>
kWBMP: EncodedImageFormat  # value = <EncodedImageFormat.kWBMP: 5>
kWEBP: EncodedImageFormat  # value = <EncodedImageFormat.kWEBP: 6>
kWavy: (
    textlayout_TextDecorationStyle  # value = <textlayout_TextDecorationStyle.kWavy: 4>
)
kWinding: PathFillType  # value = <PathFillType.kWinding: 0>
kXOR_PathOp: PathOp  # value = <PathOp.kXOR_PathOp: 3>
kXor: ConvergeMode  # value = <ConvergeMode.kXor: 4>
kYes: Budgeted  # value = <Budgeted.kYes: 1>
kZero: BlendModeCoeff  # value = <BlendModeCoeff.kZero: 0>

# skgpu: types.SimpleNamespace  # value = namespace(VulkanBackendContext=<class 'skia.GrVkBackendContext'>, VulkanAlloc=<class 'skia.GrVkAlloc'>, VulkanYcbcrConversionInfo=<class 'skia.GrVkYcbcrConversionInfo'>)
class skgpu:
    def __init__(self) -> typing.NoReturn: ...
    VulkanBackendContext: typing.ClassVar[type[GrVkBackendContext]]
    VulkanAlloc: typing.ClassVar[type[GrVkAlloc]]
    VulkanYcbcrConversionInfo: typing.ClassVar[type[GrVkYcbcrConversionInfo]]

# textlayout: types.SimpleNamespace  # value = namespace(FontCollection=<class 'skia.textlayout_FontCollection'>, ParagraphBuilder=<class 'skia.textlayout_ParagraphBuilder'>, ParagraphStyle=<class 'skia.textlayout_ParagraphStyle'>, Paragraph=<class 'skia.textlayout_Paragraph'>, TextStyle=<class 'skia.textlayout_TextStyle'>, TextAlign=<class 'skia.textlayout_TextAlign'>, TextDecoration=<class 'skia.textlayout_TextDecoration'>, TextDecorationStyle=<class 'skia.textlayout_TextDecorationStyle'>, TextDecorationMode=<class 'skia.textlayout_TextDecorationMode'>)
class textlayout:
    def __init__(self) -> typing.NoReturn: ...
    FontCollection: typing.ClassVar[type[textlayout_FontCollection]]
    ParagraphBuilder: typing.ClassVar[type[textlayout_ParagraphBuilder]]
    ParagraphStyle: typing.ClassVar[type[textlayout_ParagraphStyle]]
    Paragraph: typing.ClassVar[type[textlayout_Paragraph]]
    TextStyle: typing.ClassVar[type[textlayout_TextStyle]]
    TextAlign: typing.ClassVar[type[textlayout_TextAlign]]
    TextDecoration: typing.ClassVar[type[textlayout_TextDecoration]]
    TextDecorationStyle: typing.ClassVar[type[textlayout_TextDecorationStyle]]
    TextDecorationMode: typing.ClassVar[type[textlayout_TextDecorationMode]]

GrBackendRenderTargets = GrBackendRenderTarget
GrContext = GrDirectContext
GrDirectContexts = GrDirectContext
RuntimeBlendBuilder = RuntimeEffectBuilder
RuntimeColorFilterBuilder = RuntimeEffectBuilder
RuntimeShaderBuilder = RuntimeEffectBuilder
Surfaces = Surface

# Unknown
capsule = object
TextureCompressionType = object
GrContextThreadSafeProxy = object
VkSharingMode = object
Blender = object
